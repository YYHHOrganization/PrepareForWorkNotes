力扣 刷题 二分





## 二分

https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```C++
class Solution {
public:
    int lowerbound(vector<int>& nums, int target)
    {
        int n=nums.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if( nums[mid]<target)
                l=mid+1;
            else
                r=mid-1;
        }
        return l;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        //先判断start是否找到
        //第一个>=x
        int begin = lowerbound(nums,target);
        if(begin==n||nums[begin]!=target)
        {
            return {-1,-1};
        }
        //如果start找到了 那么end肯定也能找到
        //最后一个<=x 即  第一个 >=(x+1) 的索引-1
        int end = lowerbound(nums,target+1)-1;
        return {begin,end};
    }
};
```



### [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

```C++
class Solution {
public:
    int lowerBound(vector<int>& nums,int target)
    {
        int n=nums.size();
        int l=0;
        int r=nums.size()-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(nums[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    int maximumCount(vector<int>& nums) 
    {
        int n=nums.size();
        //获取第一个>0的数字 即第一个>=(0+1)的数字
        int Positivelower = lowerBound(nums,1);
        int posNum=n-Positivelower;
        //获取最后一个<0的数字，即第一个>=0的数字索引-1
        int NegUpper = lowerBound(nums,0)-1;
        int NegNum = NegUpper+1;
        return max(posNum,NegNum);

    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```C++
class Solution {
public:
    // int lowerBound(vector<int>& potions, long long spell,long long success)
    int lowerBound(vector<int>& potions, long long target)
    {
        int n=potions.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(potions[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) 
    {
        sort(potions.begin(),potions.end());
        //第一个  >= success / spells[i] // *spell[i]>=success
        int n= spells.size();
        vector<int> res(n,0);
        int nPotions = potions.size();
        for(int i=0;i<n;i++)
        {
            // long long target = ceil(success*1.0 / spells[i]); //这个向上取整可以
            long long target = (success+spells[i]-1) / spells[i];//这个向上取整也可以
            // cout<< target <<endl;

            int l=lowerBound(potions,target);
            res[i]+=(nPotions-l);
        } 
        return res;
    }
};
```




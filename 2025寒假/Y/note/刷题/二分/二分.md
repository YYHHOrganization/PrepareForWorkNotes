力扣 刷题 二分



34. 在排序数组中查找元素的第一个和最后一个位置 https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-zong-shi-xie-bu-dui-yi-g-t9l9/

课后作业：
2529. 正整数和负整数的最大计数 https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/
2300. 咒语和药水的成功对数 https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/
2563. 统计公平数对的数目 https://leetcode.cn/problems/count-the-number-of-fair-pairs/
275. H 指数 II https://leetcode.cn/problems/h-index-ii/
875. 爱吃香蕉的珂珂 https://leetcode.cn/problems/koko-eating-bananas/
2187. 完成旅途的最少时间 https://leetcode.cn/problems/minimum-time-to-complete-trips/
2861. 最大合金数 https://leetcode.cn/problems/maximum-number-of-alloys/
2439. 最小化数组中的最大值 https://leetcode.cn/problems/minimize-maximum-of-array/
2517. 礼盒的最大甜蜜度 https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/

课后作业题解：
2529 https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/solution/mo-ni-by-endlesscheng-8e43/
2300 https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/solution/by-endlesscheng-1kbp/
2563 https://leetcode.cn/problems/count-the-number-of-fair-pairs/solution/er-fen-cha-zhao-de-ling-huo-yun-yong-by-wplbj/
275 https://leetcode.cn/problems/h-index-ii/solution/tu-jie-yi-tu-zhang-wo-er-fen-da-an-si-ch-d15k/
875 https://leetcode.cn/problems/koko-eating-bananas/solution/er-fen-da-an-fu-ti-dan-pythonjavacgojsru-eb18/
2187 https://leetcode.cn/problems/minimum-time-to-complete-trips/solution/er-fen-da-an-python-yi-xing-gao-ding-by-xwvs8/
2861 https://leetcode.cn/problems/maximum-number-of-alloys/solution/er-fen-da-an-fu-ti-dan-by-endlesscheng-3jdr/
2439 https://leetcode.cn/problems/minimize-maximum-of-array/solution/liang-chong-zuo-fa-er-fen-da-an-fen-lei-qhee6/
2517 https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/solution/er-fen-da-an-by-endlesscheng-r418/

更多二分题目：
https://leetcode.cn/circle/discuss/SqopEo/

## 二分

lower_bound( begin,end,num)：从数组的begin位置到**end-1**位置二分查找**第一个大于或等于num**的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

upper_bound( begin,end,num)：从数组的begin位置到**end-1**位置二分查找**第一个大于num**的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。
————————————————

原文链接：https://blog.csdn.net/qq_40160605/article/details/80150252



>
>
>注意点：
>
>1、这层一定一定要加括号
>
>![image-20250224201743464](assets/image-20250224201743464.png)
>
>2、if( nums[mid]<target)//！这里l都是要不符合条件的，因为这样的话最后l才会停留在符合条件的地方 return l才对
>
>![image-20250224214716774](assets/image-20250224214716774.png)
>
>3、



https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```C++
class Solution {
public:
    int lowerbound(vector<int>& nums, int target)
    {
        int n=nums.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);//一定一定要加括号
            if( nums[mid]<target)//！这里l都是要不符合条件的，因为这样的话最后l才会停留在符合条件的地方 return l才对
                l=mid+1;
            else
                r=mid-1;
        }
        return l;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        //先判断start是否找到
        //第一个>=x
        int begin = lowerbound(nums,target);
        if(begin==n||nums[begin]!=target)
        {
            return {-1,-1};
        }
        //如果start找到了 那么end肯定也能找到
        //最后一个<=x 即  第一个 >=(x+1) 的索引-1
        int end = lowerbound(nums,target+1)-1;
        return {begin,end};
    }
};
```



### [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

```C++
class Solution {
public:
    int lowerBound(vector<int>& nums,int target)
    {
        int n=nums.size();
        int l=0;
        int r=nums.size()-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(nums[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    int maximumCount(vector<int>& nums) 
    {
        int n=nums.size();
        //获取第一个>0的数字 即第一个>=(0+1)的数字
        int Positivelower = lowerBound(nums,1);
        int posNum=n-Positivelower;
        //获取最后一个<0的数字，即第一个>=0的数字索引-1
        int NegUpper = lowerBound(nums,0)-1;
        int NegNum = NegUpper+1;
        return max(posNum,NegNum);

    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```C++
class Solution {
public:
    // int lowerBound(vector<int>& potions, long long spell,long long success)
    int lowerBound(vector<int>& potions, long long target)
    {
        int n=potions.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(potions[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) 
    {
        sort(potions.begin(),potions.end());
        //第一个  >= success / spells[i] // *spell[i]>=success
        int n= spells.size();
        vector<int> res(n,0);
        int nPotions = potions.size();
        for(int i=0;i<n;i++)
        {
            // long long target = ceil(success*1.0 / spells[i]); //这个向上取整可以
            long long target = (success+spells[i]-1) / spells[i];//这个向上取整也可以
            // cout<< target <<endl;

            int l=lowerBound(potions,target);
            res[i]+=(nPotions-l);
        } 
        return res;
    }
};
```

### 2529. 统计公平数对的数目


2529. 统计公平数对的数目 https://leetcode.cn/problems/count-the-number-of-fair-pairs/

##### 用C++接口

```C++
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) 
    {
        //逐个2分
        //或者滑动窗口 但是要排序 所以最小也是nlogn
        
        sort(nums.begin(),nums.end());
        long long cnt=0;
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            int target = lower-nums[i];
            //lower_bound第一个>=t的索引
            auto indexL = lower_bound(nums.begin(),nums.begin()+i, target);
           
            target = upper-nums[i];
             //upper_bound第一个>t的索引
            auto indexU = upper_bound(nums.begin(),nums.begin()+i,target);
            cnt += (indexU-indexL);//其实是 indexU-(indexL-1)+1
        }
        return cnt;
    }
};
```

lower_bound( begin,end,num)：从数组的begin位置到**end-1**位置二分查找**第一个大于或等于num**的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。

upper_bound( begin,end,num)：从数组的begin位置到**end-1**位置二分查找**第一个大于num**的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。
————————————————

原文链接：https://blog.csdn.net/qq_40160605/article/details/80150252

##### 自己写二分

```C++
class Solution {
public:
    int lowerBound(vector<int>& nums,int l,int r,int target)
    {
        // int l=0;
        // int r= nums.size()-1;
        while(l<=r)
        {
            int mid = (l+((r-l)>>1));
            if(nums[mid]<target)
            {
                l=mid+1;
            }
            else r=mid-1;
        }
        return l;
    }
    long long countFairPairs(vector<int>& nums, int lower, int upper) 
    {
        //逐个2分
        //或者滑动窗口 但是要排序 所以最小也是nlogn
        
        sort(nums.begin(),nums.end());
        long long cnt=0;
        int n=nums.size();
        for(int i=0;i<n;i++)
        {
            int target = lower-nums[i];
            //第一个>=t的索引
            int indexL = lowerBound(nums,i+1,n-1, target);
           
            target = upper-nums[i];
             //最后一个 <=t 第一个>=(x+1)-1
            int indexU = lowerBound(nums,i+1,n-1,target+1)-1;
            cnt += (indexU-indexL+1);
        }
        return cnt;
    }
};
```

### 2529. H 指数 II  :open_mouth:
2529. H 指数 II https://leetcode.cn/problems/h-index-ii/

正常写法：

```C++
class Solution {
public:
//https://leetcode.cn/problems/h-index-ii/solutions/870989/h-zhi-shu-ii-by-leetcode-solution-si7h/
    int lowerBound(vector<int>& citations,int n)
    {
        // int l=0,r=citations.size()-1;
        int l=0,r=citations.size()-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(citations[mid]<n-mid)//如果论文引用量 小于 后面那些符合要求的论文 说明h还可以更高 
            {
                l=mid+1;
            }
            else r=mid-1;
        }
        return n-l;
    }
    int hIndex(vector<int>& citations) {
        //论文的数量n-i 是  引用数量>=c[i]   的论文的数量
        int n=citations.size();
        int a=lowerBound(citations,n);
        return a;
    }
};
```



特殊情况：

输入

citations =

[100]

预期结果

1

这样的话其实应该输出1，也就是符合>=h的个数



非板子写法，不过可能更好理解点：

> if(citations[mid]>=n-mid)
>                r= mid-1;
>            else
>                l=mid+1;
>
>这里与板子写的是反的

```C++
class Solution {
public:
//https://leetcode.cn/problems/h-index-ii/solutions/870989/h-zhi-shu-ii-by-leetcode-solution-si7h/
    int lowerBound(vector<int>& citations,int n)
    {
        // int l=0,r=citations.size()-1;
        int l=0,r=citations.size()-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            //找到第一个满足条件citations[mid] >= n - mid的位置mid，(引用次数>=h)
            //此时h = n - mid（因为从mid到末尾共有n - mid篇论文，均满足引用次数≥h）
            if(citations[mid]>=n-mid)
                r= mid-1;
            else
                l=mid+1;
        }
        
        return n-l;
    }
    int hIndex(vector<int>& citations) {
        //论文的数量n-i 是  引用数量>=c[i]   的论文的数量
        //寻找 n-i <= c[i] 就是 c[i]+i>=n 的第一个值
        int n=citations.size();
        int a=lowerBound(citations,n);
        return a;
    }
};
```



### 2530. 爱吃香蕉的珂珂

2530. 爱吃香蕉的珂珂 https://leetcode.cn/problems/koko-eating-bananas/

Y:

```C++
class Solution {
public:
    long long eatTime(vector<int>& piles,int k)
    {
        long long sum=0;
        for(int i=0;i<piles.size();i++)
        {
            sum +=(long long)(piles[i]+k-1)/k;
        }
        return sum;
    }
    int minEatingSpeed(vector<int>& piles, int h) 
    {
        //每小时，第i堆吃k根  if <k,吃完
        // 3 6 7 11
        // 0 6 7 11
        // 0 2 7 11
        // 0 0 7 11
        // 0 0 3 11
        // 0 0 0 11

        //sum ceil(piles[i]/k) <=h
        //最小的第一个值 使得<=h

        int pilesN = piles.size();
        //满足 piles.length <= h  则一定能吃完，最快就是一小时吃 max_element
        int maxele = *max_element(piles.begin(),piles.end());

        // k ->(1 ~ pilesN)
        int l=1,r=maxele;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(eatTime(piles,mid)>h)//吃的总时间超过了 ，速度要加快
            {
                l=mid+1;
            }
            else r=mid-1;
        }
        //最后是l
        //第一个<=h的
        return l;

    }
};
```

### 2531. 完成旅途的最少时间 
2531. 完成旅途的最少时间 https://leetcode.cn/problems/minimum-time-to-complete-trips/







2532. 最大合金数 https://leetcode.cn/problems/maximum-number-of-alloys/
2533. 最小化数组中的最大值 https://leetcode.cn/problems/minimize-maximum-of-array/
2534. 礼盒的最大甜蜜度 https://leetcode.cn/problems/maximum-tastiness-of-candy-basket/


小电脑 项目位置

![image-20250218235055929](assets/image-20250218235055929.png)

![image-20250218223118650](assets/image-20250218223118650.png)

![image-20250218234541255](assets/image-20250218234541255.png)



```C++
{
    Properties
    {

        [Header(PBR)]
        [Space(10)]
        [MainTexture] _BaseMap("Albedo", 2D) = "white" {}
        [HDR][MainColor] _BaseColor("Color(PBR)", Color) = (1,1,1,1)
        _BumpMap("Normal Map", 2D) = "bump" {}
        _BumpScale("Scale", Float) = 1.0
        _Smoothness("Smoothness", Range(0.0, 1.0)) = 0.5
        _Metallic("Metallic", Range(0.0, 1.0)) = 0.0
        [HideInInspector]_AddlighIntensity("Add Intensity", Float) = 0.5
        [ToggleOff] _SpecularHighlights("Specular Highlights", Float) = 1.0
        [ToggleOff] _EnvironmentReflections("Environment Reflections", Float) = 1.0
        
        [Space(10)]
        
        _TransitionScale("Transition Scale", Float) = 0.8
        _Transition("Transition Parms", Vector) = (1,1,1,1)
        [HDR]_TransitionColor("Transition Color", Color) = (1,1,1,1)

        [Header(NPR)]
        [Space(10)]
        _BaseMap2("Albedo2", 2D) = "white" {}
        _BaseMap2("Albedo2", 2D) = "white" {}
        _Color1("Color(NPR)1", Color) = (1,1,1,1)
        _Color2("Color(NPR)2", Color) = (0.83,0.65,0.65,1)
        _Parms("Edge Parms", Vector) = (0.95,1,1,1)

        
        
        
        

        [Space(20)]

        [Header(RIM)]
        [Space(10)]
        _RimParm("Rim Edges", Vector) = (0.57,1,0.75,0.8)
        [HDR]_RimColorNPR("RimColor(NPR)", Color) = (0.75,0.53,0.16,1)
        [HDR]_RimColorPBR("Rim Color(PBR)", Color) = (0.4,0.22,0,1)
        [Space(20)]
        [Toggle]_IsNPCDead("NPC Dead", Float) = 0

        [HideInInspector] _ClearCoatMask("_ClearCoatMask", Float) = 0.0
        [HideInInspector] _ClearCoatSmoothness("_ClearCoatSmoothness", Float) = 0.0
        [HideInInspector] _SrcBlend("__src", Float) = 1.0
        [HideInInspector] _DstBlend("__dst", Float) = 0.0
        [HideInInspector] _SrcBlendAlpha("__srcA", Float) = 1.0
        [HideInInspector] _DstBlendAlpha("__dstA", Float) = 0.0
        [HideInInspector] _ZWrite("__zw", Float) = 1.0
        [HideInInspector] _BlendModePreserveSpecular("_BlendModePreserveSpecular", Float) = 1.0
        [HideInInspector] _AlphaToMask("__alphaToMask", Float) = 0.0
        [ToggleUI] _ReceiveShadows("Receive Shadows", Float) = 1.0
        _QueueOffset("Queue offset", Float) = 0.0
        [HideInInspector] _MainTex("BaseMap", 2D) = "white" {}
        [HideInInspector] _Color("Base Color", Color) = (1, 1, 1, 1)
        [HideInInspector] _GlossMapScale("Smoothness", Float) = 0.0
        [HideInInspector] _Glossiness("Smoothness", Float) = 0.0
        [HideInInspector] _GlossyReflections("EnvironmentReflections", Float) = 0.0
        [HideInInspector][NoScaleOffset]unity_Lightmaps("unity_Lightmaps", 2DArray) = "" {}
        [HideInInspector][NoScaleOffset]unity_LightmapsInd("unity_LightmapsInd", 2DArray) = "" {}
        [HideInInspector][NoScaleOffset]unity_ShadowMasks("unity_ShadowMasks", 2DArray) = "" {}
        
    }
    SubShader
    {
       

        Pass
{
   Name "Depth Rim"
   Tags
   {
      "LightMode" = "DepthOnly"
   }
   ZWrite On
   ColorMask 0
   Cull Off

   HLSLPROGRAM
   // Required to compile gles 2.0 with standard srp library
   #pragma vertex DepthOnlyVertex
   #pragma fragment DepthOnlyFragment
   #include "Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl"

   struct Attributes
   {
      float4 position     : POSITION;
      float2 texcoord     : TEXCOORD0;
      UNITY_VERTEX_INPUT_INSTANCE_ID
   };

   struct Varyings
   {
      float2 uv           : TEXCOORD0;
      float4 positionCS   : SV_POSITION;
      UNITY_VERTEX_INPUT_INSTANCE_ID
      UNITY_VERTEX_OUTPUT_STEREO
   };

   Varyings DepthOnlyVertex(Attributes input)
   {
      Varyings output = (Varyings)0;
      UNITY_SETUP_INSTANCE_ID(input);
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

      output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);
      output.positionCS = TransformObjectToHClip(input.position.xyz);
      return output;
   }

   half4 DepthOnlyFragment(Varyings input) : SV_TARGET
   {
       UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input);
       Alpha(SampleAlbedoAlpha(input.uv, TEXTURE2D_ARGS(_BaseMap, sampler_BaseMap)).a, _BaseColor, _Cutoff);
       return 0;
   }
            
   ENDHLSL
}
        Pass
        {
            Tags { "LightMode" = "UniversalForward" }
            Cull Off 
            ZWrite On
            //ZWrite Off
            Blend SrcAlpha OneMinusSrcAlpha

            HLSLPROGRAM

            #include "Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl"
            #include "MyUnlit.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            #pragma vertex vert
            #pragma fragment frag

            #pragma shader_feature _ _GI_ON
            #pragma multi_compile _ LIGHTMAP_ON
            #pragma multi_compile _ DIRLIGHTMAP_COMBINED
            #pragma shader_feature _ _RECEIVE_SHADOWS
            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS
            #pragma multi_compile _ _LIGHT_LAYERS
            #pragma multi_compile_instancing


            TEXTURE2D(_MainTex);    SAMPLER(sampler_MainTex);
            TEXTURE2D(_BaseMap2);    SAMPLER(sampler_BaseMap2);
            TEXTURE2D_X_FLOAT(_CameraDepthTexture); SAMPLER(sampler_CameraDepthTexture);

            half _AddlighIntensity, _TransitionScale, _IsNPCDead;
            half4 _Color1, _Color2, _RimParmNPR, _RimParmPBR, _RimParm, _TransitionColor;
            half4 _MainTex_ST, _BaseMap2_ST;
            half4 _Parms, _RimColorPBR, _RimColorNPR, _Transition;
            half3 vs;

            
           Varyings vert(Attributes input)
            {

                Varyings output = (Varyings)0;

                UNITY_SETUP_INSTANCE_ID(input);
                UNITY_TRANSFER_INSTANCE_ID(input, output);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

                VertexPositionInputs vertexInput = GetVertexPositionInputs(input.positionOS.xyz);

                VertexNormalInputs normalInput = GetVertexNormalInputs(input.normalOS, input.tangentOS);

                half3 vertexLight = VertexLighting(vertexInput.positionWS, normalInput.normalWS);

                half fogFactor = 0;
                #if !defined(_FOG_FRAGMENT)
                    fogFactor = ComputeFogFactor(vertexInput.positionCS.z);
                #endif

                output.uv = TRANSFORM_TEX(input.texcoord, _BaseMap);

                // already normalized from normal transform to WS.
                output.normalWS = normalInput.normalWS;
            #if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR) || defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)
                real sign = input.tangentOS.w * GetOddNegativeScale();
                half4 tangentWS = half4(normalInput.tangentWS.xyz, sign);
            #endif
            #if defined(REQUIRES_WORLD_SPACE_TANGENT_INTERPOLATOR)
                output.tangentWS = tangentWS;
            #endif

            #if defined(REQUIRES_TANGENT_SPACE_VIEW_DIR_INTERPOLATOR)
                half3 viewDirWS = GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);
                half3 viewDirTS = GetViewDirectionTangentSpace(tangentWS, output.normalWS, viewDirWS);
                output.viewDirTS = viewDirTS;
            #endif

                OUTPUT_LIGHTMAP_UV(input.staticLightmapUV, unity_LightmapST, output.staticLightmapUV);
            #ifdef DYNAMICLIGHTMAP_ON
                output.dynamicLightmapUV = input.dynamicLightmapUV.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
            #endif
                OUTPUT_SH(output.normalWS.xyz, output.vertexSH);
            #ifdef _ADDITIONAL_LIGHTS_VERTEX
                output.fogFactorAndVertexLight = half4(fogFactor, vertexLight);
            #else
                output.fogFactor = fogFactor;
            #endif

            #if defined(REQUIRES_WORLD_SPACE_POS_INTERPOLATOR)
                output.positionWS = vertexInput.positionWS;
            #endif

            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)
                output.shadowCoord = GetShadowCoord(vertexInput);
            #endif

                output.positionCS = vertexInput.positionCS;

                return output;
                vs = GetWorldSpaceNormalizeViewDir(vertexInput.positionWS);
            }

            float4 TransformHClipToViewPortPos(float4 positionCS)
            {
                float4 o = positionCS * 0.5f;
                o.xy = float2(o.x, o.y * _ProjectionParams.x) + o.w;
                o.zw = positionCS.zw;
                return o / o.w;
            }

            half4 frag(Varyings input): SV_Target
            {   

                SurfaceData surfaceData;
                InitializeStandardLitSurfaceData(input.uv, surfaceData);
            
            #ifdef LOD_FADE_CROSSFADE
                LODFadeCrossFade(input.positionCS);
            #endif
            
                InputData inputData;
                InitializeInputData(input, surfaceData.normalTS, inputData);
                SETUP_DEBUG_TEXTURE_DATA(inputData, input.uv, _BaseMap);
            
            #ifdef _DBUFFER
                ApplyDecalToSurfaceData(input.positionCS, surfaceData, inputData);
            #endif
            
                half4 color = UniversalFragmentPBR(inputData, surfaceData);
                color.rgb = MixFog(color.rgb, inputData.fogCoord);
                color.a = OutputAlpha(color.a, IsSurfaceTypeTransparent(_Surface));

                half4 shadowMask = CalculateShadowMask(inputData);
                AmbientOcclusionFactor aoFactor = CreateAmbientOcclusionFactor(inputData, surfaceData);
                Light spotlight = GetAdditionalLight (0, inputData, shadowMask, aoFactor);   
                uint meshRenderingLayers = GetMeshRenderingLayer();
                Light addLight;
                half3 NLCol = (1,1,1);
                half mask = 0;
                half mask2 = 0;
                half NL = 0;
                #ifdef _LIGHT_LAYERS
                if (IsMatchingLightLayer(spotlight.layerMask, meshRenderingLayers))
                #endif
                {
                    addLight = spotlight;
                    half3 lightDir1 = addLight.direction;
                    #ifdef _RECEIVE_SHADOWS
                    half lightAttenuation = addLight.distanceAttenuation * shadow;
                    #else
                    half lightAttenuation = addLight.distanceAttenuation;
                    #endif
                    mask = saturate(saturate(lightAttenuation)* addLight.color);
                    mask2 = mask * _TransitionScale;
                    NL = saturate(saturate(dot(input.normalWS,lightDir1)) * lightAttenuation) * _Parms.w;
                    NL = smoothstep(_Parms.x,_Parms.y,NL);
                    NLCol = lerp(_Color1,_Color2,NL);
                }
                

                Light dirlight = GetMainLight();
                half RimNL = saturate(dot(input.normalWS,dirlight.direction));
                half3 viewDir2 = normalize( _WorldSpaceCameraPos.xyz - normalize(input.positionWS));
                half NdotV2 = dot(normalize(input.normalWS), viewDir2);
                float FresnelValue = pow(1 - saturate(NdotV2), 3); 
                // half nv = saturate(dot(input.normalWS, vs));
                half3 rimPBR =smoothstep(_RimParm.x,_RimParm.y,RimNL * FresnelValue) * _RimColorPBR;
                half3 rimNPR =smoothstep(_RimParm.z,_RimParm.w,RimNL * FresnelValue) * _RimColorNPR ;

                half4 maskedge = (smoothstep(_Transition.x,_Transition.y,mask) - smoothstep(_Transition.z,_Transition.w,mask2)) * _TransitionColor;
                
                
                half3 basemap2 = saturate(SAMPLE_TEXTURE2D(_BaseMap2, sampler_BaseMap2, input.uv).rgb * NLCol) * _Parms.z;
                half3 output = lerp(saturate(color.rgb + rimPBR), saturate(basemap2.rgb + rimNPR),saturate(mask+ maskedge));

                

                if(_IsNPCDead)
                {
                    return 1;
                }

                // return half4(output.rgb,color.a) ;
                return half4(output.rgb,color.a);
            }
            ENDHLSL
        }


        Pass
        {
            Name "ShadowCaster"
            Tags
            {
                "LightMode" = "ShadowCaster"
            }


            ZWrite On
            ZTest LEqual
            ColorMask 0
            Cull[_Cull]

            HLSLPROGRAM
            #pragma target 2.0


            #pragma vertex ShadowPassVertex
            #pragma fragment ShadowPassFragment

            #pragma shader_feature_local_fragment _ALPHATEST_ON
            #pragma shader_feature_local_fragment _SMOOTHNESS_TEXTURE_ALBEDO_CHANNEL_A

            #pragma multi_compile_instancing
            #include_with_pragmas "Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl"

            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE

            #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW

            #include "Packages/com.unity.render-pipelines.universal/Shaders/LitInput.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/Shaders/ShadowCasterPass.hlsl"
            ENDHLSL
        }


        
    }
}

```





这个Shader的核心效果是通过聚光灯触发从PBR材质到卡通渲染（NPR）的动态切换，其核心逻辑主要集中在`UniversalForward`这个Pass的片段着色器（`frag`函数）中。

---

### **核心效果实现步骤**
#### **1. PBR基础渲染**
```glsl
half4 color = UniversalFragmentPBR(inputData, surfaceData);
```
- 先通过URP内置的`UniversalFragmentPBR`函数计算标准的PBR光照效果，作为基础颜色。

---

#### **2. 聚光灯遮罩计算**
```glsl
Light spotlight = GetAdditionalLight(0, inputData, shadowMask, aoFactor);
half mask = saturate(saturate(lightAttenuation) * addLight.color);
half mask2 = mask * _TransitionScale;
```
- `GetAdditionalLight`获取第一个附加光源（聚光灯）数据。
- `lightAttenuation`结合阴影和距离衰减，乘以灯光颜色得到聚光灯的影响区域遮罩`mask`。
- `mask2`通过`_TransitionScale`控制过渡范围。

---

#### **3. 卡通化明暗分界**
```glsl
half NL = saturate(dot(input.normalWS, lightDir1)) * lightAttenuation;
NL = smoothstep(_Parms.x, _Parms.y, NL) * _Parms.w;
half3 NLCol = lerp(_Color1, _Color2, NL);
```
- **NL（法线·光方向）** 计算漫反射强度，结合`smoothstep`生成硬边过渡效果。
- `_Parms.x`和`_Parms.y`控制明暗分界的阈值，`_Parms.w`调整整体强度。
- 使用`_Color1`和`_Color2`插值生成卡通风格的渐变颜色。

---

#### **4. 边缘光（Rim Light）**
```glsl
half3 viewDir2 = normalize(_WorldSpaceCameraPos - input.positionWS);
half NdotV2 = dot(input.normalWS, viewDir2);
float FresnelValue = pow(1 - saturate(NdotV2), 3);
half3 rimPBR = smoothstep(_RimParm.x, _RimParm.y, RimNL * FresnelValue) * _RimColorPBR;
half3 rimNPR = smoothstep(_RimParm.z, _RimParm.w, RimNL * FresnelValue) * _RimColorNPR;
```
- 计算基于菲涅尔效应的边缘光，`_RimParm`的xy和zw分别控制PBR和NPR边缘的宽度。
- `_RimColorPBR`和`_RimColorNPR`为不同风格指定边缘颜色。

---

#### **5. 动态过渡效果**
```glsl
half4 maskedge = (smoothstep(_Transition.x, _Transition.y, mask) - 
                smoothstep(_Transition.z, _Transition.w, mask2)) * _TransitionColor;
```
- 使用两组`smoothstep`生成聚光灯边缘的过渡区域，`_Transition`控制过渡曲线的形状。
- `_TransitionColor`为过渡区域叠加颜色（如高光）。

---

#### **6. 最终混合**
```glsl
half3 basemap2 = SAMPLE_TEXTURE2D(_BaseMap2, sampler_BaseMap2, input.uv).rgb * NLCol * _Parms.z;
half3 output = lerp(saturate(color.rgb + rimPBR), 
                  saturate(basemap2.rgb + rimNPR), 
                  saturate(mask + maskedge));
```
- `_BaseMap2`是卡通风格的贴图，与NLCol相乘得到NPR基础颜色。
- `lerp`根据聚光灯遮罩`mask`和过渡效果`maskedge`，在PBR和NPR之间动态混合。

---

### **关键参数说明**
- **`_TransitionScale`**: 控制聚光灯影响范围的缩放。
- **`_Parms`**: 
  - `x/y` - 明暗分界阈值
  - `z` - NPR贴图强度
  - `w` - 明暗对比强度
- **`_RimParm`**: 
  - `x/y` - PBR边缘光范围
  - `z/w` - NPR边缘光范围
- **`_Transition`**: 
  - `x/y` - 主过渡区域控制
  - `z/w` - 次过渡区域控制

---

### **顶点着色器补充**
- `vert`函数中计算了世界空间法线、切线等数据，特别注意末尾的`vs = GetWorldSpaceNormalizeViewDir(...)`可能存在错误（应整合到`Varyings`结构体中）。

---

### **效果示意图**
1. **无聚光灯时**: 显示标准PBR + PBR风格边缘光。
2. **聚光灯中心区域**: 完全切换为卡通着色（`_BaseMap2` + `NLCol`）。
3. **聚光灯边缘过渡区**: 叠加`_TransitionColor`的高光效果。

通过调整`_TransitionScale`和`_Transition`参数，可以控制聚光灯边缘的"硬边"或"柔边"效果。
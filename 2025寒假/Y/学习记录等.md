学习记录等

https://leetcode.cn/circle/discuss/0viNMK/

**定长滑动窗口**

- [x] 定长子串中元音的最大数目 1263 
- [x] 子数组最大平均数 I
- [x] 大小为 K 且平均值大于等于阈值的子数组数目 1317
- [x] 半径为 k 的子数组平均值 1358
- [x] 得到 K 个黑块的最少涂色次数 1360
- [x] 爱生气的书店老板 1418
- [x] 几乎唯一子数组的最大和 1546
- [x] 长度为 K 子数组中的最大和 1553
- [x] 可获得的最大点数 1574
- [x] 拆炸弹 做到 O(n)
- [x] 检查一个字符串是否包含所有长度为 K 的二进制子串 1504 【1】
- [ ] [2269. 找到一个数字的 K 美丽值](https://leetcode.cn/problems/find-the-k-beauty-of-a-number/) 1280
- [ ] [1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/) 1306
- [ ] [220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/)







**不定长滑动窗口**

不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。

**§2.1 求最长/最大**

- [x] 无重复字符的最长子串
- [x] 每个字符最多出现两次的最长子字符串 1329
- [x] 删掉一个元素以后全为 1 的最长子数组 1423
- [x] 尽可能使字符串相等 1497
- [x] 找到最长的半重复子字符串 1502
- [x] 水果成篮 1516
- [x] 删除子数组的最大得分 1529
- [x] 最多 K 个重复元素的最长子数组 1535
- [x] 数组的最大美丽值 1638
- [x] 考试的最大困扰度 1643
- [x] 最大连续 1 的个数 III 1656
- [x] [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)
- [x] [1838. 最高频元素的频数](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/)





§2.2 求最短/最小
一般题目都有「至少」的要求。

- [x] 长度最小的子数组
- [ ] 最短且字典序最小的美丽子字符串 做到$O(n^2)$
- [ ] 替换子串得到平衡字符串 1878
- [ ] 无限数组的最短子数组 1914
- [ ] 最小覆盖子串
- [ ] 最小区间 做法不止一种



- [x] [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
- [x] [42. 接雨水 ](https://leetcode.cn/problems/trapping-rain-water/)  M1
- [x] [42. 接雨水 ](https://leetcode.cn/problems/trapping-rain-water/)  M2
- [x] [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [x] [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)
- [x] [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

-----------

开始算

- [x] [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/) -1
- [x] [2302. 统计得分小于 K 的子数组数目](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/)
- [x] [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)
- [x] [1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)
- [x] [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)
- [x] [1750. 删除字符串两端相同字符后的最短长度](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/)
- [x] [658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)
- [x] [2824. 统计和小于目标的下标对数目](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/) -8
- [x] [15. 三数之和](https://leetcode.cn/problems/3sum/)
- [x] [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)




-------------

2/25

前缀和

2.前缀和与哈希表

- [x] （1）560. 和为 K 的子数组
- [x] [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

----

晚间 开始算	


- [x]   523. 连续的子数组和

- [x] 437. [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 啊

-------

2/26


- [x] [2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/)

- [x] 525. 连续数组

- [x] 面试题 17.05. 字母与数字 同 525 题

- [ ] 3026. 最大好子数组和 1817

3.距离和


- [ ] 





二分

- [x]  [2187. 完成旅途的最少时间](https://leetcode.cn/problems/minimum-time-to-complete-trips/)



### [1870. 准时到达的列车最小时速](https://leetcode.cn/problems/minimum-speed-to-arrive-on-time/)

```C++
class Solution {
public:
    long long getHour(vector<int>& dist, long long v)
    {
        int n=dist.size();
        long long sumhour =0;
        for(int i=0;i<n-1;i++)
        {
            sumhour+=(((long long)dist[i]-1)/v+1);
        }
        sumhour*=v;
        sumhour+=dist[n-1];
        return round(sumhour*100);
    }
    // //以下这样写是错的  原因在下面
    // long long getHour(vector<int>& dist, long long v)
    // {
    //     int n=dist.size();
    //     long long sumhour =0;
    //     for(int i=0;i<n-1;i++)
    //     {
    //         sumhour+=(((long long)dist[i]*100-1)/v+1);//
    //     }
    //     sumhour*=v;
    //     sumhour+=dist[n-1]*100;//
    //     return round(sumhour);//
    // }
    int minSpeedOnTime(vector<int>& dist, double hour) 
    {
        long long h100 = llround(hour*100);
        int n=dist.size();
        if(hour<=n-1)return -1;
        //getHour sum(di(0-n-2)/v)+di n-1/v <=hour
        //getHour sum(di(0-n-2)/v)*v+di n-1 <=hour*v
        //最后一个<=hour  111 222 444 算出来后最后一个<=hour的 第一个
        long long l=1,r=1e7;

        // long long maxdist = *max_element(dist.begin(),dist.end());
        // long long right = ((maxdist-1)/hour)+1;
        // r=right;
        while(l<=r)
        {
            long long mid = l+((r-l)>>1);
            // 时间小了，速度可以更慢点小一点
            // 时间大了，速度要更大
            if(getHour(dist, mid)>h100*mid) 
            {
                l=mid+1;
            }
            else r=mid-1;

        }
        return l;


    }
};
```



>
>
>要解决这个问题，我们需要找到最小的列车时速，使得按顺序乘坐所有列车后的总通勤时间不超过给定的时间。由于列车只能在整点发车，我们需要考虑等待时间。
>
>### 方法思路
>1. **问题分析**：
>   - 每趟列车（除了最后一趟）的运行时间需要向上取整，因为必须等到下一个整点才能发车。
>   - 最后一趟列车的运行时间不需要向上取整，因为它到达后不需要换乘。
>
>2. **关键思路**：
>   - 使用二分查找法来找到最小时速。二分查找的范围是1到10^7，因为题目保证答案不超过10^7。
>   - 通过转换计算避免浮点数精度问题，将小时转换为整数处理。
>
>3. **计算总时间**：
>   - 对于前n-1趟列车，计算每趟列车的运行时间并向上取整。
>   - 最后一趟列车的运行时间直接计算，不需要向上取整。
>   - 将总时间转换为整数处理以避免浮点误差。
>
>### 解决代码
>```cpp
>#include <vector>
>#include <cmath>
>#include <algorithm>
>
>using namespace std;
>
>class Solution {
>public:
>    long long getHour(vector<int>& dist, long long v) {
>        int n = dist.size();
>        long long sumhour = 0;
>        for (int i = 0; i < n - 1; ++i) {
>            sumhour += ((dist[i] + v - 1) / v; // 等价于ceil(dist[i]/v)
>        }
>        sumhour *= v; // 将前n-1趟的时间转换为总距离的整数倍
>        sumhour += dist.back(); // 加上最后一趟的距离
>        return sumhour * 100; // 转换为整数处理
>    }
>
>    int minSpeedOnTime(vector<int>& dist, double hour) {
>        long long h100 = llround(hour * 100);
>        int n = dist.size();
>        if (h100 < (n - 1) * 100) { // 总时间必须大于等于n-1小时
>            return -1;
>        }
>
>        long long left = 1;
>        long long right = 1e7;
>
>        while (left <= right) {
>            long long mid = left + (right - left) / 2;
>            long long total = getHour(dist, mid);
>            if (total > h100 * mid) { // 检查总时间是否超过允许的小时数
>                left = mid + 1;
>            } else {
>                right = mid - 1;
>            }
>        }
>
>        return left > 1e7 ? -1 : left;
>    }
>};
>```
>
>### 代码解释
>1. **getHour函数**：
>   - 计算前n-1趟列车的运行时间，向上取整后累加。
>   - 将累加的时间乘以速度转换为总距离，加上最后一趟列车的距离。
>   - 返回总时间的整数形式（乘以100以避免浮点误差）。
>
>2. **minSpeedOnTime函数**：
>   - 将给定小时转换为整数形式（h100）。
>   - 使用二分查找确定最小速度，检查每个中间速度是否满足总时间要求。
>   - 调整二分查找的左右边界，直到找到最小速度或确定无法按时到达。
>
>该方法通过避免浮点数计算，确保精度，有效解决了问题。



### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/) 啊

>#
>
>```C++
>
>
>class Solution {
>public:
>    int pathSum(TreeNode* root, int targetSum) {
>        if (!root) return 0;
>
>        // 前缀和字典
>        unordered_map<long long, int> prefix;
>        prefix[0] = 1; // 初始化前缀和为0的路径数量为1
>
>        // 辅助栈，存储节点、当前路径和、是否第一次访问
>        stack<pair<TreeNode*, pair<int, bool>>> st; // pair<节点, pair<当前路径和, 是否第一次访问>>
>        st.push({root, {root->val, true}}); // 初始节点
>
>        int result = 0;
>
>        while (!st.empty()) {
>            auto [node, curr_pair] = st.top();
>            st.pop();
>            long long curr = curr_pair.first;
>            bool is_first_visit = curr_pair.second;
>
>            if (is_first_visit) {
>                // 如果是第一次访问该节点
>                result += prefix[curr - targetSum]; // 查找当前前缀和 - target
>                prefix[curr]++; // 更新前缀和的数量
>
>                // 将当前节点再次加入栈，标记为回溯
>                st.push({node, {curr, false}});
>
>                // 如果有右子节点，将其加入栈
>                if (node->right) {
>                    st.push({node->right, {curr + node->right->val, true}});
>                }
>
>                // 如果有左子节点，将其加入栈
>                if (node->left) {
>                    st.push({node->left, {curr + node->left->val, true}});
>                }
>            } else {
>                // 如果是回溯阶段
>                prefix[curr]--; // 减少当前路径和的数量
>                if (prefix[curr] == 0) {
>                    prefix.erase(curr); // 如果数量为0，则从哈希表中移除
>                }
>            }
>        }
>
>        return result;
>    }
>};
>
>```
>
>这个只有一个过不了:
>
>输入
>
>root =
>
>[1000000000,1000000000,null,294967296,null,1000000000,null,1000000000,null,1000000000]
>
>targetSum =
>
>0
>
>
>
>添加到测试用例
>
>输出
>
>2
>
>预期结果
>
>
>
>0
>
>我
>
>我自己的写的错误的:还不知道为啥
>
>
>
>
>
>>迭代写法:错误的
>>
>>错误: 不知道为啥  
>>
>>```C++
>>/**
>> * Definition for a binary tree node.
>> * struct TreeNode {
>> *     int val;
>> *     TreeNode *left;
>> *     TreeNode *right;
>> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
>> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
>> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
>> * };
>> */
>>class Solution {
>>public:
>>    int pathSum(TreeNode* root, int targetSum) 
>>    {
>>        //每个叶子节点到根节点，维护前缀和 vec vec
>>        //只看一条链。 枚举右，维护左。 对于i，寻找map中是否有VAL[i]-target的值，+=map[VAL[i]-target]
>>        //每次新加入节点 看是否有 结合回溯来做
>>
>>        unordered_map<int,int> umap;
>>        //前序遍历
>>        stack<TreeNode* > st;
>>        // int sum=0;
>>        int res=0;
>>        TreeNode* node = root;
>>        while(!st.empty()||node!=nullptr)
>>        {
>>            while(node!=nullptr)
>>            {
>>                sum+=node->val;
>>                if(umap.contains(sum -targetSum))res+=umap[sum-targetSum];
>>                umap[sum]++;
>>                st.emplace(node);
>>                node=node->left;
>>            }
>>            node = st.top();
>>            umap[sum]--;
>>            if(umap[sum]==0)umap.erase(sum);
>>            sum-=node->val;
>>            st.pop();
>>            node = node->right;
>>        }
>>        return res;
>>    }
>>};
>>```
>>
>>









### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

https://www.bilibili.com/video/BV1Qg411q7ia/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

```C++
class Solution {
public:
    int maxArea(vector<int>& height) 
    {
        int l=0;
        int r=height.size()-1;
        int maxA = 0;

        while(l<=r)
        {
            int Area = (r-l)*min(height[r],height[l]);
            maxA = max(maxA,Area);
            if(height[l]<height[r])
            {
                l++;
            }
            else r--;
        }
        return maxA;
    }
};
```



###  [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

https://www.bilibili.com/video/BV1Qg411q7ia/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

#### 法1

时间复杂度O(n)

空间复杂度O(n)

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        vector<int> pre_max(n,0);
        vector<int> suf_max(n,0);//后缀（英语：suffix）
        pre_max[0]=height[0];
        for(int i=1;i<n;i++)pre_max[i] = max(pre_max[i-1],height[i]);
        suf_max[n-1]=height[n-1];
        for(int i=n-2;i>=0;i--)suf_max[i]=max(suf_max[i+1],height[i]);

        int res=0;
        for(int i=0;i<n;i++)
        {
            res+=min(suf_max[i],pre_max[i])-height[i];
            // cout<<res<<endl;
        }
        return res;
    }
};
```

#### 法2

时间复杂度O(n)

空间复杂度O(1)

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        int cnt=0;
        int maxL=0,maxR=0;
        int l=0,r=n-1;
        while(l<=r)
        {
            maxL=max(maxL,height[l]);//需要在外面更新 模拟那个双数组全更新
            maxR= max(maxR,height[r]);
            if(maxL<maxR)
            {
                cnt+=maxL-height[l];
                l++;
            }
            else
            {
                cnt+=maxR-height[r];
                r--;   
            }
        }
        return cnt;
    }
};
```



## 二分

https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```C++
class Solution {
public:
    int lowerbound(vector<int>& nums, int target)
    {
        int n=nums.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if( nums[mid]<target)
                l=mid+1;
            else
                r=mid-1;
        }
        return l;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        //先判断start是否找到
        //第一个>=x
        int begin = lowerbound(nums,target);
        if(begin==n||nums[begin]!=target)
        {
            return {-1,-1};
        }
        //如果start找到了 那么end肯定也能找到
        //最后一个<=x 即  第一个 >=(x+1) 的索引-1
        int end = lowerbound(nums,target+1)-1;
        return {begin,end};
    }
};
```



### [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

```C++
class Solution {
public:
    int lowerBound(vector<int>& nums,int target)
    {
        int n=nums.size();
        int l=0;
        int r=nums.size()-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(nums[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    int maximumCount(vector<int>& nums) 
    {
        int n=nums.size();
        //获取第一个>0的数字 即第一个>=(0+1)的数字
        int Positivelower = lowerBound(nums,1);
        int posNum=n-Positivelower;
        //获取最后一个<0的数字，即第一个>=0的数字索引-1
        int NegUpper = lowerBound(nums,0)-1;
        int NegNum = NegUpper+1;
        return max(posNum,NegNum);

    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```C++
class Solution {
public:
    // int lowerBound(vector<int>& potions, long long spell,long long success)
    int lowerBound(vector<int>& potions, long long target)
    {
        int n=potions.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(potions[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) 
    {
        sort(potions.begin(),potions.end());
        //第一个  >= success / spells[i] // *spell[i]>=success
        int n= spells.size();
        vector<int> res(n,0);
        int nPotions = potions.size();
        for(int i=0;i<n;i++)
        {
            // long long target = ceil(success*1.0 / spells[i]); //这个向上取整可以
            long long target = (success+spells[i]-1) / spells[i];//这个向上取整也可以
            // cout<< target <<endl;

            int l=lowerBound(potions,target);
            res[i]+=(nPotions-l);
        } 
        return res;
    }
};
```





## 双指针

### [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

```C++
class Solution {
public:
    int triangleNumber(vector<int>& nums) 
    {
        int n=nums.size();
        int a=0,b,c;
        sort(nums.begin(),nums.end());
        int res=0;
        // for(int c=n-1;c>=0;c--)
        for(int c=2;c<n;c++)
        {
            a=0,b=c-1;
            while(a<b)
            {
                if(nums[a]+nums[b]>nums[c])
                {
                    res+=(b-a);
                    b--;
                }
                else a++;
                
            }
            
        }
        return res;

    }
};
```




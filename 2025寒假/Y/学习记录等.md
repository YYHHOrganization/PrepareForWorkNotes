学习记录等

https://leetcode.cn/circle/discuss/0viNMK/

**定长滑动窗口**

- [x] 定长子串中元音的最大数目 1263 
- [x] 子数组最大平均数 I
- [x] 大小为 K 且平均值大于等于阈值的子数组数目 1317
- [x] 半径为 k 的子数组平均值 1358
- [x] 得到 K 个黑块的最少涂色次数 1360
- [x] 爱生气的书店老板 1418
- [x] 几乎唯一子数组的最大和 1546
- [x] 长度为 K 子数组中的最大和 1553
- [x] 可获得的最大点数 1574
- [x] 拆炸弹 做到 O(n)
- [x] 检查一个字符串是否包含所有长度为 K 的二进制子串 1504 【1】
- [ ] [2269. 找到一个数字的 K 美丽值](https://leetcode.cn/problems/find-the-k-beauty-of-a-number/) 1280
- [ ] [1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/) 1306
- [ ] [220. 存在重复元素 III](https://leetcode.cn/problems/contains-duplicate-iii/)







**不定长滑动窗口**

不定长滑动窗口主要分为三类：求最长子数组，求最短子数组，以及求子数组个数。

**§2.1 求最长/最大**

- [x] 无重复字符的最长子串
- [x] 每个字符最多出现两次的最长子字符串 1329
- [x] 删掉一个元素以后全为 1 的最长子数组 1423
- [x] 尽可能使字符串相等 1497
- [x] 找到最长的半重复子字符串 1502
- [x] 水果成篮 1516
- [x] 删除子数组的最大得分 1529
- [x] 最多 K 个重复元素的最长子数组 1535
- [x] 数组的最大美丽值 1638
- [x] 考试的最大困扰度 1643
- [x] 最大连续 1 的个数 III 1656
- [x] [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)
- [x] [1838. 最高频元素的频数](https://leetcode.cn/problems/frequency-of-the-most-frequent-element/)





§2.2 求最短/最小
一般题目都有「至少」的要求。

- [x] 长度最小的子数组
- [ ] 最短且字典序最小的美丽子字符串 做到$O(n^2)$
- [ ] 替换子串得到平衡字符串 1878
- [ ] 无限数组的最短子数组 1914
- [ ] 最小覆盖子串
- [ ] 最小区间 做法不止一种



- [x] [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
- [x] [42. 接雨水 ](https://leetcode.cn/problems/trapping-rain-water/)  M1
- [x] [42. 接雨水 ](https://leetcode.cn/problems/trapping-rain-water/)  M2
- [x] [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
- [x] [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)
- [x] [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

-----------

开始算

- [x] [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

- [x] [2302. 统计得分小于 K 的子数组数目](https://leetcode.cn/problems/count-subarrays-with-score-less-than-k/)

- [x] [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)

- [x] [1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

- [x] [1438. 绝对差不超过限制的最长连续子数组](https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)

- [x] [1750. 删除字符串两端相同字符后的最短长度](https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends/)

- [ ] 

  




-------------







### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

https://www.bilibili.com/video/BV1Qg411q7ia/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

```C++
class Solution {
public:
    int maxArea(vector<int>& height) 
    {
        int l=0;
        int r=height.size()-1;
        int maxA = 0;

        while(l<=r)
        {
            int Area = (r-l)*min(height[r],height[l]);
            maxA = max(maxA,Area);
            if(height[l]<height[r])
            {
                l++;
            }
            else r--;
        }
        return maxA;
    }
};
```



###  [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

https://www.bilibili.com/video/BV1Qg411q7ia/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

#### 法1

时间复杂度O(n)

空间复杂度O(n)

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        vector<int> pre_max(n,0);
        vector<int> suf_max(n,0);//后缀（英语：suffix）
        pre_max[0]=height[0];
        for(int i=1;i<n;i++)pre_max[i] = max(pre_max[i-1],height[i]);
        suf_max[n-1]=height[n-1];
        for(int i=n-2;i>=0;i--)suf_max[i]=max(suf_max[i+1],height[i]);

        int res=0;
        for(int i=0;i<n;i++)
        {
            res+=min(suf_max[i],pre_max[i])-height[i];
            // cout<<res<<endl;
        }
        return res;
    }
};
```

#### 法2

时间复杂度O(n)

空间复杂度O(1)

```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n=height.size();
        int cnt=0;
        int maxL=0,maxR=0;
        int l=0,r=n-1;
        while(l<=r)
        {
            maxL=max(maxL,height[l]);//需要在外面更新 模拟那个双数组全更新
            maxR= max(maxR,height[r]);
            if(maxL<maxR)
            {
                cnt+=maxL-height[l];
                l++;
            }
            else
            {
                cnt+=maxR-height[r];
                r--;   
            }
        }
        return cnt;
    }
};
```



## 二分

https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=f2def4aba42c7ed69fc648e1a2029c7b

### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```C++
class Solution {
public:
    int lowerbound(vector<int>& nums, int target)
    {
        int n=nums.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if( nums[mid]<target)
                l=mid+1;
            else
                r=mid-1;
        }
        return l;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int n=nums.size();
        //先判断start是否找到
        //第一个>=x
        int begin = lowerbound(nums,target);
        if(begin==n||nums[begin]!=target)
        {
            return {-1,-1};
        }
        //如果start找到了 那么end肯定也能找到
        //最后一个<=x 即  第一个 >=(x+1) 的索引-1
        int end = lowerbound(nums,target+1)-1;
        return {begin,end};
    }
};
```



### [2529. 正整数和负整数的最大计数](https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/)

```C++
class Solution {
public:
    int lowerBound(vector<int>& nums,int target)
    {
        int n=nums.size();
        int l=0;
        int r=nums.size()-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(nums[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    int maximumCount(vector<int>& nums) 
    {
        int n=nums.size();
        //获取第一个>0的数字 即第一个>=(0+1)的数字
        int Positivelower = lowerBound(nums,1);
        int posNum=n-Positivelower;
        //获取最后一个<0的数字，即第一个>=0的数字索引-1
        int NegUpper = lowerBound(nums,0)-1;
        int NegNum = NegUpper+1;
        return max(posNum,NegNum);

    }
};
```



### [2300. 咒语和药水的成功对数](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/)

```C++
class Solution {
public:
    // int lowerBound(vector<int>& potions, long long spell,long long success)
    int lowerBound(vector<int>& potions, long long target)
    {
        int n=potions.size();
        int l=0,r=n-1;
        while(l<=r)
        {
            int mid = l+((r-l)>>1);
            if(potions[mid]<target)
                l=mid+1;
            else r=mid-1;
        }
        return l;
    }
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) 
    {
        sort(potions.begin(),potions.end());
        //第一个  >= success / spells[i] // *spell[i]>=success
        int n= spells.size();
        vector<int> res(n,0);
        int nPotions = potions.size();
        for(int i=0;i<n;i++)
        {
            // long long target = ceil(success*1.0 / spells[i]); //这个向上取整可以
            long long target = (success+spells[i]-1) / spells[i];//这个向上取整也可以
            // cout<< target <<endl;

            int l=lowerBound(potions,target);
            res[i]+=(nPotions-l);
        } 
        return res;
    }
};
```





## 双指针

### [611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)

```C++
class Solution {
public:
    int triangleNumber(vector<int>& nums) 
    {
        int n=nums.size();
        int a=0,b,c;
        sort(nums.begin(),nums.end());
        int res=0;
        // for(int c=n-1;c>=0;c--)
        for(int c=2;c<n;c++)
        {
            a=0,b=c-1;
            while(a<b)
            {
                if(nums[a]+nums[b]>nums[c])
                {
                    res+=(b-a);
                    b--;
                }
                else a++;
                
            }
            
        }
        return res;

    }
};
```




# YH 2025 寒假学习计划

> 注：
>
> 【1】分割线表示可以休息两小时；
>
> 【2】==高亮部分表示不需要互相讲解的内容，但要提供学习内容和重点的笔记；==

## 规则

【1】完成每日任务=4抽，2月2号结算一次，提前完成可以提前抽

【2】额外学习内容：完成每日任务后，可以额外计时学习/运动，2小时1抽



## 记录

当前可用抽数（1抽==8元小礼物）

> 抽数5-1=4
>
> ￥40-8=32

总的抽数：

已使用抽数：

注释：

+5抽是因为胖胖1点半扣5抽

-1 学习时候看手机 被胖胖抓到



紧急：

腾讯实习1.16已开启，

雷火实习1.20已开启，DDL 2.5（剩余15天）

看手机-1抽



# 2025.1.20

## Y

- [ ] 【1】Leetcode：最大子数组和专题。参考https://leetcode.cn/circle/discuss/tXLS3i/ 1.3节，共7题左右。
  - [x] [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
  - [x] 2606：[找到最大开销的子字符串](https://leetcode.cn/problems/find-the-substring-with-maximum-cost/) 
  - [x] [1749. 任意子数组和的绝对值的最大值](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/)
  - [x] [1191. K 次串联后最大子数组之和](https://leetcode.cn/problems/k-concatenation-maximum-sum/)
  - [x] [918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)
  - [x] [2321. 拼接数组的最大分数](https://leetcode.cn/problems/maximum-score-of-spliced-array/) 
  - [x] [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

------

- [ ] 【2】继续做延迟渲染的教程，理解延迟渲染（2小时）（重点内容可以讲，==剩下部分可以直接看==）；

------

- [x] 运动一小时以上！！（1.19运动时间=2h，1.20 出去玩走了一天 也算2h吧）（19日提前完成-1）

抽数：	

## H

- [x] 【1】Leetcode：DFS基础
  - [x] [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)
  - [x] [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)
    - [x] 注意，这题C++ DFS会超时，可以用BFS或者并查集来做，而且这道题目也不能用邻接矩阵来做，要用邻接表（并查集很快！） 用了并查集
  - [x] [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)
  - [x] [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/) 
  - [x] [2316. 统计无向图中无法互相到达点对数](https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/)
    - [x] 这道题目有DFS和并查集两种做法，均可以尝试一下
      - [ ] DFS：有一定的学习价值
      - [x] **并查集：应该会比较快一些，但需要稍微改动一点并查集的代码，可以看下提交记录（值得讲一下）**
  - [x] [1319. 连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)
    - [x] dfs
    - [x] +并查集



------



- [ ] 【2】==游戏引擎架构：阅读第十章：渲染引擎==
- [ ] 【3】游戏引擎架构：复习第十一章：动画系统相关 （重点内容可以讲，==剩下部分可以直接看==）

- [x] 运动一小时以上！！（19日提前完成-2）

------

# 2025.1.21

## Y

- [ ] 【1】Leetcode：网格图DP
  - [x] [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
  - [x] [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
  - [x] [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)
  - [x] [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)
  - [x] [3393. 统计异或值为给定值的路径数目](https://leetcode.cn/problems/count-paths-with-the-given-xor-value/) 

------

- [ ] 【2】八股文集合

  - [x] ==介绍下A*算法==  D:\PGPostgraduate\githubNotePrepareForWork\PrepareForWorkNotes\2025寒假\Y\note\知识点\A星寻路算法

    https://zhuanlan.zhihu.com/p/385733813

    - [x] ==A*算法的缺点，为什么游戏中不使用==
    - [x] ==A*算法和Dijkstra算法的区别==

  - [x] ==SSAA，MSAA，FXAA==，TAA，==SMAA==（这个应该不用了解太多）  D:\PGPostgraduate\githubNotePrepareForWork\PrepareForWorkNotes\计算机图形学\图形学教程\Lesson 6——反走样技术.md

  - [x] 【增加】还可以提一下Nvidia的超分辨率DLSS系列全家桶。

  D:\PGPostgraduate\githubNotePrepareForWork\PrepareForWorkNotes\2025寒假\Y\note\知识点\超分辨率\超分辨率 DLSS等.md

  - [x] ==帧同步和状态同步==
  - [x] ==析构函数可以是虚函数么？==
  - [ ] ==Unity Monobehavior生命周期==（有重要的部分可以讲一下！）

    - [ ] 三个Update之间的区别，FixedUpdate是如何实现的稳定更新？
  - [ ] 总结一下游戏中的阴影实现方法。除了shadow map，PCF/PCSS，VSSM这些，最好再了解一些可以用于trick阴影的方法。
  - [ ] ==线程之间的通信方式==
  - [ ] Unity中的对象池介绍，必要内容，以及可以有一个手撕的简单对象池demo。（有需要简单讲一讲就好）
  - [ ] 【增加】在渲染中，透明物体的深度测试和深度写入

  

- [x] 【3】运动一小时以上！！（20日提前完成-1）

  今日运动2h 提前完成

------



## H

- [ ] 【1】Leetcode：BFS基础
  - [ ] [3243. 新增道路查询后的最短距离](https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/)
  - [ ] [1311. 获取你好友已观看的视频](https://leetcode.cn/problems/get-watched-videos-by-your-friends/)
  - [ ] [1129. 颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/)
  - [ ] [1298. 你能从盒子里获得的最大糖果数](https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/)
  - [ ] [2039. 网络空闲的时刻](https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/)
  - [ ] [2608. 图中的最短环](https://leetcode.cn/problems/shortest-cycle-in-a-graph/)
  - [ ] [815. 公交路线](https://leetcode.cn/problems/bus-routes/) 

------



- [ ] 【2】八股文集合：

  - [ ] ==子类的构造函数可以调虚函数吗？内联函数可以是虚函数么？==
  - [ ] ==static 和 const 的区别==
  - [ ] ==new 出来的对象可以用 free 释放吗，会报错吗==
  - [ ] ==面向对象三大特性==
  - [ ] ==编译器调试时看到的地址是物理地址还是逻辑地址==
  - [ ] C++虚函数部分全家桶，包括虚函数如何实现多态？虚表指针相关，以及各种函数能不能是虚函数，可以找找有没有虚函数部分的面经，集体总结一下。**重要的部分需要讲解。**
  - [ ] ==类的存储/C++的内存布局==
  - [ ] vector怎么实现的一定都要开辟再拷贝么？能不能在原来基础上开辟呢？vector 插入元素发生了什么？最好了解一下vector的所有面经，包括push_back&emplace_back这种
  - [ ] ==map和unordered_map区别== 简单说一下红黑树，为什么不用AVL树用红黑树
  - [ ] Unity的NavMesh系统原理了解一下，可以结合文档和youtube教程玩玩这个系统。

  

- [x] 【3】运动一小时以上！！（20日提前完成-2）

------



# 2025.1.22

## 互相分享

- [ ] 胖胖讲堂部分，讲解前面两天需要讲解的内容（包含一部分八股中的重点以及算法题目）；

------



## 其他

- [ ] 互相刷一下对方做过讲过的题目，学习对方分享的面经相关内容和链接；
- [ ] 复习1~2小时的图形学教程中的内容，有需要添加笔记的话记得互相通知一下防止冲突！
- [x] 运动一小时以上！！（21日运动2h 提前完成-1）

------



# 2025.1.23

## Y

- [ ] 【1】Leetcode：图论部分：DFS
  - [x] [2492. 两个城市间路径的最小分数](https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/)
  
  - [x] [3387. 两天自由外汇交易后的最大货币数](https://leetcode.cn/problems/maximize-amount-after-two-days-of-conversions/)
  
    这题目也是没谁了 以后没官方题解的 / 没人做的 就不做了
  
  - [ ] [3310. 移除可疑的方法](https://leetcode.cn/problems/remove-methods-from-project/)     :cold_sweat:  没官方题解的 and 没人做 不做 后面补题
  
  - [ ] [2685. 统计完全连通分量的数量](https://leetcode.cn/problems/count-the-number-of-complete-components/)    :cold_sweat:  没官方题解的 and 没人做 不做 后面补题
  
  - [x] [2192. 有向无环图中一个节点的所有祖先](https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/)
  
    - [x] 逆向DFS
  
    - [x] 【增加  补上题-1】 拓扑排序
  
  - [ ] [924. 尽量减少恶意软件的传播](https://leetcode.cn/problems/minimize-malware-spread/)

------

- [ ] 【2】八股部分：
  - [ ] ==C#会不会出现空引用？C++和C#的一些区别（这个问题太宽泛了，找一些比较经典的区别和考题就行）==
  - [ ] ==C++智能指针复习，手写玩具智能指针demo（包括计数、weakptr那些），智能指针的使用场景==。
    - [ ] `unique<ptr>`可以作为返回值么？智能指针是否是线程安全的？
  - [ ] ==操作系统进程和线程的区别==
  - [ ] ==enum class 的好处/和enum相比较==
  - [ ] ==说一下TCP协议和UDP协议的区别==
  - [ ] ==Drawcall具体是什么==, Unity中合批, 图集的概念是什么？静态合批和动态合批
  - [ ] ==两个AABB的相交和包含怎么判断？（二维/三维，给出思路和伪代码）==
  - [ ] https://zhuanlan.zhihu.com/p/430541328，这篇文章包含许多图形学八股，可以看一看，重要的题目可以在胖胖讲堂中分享（今天不一定看完）；



- [x] 运动一小时及以上！（21日运动2h 提前完成-2）

## H

- [ ] 【1】Leetcode：网格图dp基础
  - [x] [931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)
  - [x] [2684. 矩阵中移动的最大次数](https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/) 
  - [x] [2304. 网格中的最小路径代价](https://leetcode.cn/problems/minimum-path-cost-in-a-grid/) 
  - [x] [1289. 下降路径最小和 II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)
  - [x] [3418. 机器人可以获得的最大金币数](https://leetcode.cn/problems/maximum-amount-of-money-robot-can-earn/)
  - [x] [1594. 矩阵的最大非负积](https://leetcode.cn/problems/maximum-non-negative-product-in-a-matrix/)
- [ ] 【2】八股部分：
  - [ ] 了解一下ECS和Job System是什么？推荐可以看Games104对应这一节视频https://www.bilibili.com/video/BV1EP411V7jx?spm_id_from=333.788.videopod.sections&vd_source=f0e5ebbc6d14fe7f10f6a52debc41c99以及其下一节，如果讲的不错的话可以直接推荐！
  - [ ] RPC调用过程
  - [ ] C++八股文相关/其他基础知识八股，可以参考链接：https://github.com/huihut/interview?tab=readme-ov-file#design-pattern，https://zhuanlan.zhihu.com/p/417640759同样也是重要的地方讲一讲（今天不一定看完）；



- [x] 运动一小时及以上！（22日运动九日山2h 提前完成-1）



# 2025.1.24

## Y

- [ ] 【1】Leetcode DFS篇：
  - [ ] [2101. 引爆最多的炸弹](https://leetcode.cn/problems/detonate-the-maximum-bombs/)
  - [ ] [721. 账户合并](https://leetcode.cn/problems/accounts-merge/)
  - [ ] [207. 课程表](https://leetcode.cn/problems/course-schedule/) 
  - [ ] [802. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/) 
  - [ ] [928. 尽量减少恶意软件的传播 II](https://leetcode.cn/problems/minimize-malware-spread-ii/) 
  - [ ] [2092. 找出知晓秘密的所有专家](https://leetcode.cn/problems/find-all-people-with-secret/) 
  - [ ] [3108. 带权图里旅途的最小代价](https://leetcode.cn/problems/minimum-cost-walk-in-weighted-graph/) 

感觉可能有点难

![image-20250131154644137](assets/image-20250131154644137.png)

------

- [ ] 【2】图形学八股：https://zhuanlan.zhihu.com/p/430541328
- [x] 运动一小时以上！（22日运动九日山2h 提前完成-2）



## H

- [ ] 【1】Leetcode DP篇：
  - [ ] [1301. 最大得分的路径数目](https://leetcode.cn/problems/number-of-paths-with-max-score/)
  - [ ] [2435. 矩阵中和能被 K 整除的路径](https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/)
  - [ ] [174. 地下城游戏](https://leetcode.cn/problems/dungeon-game/)
  - [ ] [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/)
  - [ ] [2328. 网格图中递增路径的数目](https://leetcode.cn/problems/number-of-increasing-paths-in-a-grid/)
- [ ] 【2】背包部分：0-1背包
  - [ ] [2915. 和为目标值的最长子序列的长度](https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/)
  - [ ] [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)



------

- [ ] 【3】计算机基础知识八股继续看，可以参考链接：https://github.com/huihut/interview?tab=readme-ov-file#design-pattern（数据库之类的非游戏开发项可以不管），https://zhuanlan.zhihu.com/p/417640759
- [ ] 运动一小时以上！



# 2025.1.25

## 互相分享

- [ ] 胖胖讲堂部分，讲解前面两天需要讲解的内容（包含一部分八股中的重点以及算法题目）；

------



## 其他

- [ ] 互相刷一下对方做过讲过的题目，学习对方分享的面经相关内容和链接；
- [ ] 复习1~2小时的图形学教程中的内容，有需要添加笔记的话记得互相通知一下防止冲突！
- [x] 运动一小时以上！！（爬清源山登顶+走西街 6h 提前完成-1）



# 2025.1.26

## Y

【1】Leetcode算法：拓扑排序

- [ ] [1557. 可以到达所有点的最少点数目](https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/)：有助于理解拓扑排序
- [ ] [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)
- [ ] [1462. 课程表 IV](https://leetcode.cn/problems/course-schedule-iv/)
- [ ] [2115. 从给定原材料中找到所有可以做出的菜](https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/) 
- [ ] [851. 喧闹和富有](https://leetcode.cn/problems/loud-and-rich/) 
- [ ] [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)
- [ ] [2392. 给定条件下构造矩阵](https://leetcode.cn/problems/build-a-matrix-with-conditions/) 



- [ ] 【2】面经：
  - [ ] 继续看：https://zhuanlan.zhihu.com/p/430541328

- [x] 运动一小时以上！！（爬清源山登顶+走西街 6h 提前完成-2）

## H



- [ ] 【1】Leetcode算法：0-1背包问题：

  - [ ] [494. 目标和](https://leetcode.cn/problems/target-sum/)
  - [ ] [2787. 将一个数字表示成幂的和的方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/)
  - [ ] [3180. 执行操作可获得的最大总奖励 I](https://leetcode.cn/problems/maximum-total-reward-using-operations-i/)
  - [ ] [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)
  - [ ] [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/) 
  - [ ] [1774. 最接近目标价格的甜点成本](https://leetcode.cn/problems/closest-dessert-cost/)
  - [ ] [879. 盈利计划](https://leetcode.cn/problems/profitable-schemes/) 

  

- [ ] 【2】面经：
  - [ ] 计算机基础知识八股继续看，可以参考链接：https://github.com/huihut/interview?tab=readme-ov-file#design-pattern（数据库之类的非游戏开发项可以不管），https://zhuanlan.zhihu.com/p/417640759，https://www.xiaolincoding.com/

- [ ] 运动一小时以上！！

# 2025.1.27~2025.2.2

## 算法部分

一共7天，主要内容是补上面的，以及7天一共需要做30题。题单如下：

### Y

前缀和的题目

- [ ] 【1】[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)
- [ ] 【2】[2559. 统计范围内的元音字符串数](https://leetcode.cn/problems/count-vowel-strings-in-ranges/)
- [ ] 【3】[2389. 和有限的最长子序列](https://leetcode.cn/problems/longest-subsequence-with-limited-sum/)
- [ ] 【4】[3152. 特殊数组 II](https://leetcode.cn/problems/special-array-ii/) 
- [ ] 【5】[1749. 任意子数组和的绝对值的最大值](https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray/)
- [ ] 【6】[2438. 二的幂数组中查询范围内的乘积](https://leetcode.cn/problems/range-product-queries-of-powers/)
- [ ] 【7】[3361. 两个字符串的切换距离](https://leetcode.cn/problems/shift-distance-between-two-strings/) 
- [ ] 【8】[2055. 蜡烛之间的盘子](https://leetcode.cn/problems/plates-between-candles/)
- [ ] 【9】[1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？](https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/) 
- [ ] 【10】[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)（[题解：前缀和做法](https://leetcode.cn/problems/maximum-subarray/solution/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/)）

前缀和与哈希表

- [ ] 【11】[930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/) 
- [ ] 【12】[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)
- [ ] 【13】[1524. 和为奇数的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/) 
- [ ] 【14】[974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/) 
- [ ] 【15】[523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)
- [ ] 【16】[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)
- [ ] 【17】[2588. 统计美丽子数组数目](https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/)
- [ ] 【18】[525. 连续数组](https://leetcode.cn/problems/contiguous-array/)
- [ ] 【19】[3026. 最大好子数组和](https://leetcode.cn/problems/maximum-good-subarray-sum/) 
- [ ] 【20】[1477. 找两个和为目标值且不重叠的子数组](https://leetcode.cn/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/) 
- [ ] 【21】[1546. 和为目标值且不重叠的非空子数组的最大数目](https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/)
- [ ] 【22】[1124. 表现良好的最长时间段](https://leetcode.cn/problems/longest-well-performing-interval/) 
- [ ] 【23】[3381. 长度可被 K 整除的子数组的最大元素和](https://leetcode.cn/problems/maximum-subarray-sum-with-length-divisible-by-k/)
- [ ] 【24】[2488. 统计中位数为 K 的子数组](https://leetcode.cn/problems/count-subarrays-with-median-k/) 

前缀和与有序集合

- [ ] 【25】[3364. 最小正和子数组](https://leetcode.cn/problems/minimum-positive-sum-subarray/)

距离和

- [ ] 【26】[1685. 有序数组中差绝对值之和](https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/)
- [ ] 【27】[2615. 等值距离和](https://leetcode.cn/problems/sum-of-distances/) 
- [ ] 【28】[2602. 使数组元素全部相等的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal/)
- [ ] 【29】[2968. 执行操作使频率分数最大](https://leetcode.cn/problems/apply-operations-to-maximize-frequency-score/) 
- [ ] 【30】[1703. 得到连续 K 个 1 的最少相邻交换次数](https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/)

### H

**滑动窗口全家桶**

以下为定长滑动窗口

- [ ] 【1】[1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/) 
- [ ] 【2】[643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)
- [ ] 【3】[1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)
- [ ] 【4】[2090. 半径为 k 的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/)
- [ ] 【5】[2379. 得到 K 个黑块的最少涂色次数](https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/)
- [ ] 【6】[1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/) 
- [ ] 【7】[1461. 检查一个字符串是否包含所有长度为 K 的二进制子串](https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/)
- [ ] 【8】[2841. 几乎唯一子数组的最大和](https://leetcode.cn/problems/maximum-sum-of-almost-unique-subarray/) 
- [ ] 【9】[2461. 长度为 K 子数组中的最大和](https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k/)
- [ ] 【10】[1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)
- [ ] 【11】[1652. 拆炸弹](https://leetcode.cn/problems/defuse-the-bomb/) 
- [ ] 【12】[1297. 子串的最大出现次数](https://leetcode.cn/problems/maximum-number-of-occurrences-of-a-substring/)
- [ ] 【13】[2134. 最少交换次数来组合所有的 1 II](https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together-ii/)
- [ ] 【14】[2653. 滑动子数组的美丽值](https://leetcode.cn/problems/sliding-subarray-beauty/)
- [ ] 【15】[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)
- [ ] 【16】[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)
- [ ] 【17】[30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)
- [ ] 【18】[1016. 子串能表示从 1 到 N 数字的二进制串](https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n/)

以下为不定长滑动窗口：

- [ ] 【19】[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
- [ ] 【20】[3090. 每个字符最多出现两次的最长子字符串](https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/) 
- [ ] 【21】[1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/) 
- [ ] 【22】[1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)
- [ ] 【23】[2730. 找到最长的半重复子字符串](https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/)
- [ ] 【24】[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/) 
- [ ] 【25】[1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/)
- [ ] 【26】[2958. 最多 K 个重复元素的最长子数组](https://leetcode.cn/problems/length-of-longest-subarray-with-at-most-k-frequency/) 
- [ ] 【27】[2779. 数组的最大美丽值](https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/) 
- [ ] 【28】[2024. 考试的最大困扰度](https://leetcode.cn/problems/maximize-the-confusion-of-an-exam/) 
- [ ] 【29】[1004. 最大连续 1 的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/) 
- [ ] 【30】[1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/) 



## 面经部分

需要完成的内容：

- 这一周的时间，确保以下的八股文集锦里面的内容有进行遍历：
  - [ ] https://github.com/huihut/interview?tab=readme-ov-file#design-pattern，数据库之类的非游戏开发项可以不管
  - [ ] 计算机基础知识八股：https://zhuanlan.zhihu.com/p/417640759
  - [ ] 计算机图形学八股：https://zhuanlan.zhihu.com/p/430541328

- bonus：https://www.xiaolincoding.com/ 这里面有一些基础知识可以学习，但不作为强制学习的内容



## 其他

- [ ] 确保上面的算法题目和重要的八股面经都有通过胖胖讲堂进行讲解，并且有做复习、回顾和总结

  （选做）可以补全Games101，Games102，Games104中的没看部分，以及复习那些掌握不好的部分

- [ ] 确保每天尽量一个小时以上的运动量！

  - [x] （爬清源山登顶+走西街 6h 提前完成-3-6 补到30日 还有日常逛街 都算进去先不记了  每天打游戏都是站着玩！多亏了手柄嘿嘿）
  - [x] 30日走到世界城来回，+逛没有坐下 算运动2h  31+1日
  - [ ] 




后面有需要再学习的内容可以添加进来。

- [ ] （1）《游戏引擎架构》剩余的部分
- [ ] （2）《Effective C++》阅读
- [ ] （3）《More Effecive C++》阅读
- [ ] （4）额外的各种算法题



# 2025.2.3



# 2025.2.4



# 2025.2.5



# 2025.2.6



# 2025.2.7



# 2025.2.8

# 1、c++

### 1.1 `inline` 函数 `inline` 函数可以是虚函数吗？
`inline` 是 C++ 中的一个关键字，用于建议编译器将函数体直接插入到调用处，而不是通过常规的函数调用机制（如压栈、跳转等）来执行。这种优化可以减少函数调用的开销，尤其是对于短小且频繁调用的函数。

#### 特点：
1. **编译器建议**：
   - `inline` 只是一个建议，编译器可以选择忽略它。如果函数体过于复杂（如包含循环、递归等），编译器可能会拒绝内联。
   - 编译器也会根据优化级别自动内联一些函数，即使没有显式使用 `inline` 关键字。

2. **定义在头文件中**：
   - `inline` 函数的定义通常放在头文件中，因为编译器需要在每个调用处看到函数的完整定义才能内联展开。

3. **减少函数调用开销**：
   - 内联函数适合用于短小且频繁调用的函数，可以减少函数调用的开销（如压栈、跳转等）。

4. **可能增加代码体积**：
   - 如果内联函数被多次调用，函数体会被复制到每个调用处，可能会导致代码体积膨胀。

#### 示例：
```cpp
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(3, 4);  // 编译器可能会将 add 函数体直接插入到这里
    return 0;
}
```

---

### `inline` 函数可以是虚函数吗？
是的，`inline` 函数可以是虚函数，但需要注意以下几点：

1. **内联与虚函数的矛盾**：
   - 虚函数的核心机制是通过虚表（vtable）实现动态绑定，运行时根据对象的实际类型决定调用哪个函数。
   - `inline` 是编译期的优化，建议编译器将函数体直接插入到调用处。
   - 这两者的机制是矛盾的，因为虚函数需要在运行时确定调用哪个函数，而内联需要在编译期展开函数体。

2. **实际效果**：
   - 如果虚函数被声明为 `inline`，编译器可能会在编译期对某些调用进行内联优化（例如通过基类指针调用虚函数时，如果编译器能够确定实际类型）。
   - 但在大多数情况下，虚函数的调用是通过虚表动态分发的，无法内联。

3. **语法允许**：
   - C++ 语法允许将虚函数声明为 `inline`，但这种用法通常没有实际意义，甚至可能被编译器忽略。

#### 示例：
```cpp
class Base {
public:
    inline virtual void show() {  // inline 虚函数
        std::cout << "Base::show()" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived::show()" << std::endl;
    }
};

int main() {
    Base* obj = new Derived();
    obj->show();  // 运行时动态绑定，无法内联
    delete obj;
    return 0;
}
```

---

### 总结
- `inline` 函数是建议编译器将函数体直接插入到调用处的优化机制。
- `inline` 函数可以是虚函数，但由于虚函数的动态绑定特性，内联优化通常无法生效。
- 将虚函数声明为 `inline` 通常没有实际意义，除非编译器能够确定具体调用哪个函数（如通过对象直接调用）。



## ==（7）能用shared_ptr初始化unique_ptr吗？==

是的，在 C++ 中，可以使用 `std::shared_ptr` 来初始化 `std::unique_ptr`，但需要注意以下几点：

---

### 1. **直接初始化是不允许的**
`std::shared_ptr` 和 `std::unique_ptr` 是两种不同的智能指针，它们的管理方式和所有权语义不同：
- `std::shared_ptr` 允许多个指针共享所有权，通过引用计数管理资源。
- `std::unique_ptr` 独占所有权，不允许复制，只能移动。

因此，不能直接将 `std::shared_ptr` 赋值或初始化给 `std::unique_ptr`，因为它们的类型不兼容。

---

### 2. **通过 `release` 或手动提取指针**
如果你确实需要将 `std::shared_ptr` 管理的资源转移给 `std::unique_ptr`，可以通过以下步骤实现：
- 使用 `std::shared_ptr::get()` 获取原始指针。
- 使用 `std::shared_ptr::reset()` 释放 `std::shared_ptr` 对资源的所有权。
- 用原始指针初始化 `std::unique_ptr`。

#### 示例： 但是这个似乎跑不了
```cpp
#include <memory>
#include <iostream>

int main() {
    // 创建一个 shared_ptr
    std::shared_ptr<int> shared = std::make_shared<int>(42);

    // 获取原始指针
    int* rawPtr = shared.get();

    // 释放 shared_ptr 的所有权
    shared.reset();

    // 用原始指针初始化 unique_ptr
    std::unique_ptr<int> unique(rawPtr);

    // 验证 unique_ptr 是否接管了资源
    if (unique) {
        std::cout << "unique_ptr owns the resource: " << *unique << std::endl;
    }

    return 0;
}
```

---

### 3. **注意事项**
- **所有权转移**：通过上述方式，`std::shared_ptr` 会释放对资源的所有权，资源的管理权完全转移给 `std::unique_ptr`。这意味着 `std::shared_ptr` 不再管理该资源，如果继续使用 `std::shared_ptr` 可能会导致未定义行为。
- **避免双重释放**：确保在转移所有权后，不要通过 `std::shared_ptr` 或其他方式再次释放资源，否则会导致双重释放问题。
- **资源泄漏风险**：如果在转移过程中发生异常，可能会导致资源泄漏。因此，在实际代码中需要谨慎处理。

---

### 4. **更安全的做法**
如果你希望在不释放 `std::shared_ptr` 所有权的情况下创建一个 `std::unique_ptr`，可以使用 `std::unique_ptr` 的自定义删除器，让 `std::unique_ptr` 不实际管理资源，而是与 `std::shared_ptr` 共享所有权。

#### 示例：可以跑
```cpp
#include <memory>
#include <iostream>

int main() {
    // 创建一个 shared_ptr
    std::shared_ptr<int> shared = std::make_shared<int>(42);

    // 使用自定义删除器创建 unique_ptr
    std::unique_ptr<int, std::function<void(int*)>> unique(shared.get(), [shared](int*) mutable {
        // 自定义删除器，什么也不做，shared_ptr 仍然管理资源
    });

    // 验证 unique_ptr 和 shared_ptr 是否共享资源
    if (unique) {
        std::cout << "unique_ptr points to: " << *unique << std::endl;
    }
    if (shared) {
        std::cout << "shared_ptr points to: " << *shared << std::endl;
    }

    return 0;
}
```

在这个例子中，`std::unique_ptr` 的自定义删除器捕获了 `std::shared_ptr`，因此资源仍然由 `std::shared_ptr` 管理，`std::unique_ptr` 只是指向资源，但不会释放它。

---

### 5. **总结**
- 不能直接用 `std::shared_ptr` 初始化 `std::unique_ptr`，因为它们的类型不兼容。
- 可以通过提取原始指针并释放 `std::shared_ptr` 的所有权来转移资源。
- 如果需要共享资源，可以使用自定义删除器让 `std::unique_ptr` 不实际管理资源。
- 在实际代码中，需要谨慎处理所有权转移，避免资源泄漏或双重释放。



## RTTI和运行时多态 的关系

运行时类型信息（Runtime Type Information，简称RTTI）

不完全正确。**运行时类型信息（RTTI）** 和 **运行时多态** 是 C++ 中两个相关但不同的概念。它们都与运行时的类型处理有关，但解决的问题和实现机制不同。

---

### 1. **运行时多态（Runtime Polymorphism）**
运行时多态是面向对象编程的核心特性之一，主要通过虚函数（virtual functions）实现。它的核心思想是：
- 在运行时根据对象的实际类型决定调用哪个函数。
- 通过基类指针或引用调用虚函数时，实际调用的是派生类重写的函数。

#### 示例：
```cpp
#include <iostream>

class Base {
public:
    virtual void show() {
        std::cout << "Base::show()" << std::endl;
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived::show()" << std::endl;
    }
};

int main() {
    Base* obj = new Derived();
    obj->show();  // 运行时多态，调用 Derived::show()
    delete obj;
    return 0;
}
```

#### 特点：
- 运行时多态依赖于虚表（vtable）机制。
- 它关注的是函数调用的动态绑定。

---

### 2. **运行时类型信息（RTTI）**
RTTI 是 C++ 提供的一种机制，用于在运行时获取对象的类型信息。它主要通过以下两个操作符实现：
- **`typeid`**：获取对象的类型信息。
- **`dynamic_cast`**：在继承层次中进行安全的向下转型（downcasting）。

#### 示例：
```cpp
#include <iostream>
#include <typeinfo>

class Base {
public:
    virtual ~Base() = default;  // 必须有虚函数才能使用 RTTI
};

class Derived : public Base {};

int main() {
    Base* obj = new Derived();

    // 使用 typeid 获取类型信息
    std::cout << "Type of obj: " << typeid(*obj).name() << std::endl;

    // 使用 dynamic_cast 进行向下转型
    Derived* derived = dynamic_cast<Derived*>(obj);
    if (derived) {
        std::cout << "Downcast to Derived successful" << std::endl;
    }

    delete obj;
    return 0;
}
```

#### 特点：
- RTTI 依赖于虚表（vtable），因此只有包含虚函数的类才能使用 RTTI。
- 它关注的是类型的动态识别和转换。

---

### 3. **RTTI 和运行时多态的关系**
- **共同点**：
  - 两者都依赖于虚表（vtable）机制。
  - 都需要类中包含虚函数（否则无法使用 RTTI 或实现运行时多态）。

- **区别**：
  - **运行时多态** 关注的是函数调用的动态绑定（通过虚函数实现）。
  - **RTTI** 关注的是类型的动态识别和转换（通过 `typeid` 和 `dynamic_cast` 实现）。

- **依赖关系**：
  - RTTI 的实现依赖于运行时多态的基础设施（虚表）。
  - 但运行时多态并不依赖于 RTTI。

---

### 4. **总结**
- RTTI 和运行时多态是两个不同的概念，但它们都依赖于虚表机制。
- 运行时多态关注的是函数调用的动态绑定，而 RTTI 关注的是类型的动态识别和转换。
- RTTI 并不是运行时多态的一部分，但它们的实现机制有共同点（都需要虚函数和虚表）。

# C#

## 装箱和拆箱

https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing

①装箱就是隐式的将一个值类型转换为 `object` 类型/引用型对象

装箱时隐式的

常见语言运行时 (CLR) 对值类型进行装箱时，会将值包装在 [System.Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 实例中并将其存储在托管**堆**中。 

```C#
int a=0;
System.Object obj =a;
//或者
object obj=a;
```



②拆箱就是将一个引用型对象转换成任意值型 / 从对象中提取值类型

拆箱是显式的

```
int b=(int)obj; 
```

https://blog.csdn.net/michaelafeng/article/details/117460052

以下示例演示如何在 C# 中使用装箱。

C#

```csharp
// String.Concat example.
// String.Concat has many versions. Rest the mouse pointer on
// Concat in the following statement to verify that the version
// that is used here takes three object arguments. Both 42 and
// true must be boxed.
Console.WriteLine(String.Concat("Answer", 42, true));

// List example.
// Create a list of objects to hold a heterogeneous collection
// of elements.
List<object> mixedList = new List<object>();

// Add a string element to the list.
mixedList.Add("First Group:");

// Add some integers to the list.
for (int j = 1; j < 5; j++)
{
    // Rest the mouse pointer over j to verify that you are adding
    // an int to a list of objects. Each element j is boxed when
    // you add j to mixedList.
    mixedList.Add(j);
}

// Add another string and more integers.
mixedList.Add("Second Group:");
for (int j = 5; j < 10; j++)
{
    mixedList.Add(j);
}

// Display the elements in the list. Declare the loop variable by
// using var, so that the compiler assigns its type.
foreach (var item in mixedList)
{
    // Rest the mouse pointer over item to verify that the elements
    // of mixedList are objects.
    Console.WriteLine(item);
}

// The following loop sums the squares of the first group of boxed
// integers in mixedList. The list elements are objects, and cannot
// be multiplied or added to the sum until they are unboxed. The
// unboxing must be done explicitly.
var sum = 0;
for (var j = 1; j < 5; j++)
{
    // The following statement causes a compiler error: Operator
    // '*' cannot be applied to operands of type 'object' and
    // 'object'.
    //sum += mixedList[j] * mixedList[j];

    // After the list elements are unboxed, the computation does
    // not cause a compiler error.
    sum += (int)mixedList[j] * (int)mixedList[j];
}

// The sum displayed is 30, the sum of 1 + 4 + 9 + 16.
Console.WriteLine("Sum: " + sum);

// Output:
// Answer42True
// First Group:
// 1
// 2
// 3
// 4
// Second Group:
// 5
// 6
// 7
// 8
// 9
// Sum: 30
```

性能

相对于简单的赋值而言，装箱和取消装箱过程需要进行大量的计算。 对值类型进行装箱时，必须分配并构造一个新对象。 取消装箱所需的强制转换也需要进行大量的计算，只是程度较轻。 有关更多信息，请参阅[性能](https://learn.microsoft.com/zh-cn/dotnet/framework/performance/performance-tips)。

更具体一点：

### 装箱

装箱用于在垃圾回收堆中存储值类型。 装箱是[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)到 `object` 类型或到此值类型所实现的任何接口类型的隐式转换。 对值类型装箱会在堆中分配一个对象实例，并将该值复制到新的对象中。

请看以下值类型变量的声明：

```csharp
int i = 123;
```

以下语句对变量 `i` 隐式应用了装箱操作：

```csharp
// Boxing copies the value of i into object o.
object o = i;
```

此语句的结果是在堆栈上创建对象引用 `o`，而在堆上则引用 `int` 类型的值。 该值是赋给变量 `i` 的值类型值的一个副本。 以下装箱转换图说明了 `i` 和 `o` 这两个变量之间的差异：

![显示 i 和 o 变量之间的差异的图。](assets/boxing-operation-i-o-variables.gif)

还可以像下面的示例一样执行显式装箱，但显式装箱从来不是必需的：

```csharp
int i = 123;
object o = (object)i;  // explicit boxing
```



#### 示例

此示例使用装箱将整型变量 `i` 转换为对象 `o`。 这样一来，存储在变量 `i` 中的值就从 `123` 更改为 `456`。 该示例表明原始值类型和装箱的对象使用不同的内存位置，因此能够存储不同的值。

C#

```csharp
class TestBoxing
{
    static void Main()
    {
        int i = 123;

        // Boxing copies the value of i into object o.
        object o = i;

        // Change the value of i.
        i = 456;

        // The change in i doesn't affect the value stored in o.
        System.Console.WriteLine("The value-type value = {0}", i);
        System.Console.WriteLine("The object-type value = {0}", o);
    }
}
/* Output:
    The value-type value = 456
    The object-type value = 123
*/
```



### 取消装箱

取消装箱是从 `object` 类型到[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)或从接口类型到实现该接口的值类型的显式转换。 取消装箱操作包括：

- 检查对象实例，以确保它是给定值类型的装箱值。
- 将该值从实例复制到值类型变量中。

下面的语句演示装箱和取消装箱两种操作：

C#

```csharp
int i = 123;      // a value type
object o = i;     // boxing
int j = (int)o;   // unboxing
```

下图演示了上述语句的结果：

![显示取消装箱转换的图。](assets/unboxing-conversion-operation.gif)

要在运行时成功取消装箱值类型，被取消装箱的项必须是对一个对象的引用，该对象是先前通过装箱该值类型的实例创建的。 尝试取消装箱 `null` 会导致 [NullReferenceException](https://learn.microsoft.com/zh-cn/dotnet/api/system.nullreferenceexception)。 尝试取消装箱对不兼容值类型的引用会导致 [InvalidCastException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidcastexception)。



#### 示例

下面的示例演示无效的取消装箱及引发的 `InvalidCastException`。 使用 `try` 和 `catch`，在发生错误时显示错误信息。

C#

```csharp
class TestUnboxing
{
    static void Main()
    {
        int i = 123;
        object o = i;  // implicit boxing

        try
        {
            int j = (short)o;  // attempt to unbox

            System.Console.WriteLine("Unboxing OK.");
        }
        catch (System.InvalidCastException e)
        {
            System.Console.WriteLine("{0} Error: Incorrect unboxing.", e.Message);
        }
    }
}
```

此程序输出：

```
Specified cast is not valid. Error: Incorrect unboxing.
```

如果将下列语句：

```csharp
int j = (short)o;
```

更改为：

```csharp
int j = (int)o;
```

将执行转换，并将得到以下输出：

```
Unboxing OK.
```



**C#中可以给class装箱吗**

gpt:

在C#中，装箱（Boxing）是将值类型（例如`int`, `float`, `struct`等）转换为引用类型（如`object`或接口类型）的过程。然而，对于类（class）类型，本身就是引用类型，因此不需要装箱。

### 装箱和拆箱的概念

- **装箱 (Boxing)**：将值类型封装到一个对象中。这通常发生在将值类型赋给一个`object`类型的变量时。

  ```
  csharp复制代码int number = 42;
  object boxedNumber = number; // 装箱
  ```

- **拆箱 (Unboxing)**：将被装箱的对象还原为其原始值类型。

  ```
  csharp复制代码int unboxedNumber = (int)boxedNumber; // 拆箱
  ```

### 类的特性

由于类本身是引用类型，所以你不需要执行装箱操作。例如：

```
csharp复制代码class MyClass
{
    public int Value { get; set; }
}

// 实例化类
MyClass myObject = new MyClass();
object obj = myObject; // 这里没有装箱，因为 myObject 已经是引用类型
```

在上面的代码中，你可以直接将`MyClass`实例赋给一个`object`类型的变量，而不涉及任何装箱过程。

### 总结

- **装箱**：只适用于值类型。
- **类**：作为引用类型，不需要装箱。



关于装箱拆箱大的作用：

https://www.runoob.com/csharp/csharp-arraylist.html

- `ArrayList` 是非泛型集合，所有元素被存储为 `object` 类型。这意味着它可以存储任意类型的对象，但需要注意装箱（boxing）和拆箱（unboxing）的性能影响。



## 工厂模式

工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为**简单工厂模式**和**工厂方法模式**，根据工厂的抽象程度可分为工厂方法模式和**抽象工厂模式**。该模式用于封装和管理对象的创建，是一种创建型模式。

具体看**https://www.cnblogs.com/yssjun/p/11102162.html**

### 简单工厂模式

![img](assets/1419489-20190628144601084-563759643.png)

### 工厂方法模式

和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂

![img](assets/1419489-20190628154133368-906051111.png)

### 抽象工厂模式

上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品**Phone**（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。

![img](assets/1419489-20190628164001258-637961514.png)





# Leetcode:

##  1.最大子数组和

DP:

```C++
class Solution 
{
public:
    int maxSubArray(vector<int>& nums) 
    {
        //dp[i] 表示以 nums[i] *结尾* 的最大子数组和。
        int n =nums.size();
        // int dp[100010]={0};
        vector<int> dp(n,0);
        int maxNum=nums[0];//[-1]
        dp[0]=nums[0];
        for(int i=1;i<n;i++)
        {
            dp[i]=max(dp[i-1],0)+nums[i];
            maxNum=max(maxNum,dp[i]);
        }
        // return maxNum;
        //或者C++20 新特性:
        return maxNum;
    }
};
```

或者滑动窗口）应该可以？



## 2.判断括号字符串是否有效，有三种括号{},[],()，()里面有[],{}也是非法的，[]里面有{}也非法。

//[  {}[][{

#### 2.1 没有优先级的情况下  [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

没有优先级的情况下：

```C++
#define kuohao
#ifdef kuohao

#include<iostream>
#include<stack>
using namespace std;
//empty )]}
//temp={[(
bool isValid(string s)
{
	stack<char> st;
	for (int i = 0; i < s.size(); i++)
	{
		if (st.empty())
		{
			if (s[i] == ')' || s[i] == ']' || s[i] == '}')return false;
			st.push(s[i]);
		}
		else
		{
			char topS = st.top();
			if (s[i] == ')')
			{
				if (topS == '(')st.pop();
				else st.push(s[i]);
			}
			else if (s[i] == '}')
			{
				if (topS == '{')st.pop();
				else st.push(s[i]);
			}
			else if (s[i] == ']')
			{
				if (topS == '[')st.pop();
				else st.push(s[i]);
			}
			else//([{
			{
				st.push(s[i]);
			}
		}
	}
	if (st.empty())return true;
	return false;
}
int main()
{
	string str1 = "()";
	cout << isValid(str1);
	return 0;
}

#endif
```

比较冗余，可以优化为

```C++
class Solution {
public:
    bool isValid(string s) {
	stack<char> st;
	for (int i = 0; i < s.size(); i++)
	{
		if (st.empty())
		{
			if (s[i] == ')' || s[i] == ']' || s[i] == '}')return false;
			st.push(s[i]);
		}
		else
		{
			char topS = st.top();
			if ((s[i] == ')'&&topS == '(')||
            (s[i] == ']'&&topS == '[')||
            (s[i] == '}'&&topS == '{'))
			{
				st.pop();
			}
            else st.push(s[i]);
		}
	}
	if (st.empty())return true;
	return false;
}
};
```



官方：

```C++
class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1) {
            return false;
        }

        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) {
                if (stk.empty() || stk.top() != pairs[ch]) {
                    return false;
                }
                stk.pop();
            }
            else {
                stk.push(ch);
            }
        }
        return stk.empty();
    }
};

作者：力扣官方题解
链接：https://leetcode.cn/problems/valid-parentheses/solutions/373578/you-xiao-de-gua-hao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### 有优先级的情况下：

me:以下正确

https://www.acwing.com/file_system/file/content/whole/index/content/12618509/

```C++
#include<iostream>
#include<stack>
#include<unordered_map>
#include<string>
using namespace std;
bool isValid(string str, unordered_map<char, int>& m)
{
    stack<char> st;
    for (int i = 0; i < str.size(); i++)
    {
        //)  1、空 false  2、！=（ false
        if (m[str[i]] > 0)
        {
            if (st.empty() || m[str[i]] != -1 * m[st.top()])
                return false;//)
            //else if (!st.empty() && m[str[i]] == -1 * m[st.top()]) 上面那句的反面就是这句 所以并不需要
            st.pop();
        }
        else if (m[str[i]] < 0) // [-3 {-4  
        {
            if (!st.empty()&&m[str[i]] < m[st.top()])
                return false;
            else st.push(str[i]);
        }

    }
    if (!st.empty())return false;
    return true;
}
int main()//2010-2044
{
    int n;
    cin >> n;
    unordered_map<char, int> m;
    m['{'] = -4; m['}'] = 4;
    m['['] = -3; m[']'] = 3;
    m['('] = -2; m[')'] = 2;
    m['<'] = -1; m['>'] = 1;
    for (int i = 0; i < n; i++)
    {
        string str;
        cin >> str;
        cout << (isValid(str, m) == true ? "YES" : "NO") << endl;
    }
    return 0;
}

```



不确定是否正确啊 因为没有找到题目和判题网站

```C++
//有优先级的情况下
#define kuohaoYX1
#ifdef kuohaoYX

#include<iostream>
#include<stack>
using namespace std;
//empty )]}
//temp={[(
bool isValid(string s)
{
	stack<char> st;
	for (int i = 0; i < s.size(); i++)
	{
		if (st.empty())
		{
			if (s[i] == ')' || s[i] == ']' || s[i] == '}')return false;
			st.push(s[i]);
		}
		else
		{
			char topS = st.top();
			if (s[i] == ')')//([{//}])
			{
				if (topS == '(')st.pop();
				else st.push(s[i]);
			}
			else if (s[i] == ']')
			{
				if (topS == '[')st.pop();
				else st.push(s[i]);
			}
			else if (s[i] == '}')
			{
				if (topS == '{')st.pop();
				else st.push(s[i]);
			}
			if (s[i] == '(')//([{//}])
			{
				st.push(s[i]);
			}
			else if (s[i] == '[')
			{
				if (topS == '(')return false;
				else st.push(s[i]);
			}
			else if (s[i] == '{')
			{
				if (topS == '['||topS=='(')return false;
				else st.push(s[i]);
			}

			
		}
	}
	if (st.empty())return true;
	return false;
}
int main()
{
	/*string str1 = "([])";
	cout << isValid(str1);
	str1 = "([])";
	cout << isValid(str1);*/
	string testCases[] = {
		"([])",     
		"{[()]}",   
		"{[(])}",   
		"{}[]()",   
		"([{}])",   
		"((()))",   
		"[{()}]",   
		"[{(})]",   
		"(",        
		")",        
		"]",        
		"[",        
		"{{{{}}}}", 
		"(((([]))))"
		"({[{()[]}]}())", 
		"({[)}]",    
		"}{",        
		"([)]",      
		"([{}][]){}",
		"[]{}()()",  
		"([{}]{})",  
		"",          
	};

	for (const auto& testCase : testCases) {
		cout << "Input: \"" << testCase << "\" => Output: " << (isValid(testCase) ? "true" : "false") << endl;
	}

	return 0;
}

#endif
```

可以优化为

```C++
bool isValid(string s)
{
	stack<char> st;
	for (int i = 0; i < s.size(); i++)
	{
		if (st.empty())
		{
			if (s[i] == ')' || s[i] == ']' || s[i] == '}')return false;
			st.push(s[i]);
		}
		else
		{
			char topS = st.top();
			if ((s[i] == ')' && topS == '(') ||
				(s[i] == ']' && topS == '[') ||
				(s[i] == '}' && topS == '{'))
			{
				st.pop();
			}
			else if (s[i] == '(')//([{//}])
			{
				st.push(s[i]);
			}
			else if (s[i] == '[')
			{
				if (topS == '(')return false;
				else st.push(s[i]);
			}
			else if (s[i] == '{')
			{
				if (topS == '['||topS=='(')return false;
				else st.push(s[i]);
			}
			else st.push(s[i]);
			
		}
	}
	if (st.empty())return true;
	return false;
}
```

合法的是{[()]}



## 1.牛顿迭代法开方

### [69. x 的平方根 ](https://leetcode.cn/problems/sqrtx/)

https://leetcode.cn/problems/sqrtx/solutions/238553/x-de-ping-fang-gen-by-leetcode-solution/

#### 法1：袖珍计算器算法

### 方法一：袖珍计算器算法

「袖珍计算器算法」是一种用指数函数 exp 和对数函数$\ln$代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。

我们将$\sqrt x$写成幂的形式$x^{1/2}$,再使用自然对数$e$进行换底，即可得到

![image-20250208104917145](assets/image-20250208104917145.png)

$$\sqrt{x}=x^{1/2}=(e^{\ln x})^{1/2}=e^{\frac12\ln x}$$

（<img src="assets/image-20250209112644426.png" alt="image-20250209112644426" style="zoom:33%;" />)

这样我们就可以得到$\sqrt{x}$的值了。

注意：由于计算机无法存储浮点数的精确值 (浮点数的存储方法可以参考 IEEE 754,这里不再赘述),而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在**误差**。例如当$x=2147395600$时，$e^{\frac12\ln x}$的计算结果与正确值 46340 相差 10$^{-11}$,这样在对结果取整数部分时，会得到 46339 这个错误的结果。

因此在得到结果的整数部分ans后，我们应当找出**ans与$ans+1$中哪一个是真正的答案**。****

```C++
class Solution {
public:
    int mySqrt(int x) 
    {
        if(x==0)return 0;
        //
        int ans = exp(0.5*log(x));//C++语法上log(x)就是ln(x) 
        return ((long long )(ans+1)*(ans+1)<=x?ans+1:ans);
    }
};
```

log()是对数函数 ，格式是log底数(x)，如果没设底数，及只有log，那就是以e为底



#### 法2：二分

```C++
class Solution //5m
{
public:
    int mySqrt(int x) 
    {
        long long l=1,r=x;
        long long  mid;
        long long  temp;
        while(l<=r)
        {
            mid = l+((r-l)>>2);
            temp = mid*mid;
            if(temp<x)
            {
                l=mid+1;
            }
            else if(temp>x)
            {
                r=mid-1;
            }
            else
            {
                return mid;
            }
        }
        return r;

    }
};
```

#### 法3：牛顿迭代法

![image-20250209113149360](assets/image-20250209113149360.png)

![image-20250209113159861](assets/image-20250209113159861.png)

![image-20250209113210070](assets/image-20250209113210070.png)

![image-20250209113219471](assets/image-20250209113219471.png)

```C++
class Solution {
public:
    int mySqrt(int x) 
    {
        if(x==0)return 0;
        double C=x,x0=x;
        while(true)
        {
            double xi=0.5*(x0+C/x0);
            if((x0-xi)<1e-7)
            {
                break;
            }
            x0=xi;
        }
        return int(x0);
    }
};
```



## 469：凸多边形


LeetCode刷题实战469：凸多边形

今天和大家聊的问题叫做 凸多边形，我们先来看题面：

https://leetcode-cn.com/problems/convex-polygon/

Given a list of points that form a polygon when joined sequentially, find if this polygon is convex (Convex polygon definition).

Note:

There are at least 3 and at most 10,000 points.

Coordinates are in the range -10,000 to 10,000.

You may assume the polygon formed by given points is always a simple polygon (Simple polygon definition). In other words, we ensure that exactly two edges intersect at each vertex, and that edges otherwise don't intersect each other.

给定一个按顺序连接的多边形的顶点，判断该多边形是否为凸多边形。（凸多边形的定义）

注：

顶点个数至少为 3 个且不超过 10,000。

坐标范围为 -10,000 到 10,000。

你可以假定给定的点形成的多边形均为简单多边形（简单多边形的定义）。换句话说，保

每个顶点处恰好是两条边的汇合点，并且这些边 互不相交 。

示例                             
示例 1：

[[0,0],[0,1],[1,1],[1,0]]

输出：True
解释：

![image-20250209120018025](assets/image-20250209120018025.png)	


示例 2：

[[0,0],[0,10],[10,10],[10,0],[5,5]]

输出：False
解释：![image-20250209120026377](assets/image-20250209120026377.png)

解题
叉乘判断

设A(x1,y1),B(x2,y2),C(x3,y3)则三角形两边的矢量分别是：

AB=(x2-x1,y2-y1), AC=(x3-x1,y3-y1)

`则AB和AC的叉积为：(2*2的行列式) 值为：(x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)`

利用右手法则进行判断：

如果AB*AC>0,则三角形ABC是逆时针的

如果AB*AC<0,则三角形ABC是顺时针的

因为不知道顶点是顺时针输入，还是逆时针输入，所以要记录符号，后面点叉乘如果一样就是凸多边形。

<img src="assets/image-20250209130237341.png" alt="image-20250209130237341" style="zoom:50%;" />

c++

```C++
class Solution {
public:
    bool isConvex(vector<vector<int>>& points) 
    {
        int N = points.size();
        long pre = 0;
        for (int i = 0; i < N; ++i) 
        {
            long cur = angle({points[i], points[(i + 1) % N], points[(i + 2) % N]});
            if (cur != 0) 
			{
                if (cur * pre < 0)
                    return false;
                else
                    pre = cur;
            }
        }
        return true;
    }
    int angle(vector<vector<int>> A) 	
    {
        return  (A[1][0] - A[0][0]) * (A[2][1] - A[0][1]) - 
                (A[1][1] - A[0][1]) * (A[2][0] - A[0][0]);

    }
};
```



原文链接：https://blog.csdn.net/itcodexy/article/details/121987650



java

```java
class Solution:
    def isConvex(self, points: List[List[invt]]) -> bool:
        def cal_cross_product(A, B, C):
            AB = [B[0] - A[0], B[1] - A[1]]
            AC = [C[0] - A[0], C[1] - A[1]]
            return AB[0] * AC[1] - AB[1] * AC[0]
	flag = 0
    n = len(points)
    for i in range(n):
        # cur > 0 表示points是按逆时针输出的;cur < 0,顺时针
        cur = cal_cross_product(points[i], points[(i + 1) % n], points[(i + 2) % n])
        if cur != 0:
            # 说明异号, 说明有个角大于180度
            if cur * flag < 0:
                return False
            else:
                flag = cur
    return True
```



## 1. C#的编译过程: .Net, IL, JIT

**回答建议：**

.NET 是一个免费的跨平台[开放源代码开发人员平台](https://github.com/dotnet/core)，用于生成[多种类型的应用程序](https://learn.microsoft.com/zh-cn/dotnet/core/apps)。 .NET 可以运行使用[多种语言](https://learn.microsoft.com/zh-cn/dotnet/fundamentals/languages)编写的程序，其中 [C#](https://learn.microsoft.com/zh-cn/dotnet/csharp/) 是最常用的语言。 .NET 依赖于许多[大规模应用](https://devblogs.microsoft.com/dotnet/category/developer-stories/)在生产中使用的[高性能](https://devblogs.microsoft.com/dotnet/category/performance/)运行时。

C#的编译过程可以分为以下几个步骤：

1. **源代码编译为IL（Intermediate Language）**：当你编写C#代码并编译时，C#编译器（如`csc.exe`）会将你的源代码编译为中间语言（IL），也称为MSIL（Microsoft Intermediate Language）或CIL（Common Intermediate Language）。**IL是一种与平台无关的低级语言**，类似于汇编语言，但它并不是机器码。

2. **IL存储在程序集中**：编译后的IL代码会被存储在程序集（通常是`.dll`或`.exe`文件）中。程序集还包含元数据，用于描述程序集中的类型、方法、属性等信息。

3. **JIT编译（Just-In-Time Compilation）**：当程序运行时，.NET运行时（CLR，Common Language Runtime）会通过JIT编译器将IL代码编译为本地机器码。JIT编译是动态进行的，只有在方法第一次被调用时才会被编译为机器码。这种方式可以提高程序的启动速度，并且允许进行一些运行时优化。

4. **执行机器码**：一旦IL代码被JIT编译为机器码，CPU就可以直接执行这些机器码指令。

**总结：** C#的编译过程分为两个主要阶段：首先将源代码编译为IL，然后在运行时通过JIT编译器将IL编译为机器码并执行。

## 2. C#的字符串是什么类型？ C#两个字符串相同，指向同一个地方吗？

https://developer.aliyun.com/article/298536

<u></u>**回答建议：**

在C#中，字符串是`System.String`类型，它是一个引用类型。字符串在C#中是不可变的（immutable），这意味着一旦字符串被创建，它的内容就不能被修改。

**关于字符串相同是否指向同一个地方：**

在C#中，字符串有一个称为“字符串驻留”（String Interning）的特性。当你创建两个内容相同的字符串时，CLR会尝试将它们指向同一个内存地址，以减少内存占用。例如：

```csharp
string str1 = "hello";
string str2 = "hello";
```

在这个例子中，`str1`和`str2`会指向同一个内存地址，因为它们的值是相同的，CLR会进行字符串驻留优化。

但是，如果你通过`new`关键字显式创建字符串，或者通过字符串拼接等方式动态生成字符串，CLR可能不会进行驻留，这时两个内容相同的字符串可能不会指向同一个地方：

```csharp
string str3 = new string("hello");
string str4 = new string("hello");
```

在这个例子中，`str3`和`str4`虽然内容相同，但它们指向不同的内存地址。

**总结：** C#中的字符串是`System.String`类型，是不可变的引用类型。如果两个字符串的内容相同，CLR可能会通过字符串驻留机制让它们指向同一个内存地址，但通过`new`关键字创建的字符串不会进行驻留。



>**Q: 你是说c#的字符串不能改么，不是可以重新赋值吗**
>
>你提到的“重新赋值”和“字符串不可变”是两个不同的概念。让我详细解释一下：
>
>### 字符串不可变（Immutable）的含义
>
>在C#中，字符串是不可变的，这意味着一旦一个字符串对象被创建，它的内容就不能被修改。任何对字符串的“修改”操作（比如拼接、替换、插入等）实际上都会创建一个新的字符串对象，而不是修改原有的字符串。
>
>例如：
>
>```csharp
>string str = "hello";
>str = str + " world";  // 这里实际上是创建了一个新的字符串对象
>```
>
>在这个例子中，`str`最初指向一个包含`"hello"`的字符串对象。当执行`str = str + " world"`时，C#会创建一个新的字符串对象`"hello world"`，然后将`str`指向这个新的对象。原来的`"hello"`字符串对象并没有被修改，它仍然存在于内存中，直到垃圾回收器将其回收。
>
>### 重新赋值 vs 修改内容
>
>- **重新赋值**：你可以将一个字符串变量重新赋值为另一个字符串。这并不会修改原有的字符串对象，而是让变量指向一个新的字符串对象。
>
>  ```csharp
>  string str = "hello";
>  str = "world";  // 重新赋值，str现在指向一个新的字符串对象
>  ```
>
>- **修改内容**：你不能直接修改一个字符串对象的内容。例如，你不能通过索引来修改字符串中的某个字符：
>
>  ```csharp
>  string str = "hello";
>  str[0] = 'H';  // 这行代码会编译错误，因为字符串是不可变的
>  ```
>
>### 为什么字符串要设计为不可变？
>
>1. **线程安全**：由于字符串是不可变的，它们可以被多个线程共享而不需要额外的同步机制。
>2. **性能优化**：字符串驻留（String Interning）等优化技术依赖于字符串的不可变性。
>3. **安全性**：不可变性可以防止字符串在不知情的情况下被修改，这在处理敏感数据时尤为重要。
>
>### 如何“修改”字符串？
>
>如果你需要频繁修改字符串内容，可以使用`StringBuilder`类。`StringBuilder`是一个可变的字符串缓冲区，它允许你在不创建新对象的情况下修改字符串内容。
>
>例如：
>
>```csharp
>StringBuilder sb = new StringBuilder("hello");
>sb[0] = 'H';  // 可以直接修改字符
>sb.Append(" world");  // 可以追加字符串
>string result = sb.ToString();  // 最终转换为字符串
>```
>
>**总结：** C#中的字符串是不可变的，这意味着你不能修改一个已存在的字符串对象的内容。你可以通过重新赋值来让字符串变量指向一个新的字符串对象，但这并不会修改原有的字符串。如果需要频繁修改字符串内容，可以使用`StringBuilder`。

## 3. Unity协程, Unity协程和C#多线程使用上的区别，C#异步

**回答建议：**

**Unity协程：**

Unity中的协程（Coroutine）是一种特殊的函数，它可以在执行过程中暂停并在稍后的时间点继续执行。协程通常用于处理需要分步执行的任务，比如等待一段时间、等待某个条件满足等。协程通过`yield`关键字来实现暂停和继续。

例如：

```csharp
IEnumerator MyCoroutine()
{
    Debug.Log("Start");
    yield return new WaitForSeconds(1); // 暂停1秒
    Debug.Log("After 1 second");
}
```

**Unity协程与C#多线程的区别：**

1. **执行环境**：Unity协程是在主线程上执行的，它们并不是真正的多线程。协程的暂停和继续是通过Unity的主循环来控制的。而C#的多线程是通过`Thread`类或`Task`类创建的，它们可以在不同的线程上并行执行。

2. **用途**：协程通常用于处理需要分步执行的任务，比如动画、延时操作等。而多线程通常用于处理需要并行执行的任务，比如计算密集型操作、IO操作等。

3. **线程安全**：由于协程是在主线程上执行的，因此它们可以安全地访问Unity的对象（如`GameObject`、`Transform`等）。而多线程操作Unity对象时需要注意线程安全问题，通常需要通过主线程来操作Unity对象。

**C#异步：**

C#中的异步编程是通过`async`和`await`关键字来实现的。异步操作通常用于处理IO操作、网络请求等耗时操作，以避免阻塞主线程。

例如：

```csharp
async Task MyAsyncMethod()
{
    Debug.Log("Start");
    await Task.Delay(1000); // 异步等待1秒
    Debug.Log("After 1 second");
}
```



>异步
>
>**异步**（Asynchronous）是一种编程模式，允许程序在等待某些耗时操作（如I/O操作、网络请求、文件读写等）完成时，不阻塞当前线程，而是继续执行其他任务。当耗时操作完成后，程序再回来处理结果。
>
>### 异步的核心思想
>异步的核心思想是**“不等待”**。通过异步编程，你可以让程序在等待某个操作完成的同时，继续执行其他任务，从而提高程序的效率和响应性。
>
>### 同步 vs 异步
>- **同步（Synchronous）**：程序按顺序执行，每一步都必须等待前一步完成。如果某个操作耗时较长，程序会一直阻塞，直到操作完成。
>  - 例如：你打电话给客服，电话接通后你一直等待，直到客服处理完你的问题。
>  
>- **异步（Asynchronous）**：程序在发起某个操作后，不需要等待操作完成，而是继续执行其他任务。当操作完成后，程序会通过回调、事件或任务（Task）等方式得到通知。
>  - 例如：你打电话给客服，电话接通后你告诉客服你的问题，然后挂断电话去做其他事情。客服处理完后会回电通知你结果。
>
>---
>
>### C# 中的异步编程
>在C#中，异步编程主要通过 `async` 和 `await` 关键字来实现。`async` 用于标记一个方法是异步的，`await` 用于等待一个异步操作的完成。
>
>#### 示例：异步方法
>```csharp
>using System;
>using System.Threading.Tasks;
>
>class Program
>{
>    static async Task Main(string[] args)
>    {
>        Console.WriteLine("开始执行异步方法");
>        await DoSomethingAsync();  // 等待异步方法完成
>        Console.WriteLine("异步方法执行完毕");
>    }
>
>    static async Task DoSomethingAsync()
>    {
>        Console.WriteLine("异步操作开始");
>        await Task.Delay(2000);  // 模拟一个耗时操作（延迟2秒）
>        Console.WriteLine("异步操作完成");
>    }
>}
>```
>
>#### 输出：
>```
>开始执行异步方法
>异步操作开始
>（等待2秒）
>异步操作完成
>异步方法执行完毕
>```
>
>#### 关键点：
>1. **`async`**：标记一个方法为异步方法。异步方法通常返回 `Task` 或 `Task<T>`。
>2. **`await`**：等待一个异步操作完成。`await` 会暂停当前方法的执行，直到异步操作完成，但不会阻塞线程。
>3. **`Task`**：表示一个异步操作。`Task.Delay` 是一个模拟耗时操作的异步方法。
>
>---
>
>### 异步的优点
>1. **提高响应性**：异步操作不会阻塞主线程，因此程序可以继续响应用户输入或其他任务。
>2. **提高资源利用率**：异步操作可以充分利用CPU和I/O资源，避免线程空闲等待。
>3. **适合I/O密集型操作**：异步编程特别适合处理文件读写、网络请求等I/O密集型操作，因为这些操作通常需要等待外部资源。
>
>---
>
>### 异步的适用场景
>1. **网络请求**：例如从Web API获取数据。
>2. **文件读写**：例如读取大文件或写入数据到磁盘。
>3. **数据库操作**：例如查询数据库或执行存储过程。
>4. **UI编程**：在桌面或移动应用中，异步操作可以避免UI线程被阻塞，保持界面流畅。
>
>---
>
>### 异步与多线程的区别
>- **异步**：关注的是任务的非阻塞执行，不一定涉及多线程。异步操作可能使用单线程（如JavaScript的异步模型）或多线程（如C#的异步模型）。
>- **多线程**：关注的是并行执行多个任务，通常涉及多个线程。
>
>在C#中，异步操作通常使用线程池中的线程来执行，但异步编程的核心思想是通过 `async` 和 `await` 实现非阻塞的任务调度，而不是直接管理线程。
>
>---
>
>### 总结
>- **异步**是一种编程模式，允许程序在等待耗时操作时继续执行其他任务。
>- 在C#中，异步编程通过 `async` 和 `await` 实现，适合处理I/O密集型操作或需要提高程序响应性的场景。
>- 异步的核心思想是“不等待”，通过非阻塞的方式提高程序的效率和用户体验。



**总结：** Unity协程是在主线程上执行的，适合处理分步执行的任务；C#多线程可以在不同线程上并行执行，适合处理计算密集型任务；C#异步编程通过`async`和`await`关键字实现，适合处理IO操作等耗时任务。

---

在面试中，除了回答这些问题，你还可以结合实际项目经验，举例说明你在项目中如何使用这些技术，这样可以更好地展示你的能力和经验。



在面试中，回答Unity相关问题时，除了要准确回答问题本身，还要尽量展示你对Unity引擎的理解和实际开发经验。以下是针对你提出的几个问题的回答建议：

---

## 1. Unity脚本的生命周期

**回答建议：**

Unity脚本的生命周期是指从脚本被加载到场景中，到脚本被销毁的整个过程。Unity提供了一系列的事件函数（也称为生命周期函数），开发者可以在这些函数中编写代码来控制游戏对象的行为。以下是Unity脚本的主要生命周期函数：

1. **Awake()**：
   - 在脚本实例被创建时调用，即使脚本未启用也会调用。
   - 通常用于初始化变量或获取组件引用。
   - 注意：`Awake` 只会在脚本实例化时调用一次。

2. **OnEnable()**：
   - 当脚本启用时调用（例如通过 `SetActive(true)` 或勾选脚本组件）。
   - 适合用于重新启用脚本时的初始化操作。

3. **Start()**：
   - 在脚本启用后，第一次调用 `Update` 之前调用。
   - 通常用于初始化需要在 `Awake` 之后执行的操作。

4. **FixedUpdate()**：
   - 以固定的时间间隔调用（默认每秒50次，可通过 `Time.fixedDeltaTime` 调整）。
   - 适合用于物理相关的操作，如刚体运动。

5. **Update()**：
   - 每帧调用一次，频率取决于设备的帧率。
   - 适合用于处理游戏逻辑、输入检测等。

6. **LateUpdate()**：
   - 在 `Update` 之后调用，每帧调用一次。
   - 适合用于需要在所有 `Update` 逻辑执行完毕后执行的操作，如相机跟随。

7. **OnDisable()**：
   - 当脚本被禁用时调用（例如通过 `SetActive(false)` 或取消勾选脚本组件）。
   - 适合用于清理资源或停止某些操作。

8. **OnDestroy()**：
   - 当脚本被销毁时调用（例如对象被销毁或场景切换）。
   - 适合用于释放资源或保存数据。

**总结：** Unity脚本的生命周期包括从初始化到销毁的多个阶段，开发者可以通过重写这些生命周期函数来控制游戏对象的行为。

---

## 2. Update、LateUpdate 和 FixedUpdate 的区别

**回答建议：**

- **Update()**：
  - 每帧调用一次，调用频率取决于设备的帧率（FPS）。
  - 适合用于处理游戏逻辑、输入检测、动画控制等。
  - 例如：检测玩家输入、更新角色位置。

- **LateUpdate()**：
  - 在 `Update` 之后调用，每帧调用一次。
  - 适合用于需要在所有 `Update` 逻辑执行完毕后执行的操作。
  - 例如：相机跟随逻辑（确保相机在角色移动后更新）。

- **FixedUpdate()**：
  - 以固定的时间间隔调用（默认每秒50次，可通过 `Time.fixedDeltaTime` 调整）。
  - 适合用于物理相关的操作，如刚体运动、碰撞检测等。
  - 例如：施加力到刚体、处理物理碰撞。

**总结：**
- `Update` 用于每帧更新的逻辑。
- `LateUpdate` 用于在 `Update` 之后执行的逻辑。
- `FixedUpdate` 用于物理相关的逻辑，调用频率固定。

---

## 3. 怎么判断子弹与人物的碰撞

**回答建议：**

在Unity中，判断子弹与人物的碰撞通常使用 **碰撞检测** 或 **触发器检测**。以下是两种常见的方式：

#### 方法1：使用碰撞检测（Collision）
1. 确保子弹和人物都有 **Collider** 组件（如 `BoxCollider`、`SphereCollider` 等）。
2. 确保至少有一个对象（子弹或人物）有 **Rigidbody** 组件。
3. 在子弹的脚本中实现 `OnCollisionEnter` 方法，检测碰撞事件。

```csharp
void OnCollisionEnter(Collision collision)
{
    if (collision.gameObject.CompareTag("Player")) // 假设人物有 "Player" 标签
    {
        Debug.Log("子弹击中了人物");
        // 处理击中逻辑，如扣血、销毁子弹等
        Destroy(gameObject); // 销毁子弹
    }
}
```

#### 方法2：使用触发器检测（Trigger）
1. 将子弹或人物的 Collider 设置为 **Is Trigger**。
2. 在子弹的脚本中实现 `OnTriggerEnter` 方法，检测触发事件。

```csharp
void OnTriggerEnter(Collider other)
{
    if (other.CompareTag("Player")) // 假设人物有 "Player" 标签
    {
        Debug.Log("子弹击中了人物");
        // 处理击中逻辑，如扣血、销毁子弹等
        Destroy(gameObject); // 销毁子弹
    }
}
```

#### 优化建议：
- **标签（Tag）**：为人物和子弹设置标签，方便快速判断碰撞对象。
- **层级碰撞矩阵（Layer Collision Matrix）**：通过设置层级碰撞矩阵，优化碰撞检测的性能。
- **对象池（Object Pooling）**：如果子弹频繁生成和销毁，可以使用对象池技术来优化性能。

**总结：**

- 使用 `OnCollisionEnter` 或 `OnTriggerEnter` 检测子弹与人物的碰撞。
- 通过标签或层级区分碰撞对象。
- 根据需求选择碰撞检测或触发器检测。

todo:什么时候调用OntriggerEnter或者Collider..



## 1. 可靠UDP的实现，如何减少UDP丢包

**回答建议：**

UDP（User Datagram Protocol）是一个无连接的传输协议，它不保证数据的可靠传输。为了实现可靠的UDP传输，通常需要在应用层实现一些机制来确保数据的可靠性和顺序性。以下是一些常见的实现方式：

#### 可靠UDP的实现
1. **确认机制（ACK）**：
   - 发送方发送数据包后，接收方需要返回一个确认（ACK）消息。
   - 如果发送方在一定时间内没有收到ACK，则认为数据包丢失，并进行重传。

2. **序列号（Sequence Number）**：
   - 每个数据包都附带一个序列号，接收方根据序列号来检测丢失的数据包和保证数据的有序性。

3. **重传机制（Retransmission）**：
   - 当发送方检测到数据包丢失时，会重新发送丢失的数据包。

4. **滑动窗口（Sliding Window）**：
   - 通过滑动窗口机制，发送方可以在未收到ACK的情况下继续发送多个数据包，从而提高传输效率。

5. **冗余校验（Checksum）**：
   - 在数据包中加入校验和，接收方可以通过校验和来检测数据包是否损坏。

#### 减少UDP丢包的方法
1. **流量控制**：
   - 通过控制发送速率，避免网络拥塞，从而减少丢包。

2. **拥塞控制**：
   - 实现类似于TCP的拥塞控制算法（如慢启动、拥塞避免等），动态调整发送速率。

3. **前向纠错（FEC）**：
   - 在发送数据时加入冗余信息，接收方可以通过这些冗余信息恢复部分丢失的数据包。

4. **路径优化**：
   - 通过选择更优的网络路径或使用多路径传输，减少丢包的可能性。

**总结：** 可靠UDP的实现通常需要在应用层加入确认机制、序列号、重传机制和滑动窗口等技术。减少UDP丢包的方法包括流量控制、拥塞控制、前向纠错和路径优化等。

---

## 2. 定点数的实现

https://zhuanlan.zhihu.com/p/338588296

**回答建议：**

定点数（Fixed-Point Number）是一种用于表示小数的数据类型，它通过固定小数点的位置来表示数值。定点数通常用于嵌入式系统或性能要求较高的场景，因为它的计算速度比浮点数快。

#### 定点数的实现
1. **表示方法**：
   - 定点数通常用一个整数来表示，其中一部分位表示整数部分，另一部分位表示小数部分。
   - 例如，一个16位的定点数可以用前8位表示整数部分，后8位表示小数部分。

2. **运算规则**：
   - **加法和减法**：直接对整数进行加减操作，结果仍然是定点数。
   - **乘法**：两个定点数相乘后，需要对结果进行右移操作，以保持小数点的位置。
   - **除法**：两个定点数相除后，需要对结果进行左移操作，以保持小数点的位置。

3. **精度控制**：
   - 定点数的精度取决于小数部分的位数。例如，8位小数部分的精度为1/256。

#### 示例代码
```c
typedef int32_t fixed_t;

#define FIXED_POINT_FRACTIONAL_BITS 16
#define FIXED_POINT_SCALE (1 << FIXED_POINT_FRACTIONAL_BITS)

fixed_t float_to_fixed(float f) {
    return (fixed_t)(f * FIXED_POINT_SCALE);
}

float fixed_to_float(fixed_t f) {
    return (float)f / FIXED_POINT_SCALE;
}

fixed_t fixed_multiply(fixed_t a, fixed_t b) {
    return (a * b) >> FIXED_POINT_FRACTIONAL_BITS;
}

fixed_t fixed_divide(fixed_t a, fixed_t b) {
    return (a << FIXED_POINT_FRACTIONAL_BITS) / b;
}
```

**总结：** 定点数通过固定小数点的位置来表示小数，适合用于性能要求较高的场景。定点数的实现包括表示方法、运算规则和精度控制。

---

## 3. RTTI（Run-Time Type Information）和 dynamic_cast 原理

现代C++中的四种CAST - 孙梓轩的文章 - 知乎
https://zhuanlan.zhihu.com/p/578828427

**回答建议：**

RTTI（Run-Time Type Information）是C++中的一种机制，用于在运行时获取对象的类型信息。RTTI主要包括两种操作符：`typeid` 和 `dynamic_cast`。

C++通过以下的两个操作提供RTTI：

（1）typeid运算符，该运算符返回其表达式或类型名的实际类型。

（2）dynamic_cast运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。

#### RTTI 的四种类型转换
1. **static_cast**：
   - 用于静态类型转换，通常在编译时进行类型检查。
   - 例如：将基类指针转换为派生类指针。

2. **dynamic_cast**：
   - 用于动态类型转换，通常在运行时进行类型检查。
   - 例如：将基类指针转换为派生类指针，并检查转换是否成功。

3. **const_cast**：
   - 用于去除或添加 `const` 或 `volatile` 修饰符。
   - 例如：将 `const int*` 转换为 `int*`。

4. **reinterpret_cast**：
   - 用于低级别的类型转换，通常不进行类型检查。
   - 例如：将指针转换为整数。

#### dynamic_cast 原理
`dynamic_cast` 是RTTI的一部分，用于在运行时进行安全的类型转换。它通常用于将基类指针或引用转换为派生类指针或引用。

- **工作原理**：
  - `dynamic_cast` 依赖于虚函数表（vtable）来实现类型检查。
  - 当使用 `dynamic_cast` 进行转换时，C++运行时会检查对象的实际类型是否与目标类型兼容。
  - 如果转换成功，返回目标类型的指针或引用；如果转换失败，返回 `nullptr`（对于指针）或抛出 `std::bad_cast` 异常（对于引用）。

- **示例代码**：
```cpp
class Base {
public:
    virtual ~Base() {} // 必须有虚函数
};

class Derived : public Base {};

Base* basePtr = new Derived;
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);
if (derivedPtr) {
    // 转换成功
} else {
    // 转换失败
}
```

**总结：** RTTI 是C++中的运行时类型信息机制，`dynamic_cast` 是RTTI的一部分，用于在运行时进行安全的类型转换。`dynamic_cast` 依赖于虚函数表来实现类型检查，确保转换的安全性。

---

typeid 底层实现是什么 和模板萃取有关系吗

`typeid` 是 C++ 中用于获取类型信息的运算符，其底层实现依赖于 RTTI（Run-Time Type Information）机制。RTTI 允许程序在运行时获取对象的类型信息，通常由编译器实现。

### 底层实现
1. **类型信息存储**：
   - 编译器为每个多态类型（包含虚函数的类）生成一个 `std::type_info` 对象，存储类型信息。
   - 这些对象通常保存在只读内存段中，程序运行时通过虚表（vtable）访问。

2. **虚表（vtable）**：
   - 多态类对象的虚表包含指向 `type_info` 对象的指针。
   - 调用 `typeid` 时，编译器生成代码从虚表中获取 `type_info` 对象。

3. **typeid 运算符**：
   - 对于多态类型，`typeid` 通过虚表获取 `type_info` 对象。
   - 对于非多态类型，`typeid` 在编译时直接返回对应的 `type_info` 对象。

### 与模板萃取的关系
模板萃取（Type Traits）是编译时类型推导和操作的技术，与 `typeid` 的运行时类型信息不同：

1. **编译时 vs 运行时**：
   - 模板萃取在编译时操作类型信息。
   - `typeid` 在运行时获取类型信息。

2. **用途不同**：
   - 模板萃取用于优化和类型推导。
   - `typeid` 用于运行时类型检查和调试。

3. **结合使用**：
   - 虽然用途不同，但在某些场景下可以结合使用，例如在模板函数中根据 `typeid` 的结果进行不同操作。

### 示例代码
```cpp
#include <iostream>
#include <typeinfo>
#include <type_traits>

template <typename T>
void check_type(const T& value) {
    if (typeid(value) == typeid(int)) {
        std::cout << "Type is int" << std::endl;
    } else if (typeid(value) == typeid(double)) {
        std::cout << "Type is double" << std::endl;
    } else {
        std::cout << "Unknown type" << std::endl;
    }

    if (std::is_integral<T>::value) {
        std::cout << "T is an integral type" << std::endl;
    } else {
        std::cout << "T is not an integral type" << std::endl;
    }
}

int main() {
    int i = 42;
    double d = 3.14;

    check_type(i);
    check_type(d);

    return 0;
}
```

### 总结
- `typeid` 的底层实现依赖于 RTTI，通过虚表获取 `type_info` 对象。
- 模板萃取在编译时操作类型信息，与 `typeid` 的运行时机制不同，但可以结合使用。



---------------



## 🐖猪喝毒水 小白鼠试毒

https://leetcode.cn/problems/poor-pigs/solutions/15770/hua-jie-suan-fa-458-ke-lian-de-xiao-zhu-by-guanpen/

https://leetcode.cn/problems/poor-pigs/solutions/1121124/wei-rao-li-lun-cong-ke-lian-de-xiao-zhu-h8t4p/

这道题最开始不要去关注细节，去想到应该怎么喂水。而是应该先思考在考察哪方面的问题，数组、链表、二叉树还是数学？那么仔细思考就能得出结论，本质上在考察教学中的 进制 问题。

举例说明:
- 假设：总时间 minutesToTest = 60 ，死亡时间 minutesToDie = 15 ，pow(x,y) 表示 x 的 y 次方，ceil(x) 表示 x 向上取整 
- 当前有1只小猪，最多可以喝 times = minutesToTest / minutesToDie = 4 次水 
- 最多可以喝 4 次，能够携带 base = times + 1 = 5 个的信息量，也就是（便于理解从0开始）：
  - （1）喝 0 号死去，0号桶水有毒
  - （2）喝 1 号死去，1号桶水有毒
  - （3）喝 2 号死去，2号桶水有毒
  - （4）喝 3 号死去，3号桶水有毒
  - （5）喝了上述所有水依然活蹦乱跳，4号桶水有毒
- 结论是1只小猪最多能够验证5桶水中哪只水桶含有***，当 buckets ≤ 5 时，answer = 1 
- 那么2 只小猪可以验证的范围最多到多少呢？我们把每只小猪携带的信息量看成是base进制数，2只小猪的信息量就是 pow(base, 2) = pow(5, 2) = 25，所以当 buckets ≥ 25时，anser = 2 
- 那么可以得到公式关系：pow(base, ans) ≥ buckets ，取对数后即为：ans ≥ log(buckets) / log(base)，因为 ans 为整数，所以 ans = ceil(log(buckets)) / log(base))

<img src="assets/image-20250210143528362.png" alt="image-20250210143528362" style="zoom:50%;" />

时间复杂度：O(1)
看到这里我们再去关注细节，2只小猪到底怎么喂水，在上述假设下，能够最多验证 25 桶水呢？请看下方图画解答：



从楼主题解引申出来的理解:

一只小猪代表一个维度(设为n), 每只小猪可以测试的次数+1为这只小猪在本维度上可以确定的点的数量(设为s), 则组成的n维空间中的总的点的数量为 s^n .

小猪喝水策略: 把所有的水桶排成一个n维的n方体, 每只小猪喝垂直于本维度(轴)的一个"超平面".

如2只小猪, 5个点. 25桶水排成一个矩形, 一只喝行, 一只喝列. 2只小猪确定一个点(***).

如3只小猪, 5个点. 125桶水排成一个立方体, 一只喝垂直于x轴的面, 一只喝垂直于y轴的面, 一只喝垂直于z轴的面. 3只小猪确定一个点(***).

如n只小猪, 5个点. 5^n桶水排成一个n方体, 每只喝垂直于本维度的一个"超平面"上的所有的水. n只小猪确定n维空间中的一个点(***).

![image-20250210143649381](assets/image-20250210143649381.png)

```C++
class Solution {
public:
    int poorPigs(int buckets, int minutesToDie, int minutesToTest) 
    {
        int base = minutesToTest/minutesToDie+1;
        return ceil(log10(buckets)/log10(base));
    }
};
```





## 小明有n个游戏币 至少玩多少把游戏可以花完

要么一局一个币

要么如果能被2整除 就可以花掉n/2个币

要么如果能被3整除 就可以花掉  2*(n/3)  个币

### 问题理解

小明有 `n` 个游戏币，每次可以选择以下三种方式之一花费游戏币：

1. **花费 1 个币**：直接花费 1 个币。
2. **花费一半的币**：如果当前剩余的游戏币数 `n` 能被 2 整除，则可以花费 `n/2` 个币。
3. **花费三分之二的币**：如果当前剩余的游戏币数 `n` 能被 3 整除，则可以花费 `2*(n/3)` 个币。

目标是找到**最少需要玩多少把游戏**才能花完所有的游戏币。

---

### 解题思路

这个问题可以看作是一个**动态规划（Dynamic Programming, DP）**问题。我们需要找到从 `n` 到 0 的最少操作次数。

#### 动态规划状态定义

设 `dp[i]` 表示花完 `i` 个游戏币所需的最少游戏次数。

#### 状态转移方程

对于每个 `i`，我们有以下选择：

1. **花费 1 个币**：
   - 操作次数为 `dp[i-1] + 1`。
2. **花费一半的币**（如果 `i` 能被 2 整除）：
   - 操作次数为 `dp[i/2] + 1`。
3. **花费三分之二的币**（如果 `i` 能被 3 整除，花费后，剩余的币数是 `n - 2*(n/3) = n/3`。）：
   - 操作次数为 `dp[i/3] + 1`。

因此，状态转移方程为：
$$
dp[i] = \min(dp[i-1] + 1, \ dp[i/2] + 1, \ dp[i/3] + 1)
$$

#### 初始条件

- `dp[0] = 0`：花完 0 个币不需要任何操作。
- `dp[1] = 1`：花完 1 个币需要 1 次操作（花费 1 个币）。

#### 实现步骤

1. 初始化一个数组 `dp`，大小为 `n+1`，用于存储从 0 到 `n` 的最少操作次数。
2. 遍历从 2 到 `n` 的每个数 `i`，计算 `dp[i]` 的值。
3. 最终返回 `dp[n]`。

---

### 代码实现

以下是 Python 的实现代码：

```python
def min_games(n):
    # 初始化 dp 数组
    dp = [float('inf')] * (n + 1)
    dp[0] = 0  # 0 个币需要 0 次操作
    dp[1] = 1  # 1 个币需要 1 次操作

    # 动态规划求解
    for i in range(2, n + 1):
        # 选择 1：花费 1 个币
        dp[i] = dp[i - 1] + 1

        # 选择 2：花费一半的币（如果 i 能被 2 整除）
        if i % 2 == 0:
            dp[i] = min(dp[i], dp[i // 2] + 1)

        # 选择 3：花费三分之二的币（如果 i 能被 3 整除）
        if i % 3 == 0:
            dp[i] = min(dp[i], dp[i // 3] + 1)

    return dp[n]

# 测试
n = 10
print(f"最少需要 {min_games(n)} 把游戏花完 {n} 个币")
```

---

### 示例分析

#### 示例 1：`n = 10`

1. **初始状态**：
   - `dp[0] = 0`
   - `dp[1] = 1`

2. **计算过程**：
   - `dp[2] = min(dp[1] + 1, dp[1] + 1) = 2`
   - `dp[3] = min(dp[2] + 1, dp[1] + 1) = 2`
   - `dp[4] = min(dp[3] + 1, dp[2] + 1) = 3`
   - `dp[5] = dp[4] + 1 = 4`
   - `dp[6] = min(dp[5] + 1, dp[3] + 1, dp[2] + 1) = 3`
   - `dp[7] = dp[6] + 1 = 4`
   - `dp[8] = min(dp[7] + 1, dp[4] + 1) = 4`
   - `dp[9] = min(dp[8] + 1, dp[3] + 1) = 3`
   - `dp[10] = min(dp[9] + 1, dp[5] + 1) = 4`

3. **结果**：
   - 最少需要 4 把游戏花完 10 个币。

#### 示例 2：`n = 6`

1. **初始状态**：
   - `dp[0] = 0`
   - `dp[1] = 1`

2. **计算过程**：
   - `dp[2] = min(dp[1] + 1, dp[1] + 1) = 2`
   - `dp[3] = min(dp[2] + 1, dp[1] + 1) = 2`
   - `dp[4] = min(dp[3] + 1, dp[2] + 1) = 3`
   - `dp[5] = dp[4] + 1 = 4`
   - `dp[6] = min(dp[5] + 1, dp[3] + 1, dp[2] + 1) = 3`

3. **结果**：
   - 最少需要 3 把游戏花完 6 个币。

---

### 复杂度分析

1. **时间复杂度**：`O(n)`，因为需要遍历从 2 到 `n` 的每个数。
2. **空间复杂度**：`O(n)`，用于存储 `dp` 数组。

---

### 总结

通过动态规划的方法，我们可以高效地解决这个问题。对于任意给定的 `n`，都可以在 `O(n)` 的时间内计算出最少需要多少把游戏才能花完所有的游戏币。



## topK

使用快速选择算法

讲得很好：

https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278



***\*问题描述\****：

从arr[1, n]这n个数中，找出最大的k个数，这就是经典的TopK问题。



[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

```C++
class Solution 
{
public:
    int partition(int l,int r,vector<pair<int,int>> &v)
    {
        int pivot=((l+r)>>1);
        int pivotNum = v[pivot].second;//一定要有这句话 因为后面放在这里的值 会一直变化
        int i=l-1;//边界

        swap(v[pivot],v[r]); //1 交换到r的位置 就不需要遍历到r
        for(int j=l;j<r;j++) //1
        {
            if(v[j].second>pivotNum)//大于的放前面！！注意审题
            {
                i++;
                swap(v[i],v[j]);
            }
        }
        swap(v[r],v[i+1]); //1
        return i+1;
    }
    void quickSelect(int l,int r,vector<pair<int,int>> &v,int k)
    {      
        if(l>=r)return;  
        int index=partition(l,r,v);
        if(index-l+1>k)
        {
            quickSelect(l,index-1,v,k);
        }
        else if(r-index+1>k)
        {
            //quickSelect(index+1,r,v,k);
            quickSelect(index+1,r,v,k-(index-l+1));
        }
    }
    vector<int> topKFrequent(vector<int>& nums, int k) 
    {
        int n=nums.size();
        unordered_map<int,int> umap;
        for(int i=0;i<n;i++)
        {
            umap[nums[i]]++;
        }
        vector<pair<int,int>> v(umap.begin(),umap.end());
        //quickSelect(0,n-1,v,k); 错误 大小应该是是v的大小 
        quickSelect(0,v.size()-1,v,k); 

        vector<int> res; 
        for(int i=0;i<k;i++)
        {
            res.push_back(v[i].first);
        }
        return res;
    }
};
```

DS有解释版：

```C++


class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计频率
        unordered_map<int, int> umap;
        for (int num : nums) {
            umap[num]++;
        }

        // 将频率统计结果转换为 vector<pair<int, int>>
        vector<pair<int, int>> v(umap.begin(), umap.end());

        // 使用快速选择算法找到前 K 个高频元素
        quickSelect(0, v.size() - 1, v, k);

        // 提取前 K 个高频元素
        vector<int> res;
        for (int i = 0; i < k; i++) {
            res.push_back(v[i].first);
        }

        return res;
    }

private:
    // 分区函数
    int partition(int l, int r, vector<pair<int, int>>& v) {
        int pivot = (l + r) >> 1; // 选择中间元素作为 pivot
        int pivotNum = v[pivot].second; // 保存 pivot 的频率值

        // 将 pivot 放到最后
        swap(v[pivot], v[r]);

        int i = l - 1; // 边界
        for (int j = l; j < r; j++) {
            if (v[j].second > pivotNum) { // 大于的放前面
                i++;
                swap(v[i], v[j]);
            }
        }

        // 将 pivot 放到正确的位置
        swap(v[i + 1], v[r]);
        return i + 1;
    }

    // 快速选择算法
    void quickSelect(int l, int r, vector<pair<int, int>>& v, int k) {
        if (l >= r) return;

        int index = partition(l, r, v);

        if (index - l + 1 > k) {
            // 如果左半部分的元素个数大于 k，递归左半部分
            quickSelect(l, index - 1, v, k);
        } else if (index - l + 1 < k) {
            // 如果左半部分的元素个数小于 k，递归右半部分，并调整 k
            quickSelect(index + 1, r, v, k - (index - l + 1));
        }
        // 如果 index - l + 1 == k，直接返回
    }
};
```



## 天平称重

8枚硬币，一枚比较重，用天平找到最重的硬币，最少需要多少次（2次）



要在8枚硬币中找到最重的硬币，使用天平的最少次数是 **2次**。以下是具体步骤：

------

### **步骤 1：将8枚硬币分成3组**

- 将8枚硬币分成3组：**A组（3枚）**、**B组（3枚）**、**C组（2枚）**。
- 将A组和B组放在天平两端进行比较。

------

### **步骤 2：分析第一次称重的结果**

1. **如果A组 = B组**：
   - 说明最重的硬币在C组（2枚）中。
   - 将C组的2枚硬币放在天平两端，较重的一枚就是最重的硬币。
2. **如果A组 ≠ B组**：
   - 较重的一组中有最重的硬币。
   - 从较重的一组中任选2枚硬币进行比较：
     - 如果两枚硬币重量相同，未称的那一枚就是最重的。
     - 如果两枚硬币重量不同，较重的一枚就是最重的。

------

### **总结**

通过上述步骤，**最多只需要2次称重**就可以找到最重的硬币。





对于 **N 枚硬币**，其中一枚较重，使用天平找到最重硬币的**通用解法**可以通过**分组比较**和**递归思想**来实现。以下是通用的解决思路：

---

### **1. 分组策略**
每次称重时，将硬币尽可能均匀地分成 **3 组**（因为天平有 3 种可能的结果：左重、右重、平衡）。通过每次将问题规模缩小到原来的 **1/3**，可以最小化称重次数。

---

### **2. 称重次数公式**
设最少需要 **k 次称重**，则：
$$
3^k \geq N
$$
取对数后得到：
$$
k \geq \log_3 N
$$
因此，最少称重次数为：
$$
k = \lceil \log_3 N \rceil
$$
其中，\(\lceil \cdot \rceil\) 表示向上取整。

---

### **3. 具体步骤**
1. **分组**：
   - 将 N 枚硬币分成 3 组，尽量使每组的数量相等。
   - 如果 N 不是 3 的倍数，可以有两组数量相同，另一组少 1 或 2 枚。

2. **第一次称重**：
   - 将两组硬币放在天平两端进行比较。
   - 如果两组重量相同，说明较重的硬币在第三组。
   - 如果两组重量不同，较重的一组包含较重的硬币。

3. **递归缩小范围**：
   - 对包含较重硬币的那一组，重复上述分组和称重过程，直到找到最重的硬币。

---

### **4. 示例**
#### **N = 9 枚硬币**
- 第一次称重：将 9 枚硬币分成 3 组（3, 3, 3），比较两组。
- 第二次称重：将较重的那一组（3 枚）分成 3 组（1, 1, 1），比较两枚。
- 结果：最多需要 **2 次称重**。

#### **N = 10 枚硬币**
- 第一次称重：将 10 枚硬币分成 3 组（3, 3, 4），比较两组 3 枚。
- 如果两组 3 枚重量相同，较重硬币在 4 枚中。
  - 第二次称重：将 4 枚分成 3 组（1, 1, 2），比较两枚 1 枚。
  - 第三次称重：如果两枚 1 枚重量相同，较重硬币在 2 枚中，再比较一次。
- 如果两组 3 枚重量不同，较重硬币在较重的那组 3 枚中。
  - 第二次称重：将 3 枚分成 3 组（1, 1, 1），比较两枚。
- 结果：最多需要 **3 次称重**。

---

### **5. 总结**
- **最少称重次数**：$\lceil \log_3 N \rceil$。
- **分组策略**：每次将硬币分成 3 组，尽可能均匀分配。
- **适用范围**：适用于任意数量的硬币（N ≥ 2）。

通过这种方法，可以高效地找到最重的硬币，同时最小化称重次数。



对比小猪喝毒水那题，我的理解是：天平信息量固定是3，小猪是 minutesToTest / minutesToDie+1



## 点到直线的距离

推导方法：

https://zhuanlan.zhihu.com/p/26307123

公式：

**点到直线的距离公式**用于计算点 \( P(x_0, y_0) \) 到直线 \( Ax + By + C = 0 \) 的最短距离。公式如下：

$$
d = \frac{|Ax_0 + By_0 + C|}{\sqrt{A^2 + B^2}}
$$

---

### **公式推导**
1. 直线的一般方程为 $$ Ax + By + C = 0 $$。
2. 点 $$ P(x_0, y_0) $$ 到直线的距离可以通过投影计算。
3. 距离公式的分子是点代入直线方程的绝对值，分母是直线方程系数的欧几里得范数（即直线法向量的模）。

---

### **示例**
计算点 \( P(2, 3) \) 到直线 \( 3x + 4y - 5 = 0 \) 的距离。

1. 提取直线方程的系数：
   - \( A = 3 \)
   - \( B = 4 \)
   - \( C = -5 \)

2. 提取点的坐标：
   - \( x_0 = 2 \)
   - \( y_0 = 3 \)

3. 代入公式：
   $$
   d = \frac{|3 \cdot 2 + 4 \cdot 3 - 5|}{\sqrt{3^2 + 4^2}} = \frac{|6 + 12 - 5|}{\sqrt{9 + 16}} = \frac{|13|}{5} = 2.6
   $$

4. 结果：
   - 点 \( P(2, 3) \) 到直线的距离为 **2.6**。

---

### **注意事项**
1. 直线方程必须化为一般式 \( Ax + By + C = 0 \)。
2. 如果直线方程是斜截式 \( y = kx + b \)，需要先转换为一般式：
$$
kx - y + b = 0
$$
   此时 \( A = k \)，\( B = -1 \)，\( C = b \)。

---

### **几何意义**
点到直线的距离公式是几何中常用的工具，广泛应用于计算机图形学、物理、工程等领域。



## LRU

LRU相关，给一些数据项，计算缓存命中次数，计算最后缓存中即将被淘汰的数据项

**LRU（Least Recently Used）缓存淘汰算法**是一种常用的缓存管理策略。它的核心思想是：当缓存空间不足时，淘汰**最近最少使用**的数据项。以下是关于 LRU 缓存的相关计算步骤：

---

### **1. 缓存命中次数的计算**
- **缓存命中**：当访问的数据项已经在缓存中时，称为缓存命中。
- **缓存未命中**：当访问的数据项不在缓存中时，称为缓存未命中，需要将数据项加载到缓存中。

---

### **2. 最后缓存中即将被淘汰的数据项**
- 当缓存已满且需要加载新数据项时，LRU 会淘汰**最近最少使用**的数据项。
- 可以通过维护一个**访问顺序**（如链表或队列）来确定最近最少使用的数据项。

---

### **3. 示例**
假设缓存容量为 **3**，数据项访问顺序为：`[A, B, C, A, D, B, E]`。

#### **步骤 1：初始化缓存**
- 缓存初始为空：`[]`

#### **步骤 2：逐个访问数据项**
1. **访问 A**：
   - 缓存未命中，加载 A。
   - 缓存状态：`[A]`

2. **访问 B**：
   - 缓存未命中，加载 B。
   - 缓存状态：`[A, B]`

3. **访问 C**：
   - 缓存未命中，加载 C。
   - 缓存状态：`[A, B, C]`

4. **访问 A**：
   - 缓存命中，A 被访问，更新顺序。
   - 缓存状态：`[B, C, A]`

5. **访问 D**：
   - 缓存未命中，缓存已满，淘汰最近最少使用的 B。
   - 加载 D。
   - 缓存状态：`[C, A, D]`

6. **访问 B**：
   - 缓存未命中，缓存已满，淘汰最近最少使用的 C。
   - 加载 B。
   - 缓存状态：`[A, D, B]`

7. **访问 E**：
   - 缓存未命中，缓存已满，淘汰最近最少使用的 A。
   - 加载 E。
   - 缓存状态：`[D, B, E]`

#### **步骤 3：结果**
- **缓存命中次数**：1 次（访问 A 时命中）。
- **最后缓存中即将被淘汰的数据项**：如果接下来缓存已满且需要加载新数据项，LRU 会淘汰 **D**（因为 D 是最近最少使用的）。

---

### **4. 通用计算方法**
1. **缓存命中次数**：
   - 遍历数据项访问顺序，统计数据项是否在缓存中。
   - 如果在缓存中，则命中次数加 1，并更新数据项的访问顺序。
   - 如果不在缓存中，则加载数据项，并淘汰最近最少使用的数据项（如果缓存已满）。

2. **最后缓存中即将被淘汰的数据项**：
   - 根据缓存中数据项的访问顺序，找到最近最少使用的数据项。

---

### **5. 代码实现（Python 示例）**
以下是 LRU 缓存命中次数和淘汰数据项的 Python 实现：

```python
from collections import OrderedDict

def lru_cache_hits(access_sequence, cache_capacity):
    cache = OrderedDict()
    hits = 0

    for item in access_sequence:
        if item in cache:
            # 缓存命中
            hits += 1
            # 更新访问顺序
            cache.move_to_end(item)
        else:
            # 缓存未命中
            if len(cache) >= cache_capacity:
                # 淘汰最近最少使用的数据项
                cache.popitem(last=False)
            # 加载新数据项
            cache[item] = True

    # 最后缓存中即将被淘汰的数据项
    if cache:
        next_evicted = next(iter(cache))
    else:
        next_evicted = None

    return hits, next_evicted

# 示例
access_sequence = ['A', 'B', 'C', 'A', 'D', 'B', 'E']
cache_capacity = 3
hits, next_evicted = lru_cache_hits(access_sequence, cache_capacity)

print("缓存命中次数:", hits)
print("最后缓存中即将被淘汰的数据项:", next_evicted)
```

---

### **6. 输出结果**
对于示例数据：
- **缓存命中次数**：1
- **最后缓存中即将被淘汰的数据项**：D

---

通过以上方法，可以计算任意数据项访问顺序下的缓存命中次数和即将被淘汰的数据项。



## 完全二叉树N个节点，节点为i为左孩子的判断表达式是？其父节点的下标为？i所在层数？

对于完全二叉树，节点编号从1开始，逐层从左到右依次编号。以下是相关问题的解答：

### 1. 节点i为左孩子的判断表达式
在完全二叉树中，节点i的左孩子节点编号为2i。因此，节点i是否为左孩子可以通过以下表达式判断：
- 如果i是偶数，则i是其父节点的左孩子。

### 2. 节点i的父节点的下标
节点i的父节点下标为：
- 父节点下标 = floor(i / 2)

### 3. 节点i所在的层数
节点i所在的层数可以通过以下公式计算：
- 层数 = floor(log₂i) + 1

### 示例
假设i = 4：
- 判断是否为左孩子：4是偶数，因此是左孩子。
- 父节点下标：floor(4 / 2) = 2
- 所在层数：floor(log₂4) + 1 = 2 + 1 = 3

这些公式适用于完全二叉树中任意节点i的判断和计算。



## 给男女玩家比例，男女玩家扮演男女角色的偏好比例数据，求一个游戏中女性角色是女玩家的概率

https://blog.nowcoder.net/n/9a40767902fc4699b2c14978d930d11c

https://blog.csdn.net/weixin_41563161/article/details/114456805



相对现实世界来说,网络游戏世界给了我们更大的自由度。比如,在网络游戏中,我们可以选择不同性别的角色,比如和自己性别不相同的角色。通过统计得知以下信息。

 

***\*a某游戏男性玩家和女性玩家的比率如下:\****

男性玩家女性玩家

0.80 0.20 

 

***\*b.玩家对于扮演不同性别角色的偏好如下:\****

***\*男性角色\****  ***\*女性角色\****

***\*男性玩家\****  0.75 0.25

***\*女性玩家\****  0.1  0.9

注:0.6表示男性玩家选择游戏中扮演男性角色的比例求游戏中女性角色中是一个女性玩家的概率是 ？

 ![img](assets/613861755_1618025153246_014AA794B8DE2B0593F9F6C4BE7243D9.png)

 ![img](assets/613861755_1618025153324_7C56B49B64AFAF6313AE3BEC8712F178.png)

 

[贝叶斯定理](https://baike.baidu.com/item/贝叶斯定理/1185949)由英国数学家贝叶斯 ( Thomas Bayes 1702-1761 ) 发展，用来描述两个条件[概率](https://baike.baidu.com/item/概率)之间的关系，

比如 P(A|B) 和 P(B|A)。按照乘法法则，可以立刻导出：P(A∩B) = P(A)*P(B|A)=P(B)*P(A|B)。如上公式也可变形为：P(A|B)=P(B|A)*P(A)/P(B)。

 ![img](assets/613861755_1618025153434_014AA794B8DE2B0593F9F6C4BE7243D9.png)

![img](assets/613861755_1618025153733_014AA794B8DE2B0593F9F6C4BE7243D9.png)

 ![img](assets/613861755_1618025153989_014AA794B8DE2B0593F9F6C4BE7243D9.png)

 



 **另一个例子，现分别有 A、B 两个容器，在容器 A 里分别有 7 个红球和 3 个白球，在容器 B 里有 1 个红球和 9 个白球，现已知从这两个容器里任意抽出了一个红球，问这个球来自容器 A 的概率是多少?**



**假设已经抽出红球为事件 B，选中容器 A 为事件 A，**

 

**则有：P(B) = 8/20，P(A) = 1/2，P(B|A) = 7/10，按照公式，则有：P(A|B) = (7/10)\*(1/2) / (8/20) = 0.875**

![image-20250211165508118](assets/image-20250211165508118.png)





这个题目使用贝叶斯公式

我们需要计算的是：**在游戏中扮演女性角色的玩家中，实际是女性玩家的概率**。这个问题可以通过贝叶斯公式来解决。

---

### **已知数据**

1. **玩家性别比例**：
   - 男性玩家：$ P(M) = 0.8 $
   - 女性玩家：$ P(F) = 0.2 $

2. **玩家扮演角色的偏好**：
   - 男性玩家扮演男性角色的概率：$ P(R_M | M) = 0.75 $
   - 男性玩家扮演女性角色的概率：$ P(R_F | M) = 0.25 $
   - 女性玩家扮演男性角色的概率：$ P(R_M | F) = 0.1 $
   - 女性玩家扮演女性角色的概率：$ P(R_F | F) = 0.9 $

---

### **目标**

计算在游戏中扮演女性角色的玩家中，实际是女性玩家的概率，即：
$$
P(F | R_F)
$$

---

### **贝叶斯公式**

贝叶斯公式为：
$$
P(F | R_F) = \frac{P(R_F | F) \cdot P(F)}{P(R_F)}
$$
其中：

- $ P(R_F | F) $ 是女性玩家扮演女性角色的概率（已知为 0.9）。
- $ P(F) $ 是女性玩家的比例（已知为 0.2）。
- $ P(R_F) $ 是游戏中扮演女性角色的总概率，需要通过全概率公式计算。

---

### **计算 $ P(R_F) $**

$ P(R_F) $ 是游戏中扮演女性角色的总概率，可以通过全概率公式计算：
$$
P(R_F) = P(R_F | M) \cdot P(M) + P(R_F | F) \cdot P(F)
$$
代入已知数据：
$$
P(R_F) = 0.25 \cdot 0.8 + 0.9 \cdot 0.2 = 0.2 + 0.18 = 0.38
$$

---

### **代入贝叶斯公式**

将 $ P(R_F | F) $、$ P(F) $ 和 $ P(R_F) $ 代入贝叶斯公式：
$$
P(F | R_F) = \frac{0.9 \cdot 0.2}{0.38} = \frac{0.18}{0.38} \approx 0.4737
$$

---

### **结果**

在游戏中扮演女性角色的玩家中，实际是女性玩家的概率约为 **47.37%**。

---

### **总结**

通过贝叶斯公式，我们计算得出：
$$
P(F | R_F) \approx 47.37\%
$$
这意味着在游戏中扮演女性角色的玩家中，约有 47.37% 是女性玩家。





KD-Tree


线程的调度

操作系统内存管理 小林coding

内存调度不够了怎么办

Window应用程序内存分配策略

排列组合的题

进制转换



讲一下RPC的几种写法

指针和引用的区别，什么时候用指针什么时候用引用？

讲下抽象类。那既然它不能被构造出实例，那他存在意义是什么？

在函数里面的临时变量是在堆还是栈

用过正则表达式吗？这个正则表达式能匹配什么串？^[^d]+.*d$

给定文法: A -> aAb|cc, 下列符号串可由其推导出的有  A. accccb  B. aaccbb  C. acb  D. accb

 动画同步怎么做的？

描述一下你的延迟补偿具体思路



### RPC的几种写法

RPC（Remote Procedure Call，远程过程调用）的实现方式有多种，常见的包括：

1. **基于HTTP的RPC**：
   - 使用HTTP协议进行通信，通常使用JSON或XML作为数据格式。
   - 例如：RESTful API、gRPC（基于HTTP/2）。

2. **基于TCP/UDP的RPC**：
   - 直接使用TCP或UDP协议进行通信，通常自定义协议格式。
   - 例如：Thrift、Apache Avro。

3. **基于消息队列的RPC**：
   - 使用消息队列（如RabbitMQ、Kafka）进行异步通信。
   - 例如：ZeroMQ、AMQP。

4. **基于共享内存的RPC**：
   - 在同一台机器上，通过共享内存进行进程间通信。
   - 例如：Windows的LPC（Local Procedure Call）。

5. **基于WebSocket的RPC**：
   - 使用WebSocket进行全双工通信，适合实时应用。
   - 例如：Socket.IO。

### 指针和引用的区别

**指针**：
- 指针是一个变量，存储的是另一个变量的内存地址。
- 指针可以为空（nullptr）。
- 指针可以重新指向其他变量。
- 使用指针时需要解引用（*）来访问实际的值。

**引用**：
- 引用是一个变量的别名，本质上是对另一个变量的直接引用。
- 引用必须在声明时初始化，且不能重新绑定到其他变量。
- 引用不能为空。
- 使用引用时不需要解引用，直接使用即可。

**何时使用指针**：
- 当需要表示“无”或“空”时（如链表中的空指针）。
- 当需要重新指向其他对象时。
- 当需要动态分配内存时（如使用`new`和`delete`）。

**何时使用引用**：
- 当不需要重新绑定到其他对象时。
- 当函数参数需要传递大对象且不希望拷贝时。
- 当实现操作符重载时（如`operator=`）。

### 抽象类

**抽象类**：
- 抽象类是包含至少一个纯虚函数（`virtual void func() = 0;`）的类。
- 抽象类不能被实例化，只能作为基类被继承。
- 派生类必须实现所有的纯虚函数，否则派生类也会成为抽象类。

**抽象类的意义**：
- **定义接口**：抽象类可以定义一组接口，强制派生类实现这些接口，确保派生类具有某些行为。
- **代码复用**：抽象类可以包含一些通用的实现，派生类可以复用这些实现。
- **多态性**：通过基类指针或引用调用派生类的实现，实现运行时多态。

### 函数里面的临时变量是在堆还是栈

- **栈**：函数中的临时变量（局部变量）通常存储在栈上。栈是一种后进先出（LIFO）的数据结构，函数调用时分配，函数返回时自动释放。
- **堆**：动态分配的内存（如使用`new`或`malloc`）存储在堆上。堆上的内存需要手动管理（使用`delete`或`free`）。

### 正则表达式

正则表达式：`^[^d]+.*d$`

- `^`：匹配字符串的开头。
- `[^d]+`：匹配一个或多个不是`d`的字符。
- `.*`：匹配任意数量的任意字符（包括空字符）。
- `d$`：匹配以`d`结尾的字符串。

**匹配的字符串**：
- 该正则表达式匹配以非`d`字符开头，中间可以有任意字符，最后以`d`结尾的字符串。
- 例如：`abcd`, `xyz123d`, `123d`。

`[^d]+` 是正则表达式中的一个模式，具体含义如下：

- `[^d]`：`[^...]` 表示一个字符类，匹配 **不在** 方括号内的字符。`[^d]` 表示匹配 **不是 `d` 的任意一个字符**。
- `+`：表示匹配前面的模式 **一次或多次**。

因此，`[^d]+` 表示匹配 **一个或多个不是 `d` 的字符**。

**示例**：

- 字符串 `abc`：匹配 `abc`，因为 `a`、`b`、`c` 都不是 `d`。
- 字符串 `a1d2`：匹配 `a1`，因为 `a` 和 `1` 不是 `d`，遇到 `d` 停止匹配。
- 字符串 `ddd`：不匹配，因为所有字符都是 `d`。

### 文法推导

给定文法：`A -> aAb | cc`

- **A. accccb**：不符合，因为`A -> aAb`只能生成`aAb`，无法生成`accccb`。
- **B. aaccbb**：符合，`A -> aAb -> aaAbb -> aaccbb`。
- **C. acb**：不符合，因为`A -> aAb`无法生成`acb`。
- **D. accb**：符合，`A -> aAb -> accb`。

**答案**：B 和 D。

给定文法：`A -> aAb | cc`

这是一个上下文无关文法（CFG），表示非终结符 `A` 可以推导出两种形式：

1. `aAb`：`A` 可以推导为 `a` 加上 `A` 加上 `b`。
2. `cc`：`A` 可以直接推导为 `cc`。

**推导规则**：

- 从 `A` 开始，可以选择 `aAb` 或 `cc`。
- 如果选择 `aAb`，则可以继续推导 `A`，直到选择 `cc` 结束。

**推导示例**：

1. `A -> aAb`：选择 `aAb`。
2. `A -> aAb`：再次选择 `aAb`，得到 `aaAbb`。
3. `A -> cc`：选择 `cc`，得到 `aaccbb`。

**题目分析**：

- **A. accccb**：不符合，因为无法通过 `A -> aAb` 生成 `accccb`。
- **B. aaccbb**：符合，推导过程为 `A -> aAb -> aaAbb -> aaccbb`。
- **C. acb**：不符合，因为无法通过 `A -> aAb` 生成 `acb`。
- **D. accb**：符合，推导过程为 `A -> aAb -> accb`。

**答案**：B 和 D。

### 动画同步

**动画同步**：
- **时间同步**：使用时间戳或帧率来同步动画的播放。
- **事件驱动**：通过事件触发动画的开始、暂停、停止等操作。
- **插值**：在关键帧之间进行插值计算，确保动画平滑过渡。
- **物理引擎**：使用物理引擎模拟真实世界的物理效果，确保动画的物理行为一致。

### 延迟补偿

**延迟补偿**：
- **客户端预测**：客户端在发送操作后立即预测结果，减少用户感知的延迟。
- **服务器回滚**：服务器接收到客户端操作后，回滚到操作发生时的状态，重新计算并广播结果。
- **插值和外推**：在客户端和服务器之间使用插值和外推技术，平滑显示其他玩家的动作。
- **时间同步**：确保客户端和服务器的时间同步，减少时间差带来的延迟影响。

这些技术通常用于实时多人在线游戏，以减少网络延迟对游戏体验的影响。

#### 1. 为什么用 Protobuf？

Protobuf（Protocol Buffers）是一种高效的序列化工具，常用于数据交换和存储。使用 Protobuf 的原因包括：

- **高效**：二进制格式，比 JSON 和 XML 更小、更快。
- **跨语言支持**：支持多种编程语言（如 C++、Java、Python 等）。
- **可扩展**：支持向后兼容的字段更新。
- **强类型**：定义清晰的数据结构，减少错误。

#### 2. Protobuf 里面 int 有哪些类型？你用过哪些？

Protobuf 支持的整数类型包括：

- `int32`：32 位有符号整数。
- `int64`：64 位有符号整数。
- `uint32`：32 位无符号整数。
- `uint64`：64 位无符号整数。
- `sint32`、`sint64`：有符号整数，适合存储负数（更高效的编码）。
- `fixed32`、`fixed64`：固定长度的无符号整数。

常用的是 `int32` 和 `int64`。

#### 3. `static` 一般有哪些用法？

- **静态局部变量**：函数内的静态变量，生命周期为整个程序运行期间，但作用域仅限于函数内。
- **静态全局变量**：文件作用域的静态变量，只在定义它的文件内可见。
- **静态成员变量**：类的静态成员，属于类而非对象，所有对象共享。
- **静态成员函数**：类的静态函数，只能访问静态成员变量，不能访问非静态成员。

#### 4. 用 `static` 声明的类的成员变量，在进程内存空间里存在哪个区域？这个存储区还存了什么？

- **存储区域**：静态成员变量存储在 **全局/静态存储区**。
- **存储区内容**：该区域还存储了全局变量、静态全局变量、常量等。

#### 5. 内核态和用户态什么情况下会发生切换？

- **系统调用**：用户程序调用操作系统提供的接口（如 `read`、`write`）。
- **中断**：硬件中断（如键盘输入、时钟中断）触发内核处理。
- **异常**：程序运行时的异常（如除零错误）需要内核处理。

### 正则表达式 `[^d]+` 的解释

`[^d]+` 是正则表达式中的一个模式，具体含义如下：

- `[^d]`：`[^...]` 表示一个字符类，匹配 **不在** 方括号内的字符。`[^d]` 表示匹配 **不是 `d` 的任意一个字符**。
- `+`：表示匹配前面的模式 **一次或多次**。

因此，`[^d]+` 表示匹配 **一个或多个不是 `d` 的字符**。

**示例**：
- 字符串 `abc`：匹配 `abc`，因为 `a`、`b`、`c` 都不是 `d`。
- 字符串 `a1d2`：匹配 `a1`，因为 `a` 和 `1` 不是 `d`，遇到 `d` 停止匹配。
- 字符串 `ddd`：不匹配，因为所有字符都是 `d`。

---

### 文法推导

给定文法：`A -> aAb | cc`

这是一个上下文无关文法（CFG），表示非终结符 `A` 可以推导出两种形式：
1. `aAb`：`A` 可以推导为 `a` 加上 `A` 加上 `b`。
2. `cc`：`A` 可以直接推导为 `cc`。

**推导规则**：
- 从 `A` 开始，可以选择 `aAb` 或 `cc`。
- 如果选择 `aAb`，则可以继续推导 `A`，直到选择 `cc` 结束。

**推导示例**：
1. `A -> aAb`：选择 `aAb`。
2. `A -> aAb`：再次选择 `aAb`，得到 `aaAbb`。
3. `A -> cc`：选择 `cc`，得到 `aaccbb`。

**题目分析**：
- **A. accccb**：不符合，因为无法通过 `A -> aAb` 生成 `accccb`。
- **B. aaccbb**：符合，推导过程为 `A -> aAb -> aaAbb -> aaccbb`。
- **C. acb**：不符合，因为无法通过 `A -> aAb` 生成 `acb`。
- **D. accb**：符合，推导过程为 `A -> aAb -> accb`。

**答案**：B 和 D。

---

### 面试题目

#### 1. 为什么用 Protobuf？
Protobuf（Protocol Buffers）是一种高效的序列化工具，常用于数据交换和存储。使用 Protobuf 的原因包括：
- **高效**：二进制格式，比 JSON 和 XML 更小、更快。
- **跨语言支持**：支持多种编程语言（如 C++、Java、Python 等）。
- **可扩展**：支持向后兼容的字段更新。
- **强类型**：定义清晰的数据结构，减少错误。

#### 2. Protobuf 里面 int 有哪些类型？你用过哪些？
Protobuf 支持的整数类型包括：
- `int32`：32 位有符号整数。
- `int64`：64 位有符号整数。
- `uint32`：32 位无符号整数。
- `uint64`：64 位无符号整数。
- `sint32`、`sint64`：有符号整数，适合存储负数（更高效的编码）。
- `fixed32`、`fixed64`：固定长度的无符号整数。

常用的是 `int32` 和 `int64`。

#### 3. `static` 一般有哪些用法？
- **静态局部变量**：函数内的静态变量，生命周期为整个程序运行期间，但作用域仅限于函数内。
- **静态全局变量**：文件作用域的静态变量，只在定义它的文件内可见。
- **静态成员变量**：类的静态成员，属于类而非对象，所有对象共享。
- **静态成员函数**：类的静态函数，只能访问静态成员变量，不能访问非静态成员。

#### 4. 用 `static` 声明的类的成员变量，在进程内存空间里存在哪个区域？这个存储区还存了什么？
- **存储区域**：静态成员变量存储在 **全局/静态存储区**。
- **存储区内容**：该区域还存储了全局变量、静态全局变量、常量等。

#### 5. 内核态和用户态什么情况下会发生切换？
- **系统调用**：用户程序调用操作系统提供的接口（如 `read`、`write`）。
- **中断**：硬件中断（如键盘输入、时钟中断）触发内核处理。
- **异常**：程序运行时的异常（如除零错误）需要内核处理。

#### 6. 你用过什么系统调用？

在[电脑](https://zh.wikipedia.org/wiki/電腦)中，**系统调用**（英语：system call），指运行在[用户空间](https://zh.wikipedia.org/wiki/使用者空間)的[程序](https://zh.wikipedia.org/wiki/程序)向[操作系统](https://zh.wikipedia.org/wiki/操作系统)[内核](https://zh.wikipedia.org/wiki/内核)请求需要更高权限运行的服务。系统调用提供用户程序与[操作系统](https://zh.wikipedia.org/wiki/操作系统)之间的接口。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。

常见的系统调用包括：
- 文件操作：`open`、`read`、`write`、`close`。
- 进程控制：`fork`、`exec`、`wait`。
- 网络通信：`socket`、`bind`、`connect`。
- 内存管理：`mmap`、`brk`。

#### 7. `fork` 是用来干嘛的？
`fork` 用于创建一个新进程。调用 `fork` 后，会创建一个与父进程几乎完全相同的子进程，子进程从 `fork` 的返回值开始执行。

#### 8. 你知道哪些进程调度算法？
- **先来先服务（FCFS）**：按到达顺序调度。
- **短作业优先（SJF）**：优先调度运行时间短的进程。
- **时间片轮转（RR）**：每个进程分配一个时间片，轮流执行。
- **优先级调度**：按优先级调度进程。
- **多级反馈队列（MFQ）**：结合优先级和时间片的调度算法。

#### 9. 什么叫高响应比优先？响应比怎么定义的？
- **高响应比优先（HRRN）**：一种非抢占式调度算法，优先调度响应比高的进程。
- **响应比定义**：`响应比 = (等待时间 + 服务时间) / 服务时间`。
  - 等待时间：进程在就绪队列中等待的时间。
  - 服务时间：进程需要的运行时间。

响应比越高，表示进程等待时间越长，优先级越高。



### 12. TCP 确认机制与拥塞控制

#### 发送方如何知道接收方收到了数据？
- **确认机制（ACK）**：
  - 接收方收到数据后，会发送一个确认报文（ACK）给发送方，ACK 中包含已成功接收的最后一个字节的序列号。
  - 发送方收到 ACK 后，就知道接收方已经成功接收了数据。

#### 如果好久没有收到确认报文，会怎么样？
- **超时重传**：
  - 发送方会为每个发送的报文段启动一个定时器。
  - 如果在定时器超时前没有收到 ACK，发送方会认为数据包丢失，触发重传。

#### 如果接收方网络拥塞，跟不上接收速度，TCP 如何处理？
- **流量控制**：
  - 接收方通过 TCP 头部的窗口大小字段告诉发送方自己的接收缓冲区剩余空间。
  - 发送方根据窗口大小调整发送速率，避免发送过多数据导致接收方缓冲区溢出。
- **拥塞控制**：
  - **慢启动**：初始阶段指数增长发送窗口，探测网络容量。
  - **拥塞避免**：窗口达到阈值后线性增长。
  - **快速重传**：收到 3 个重复 ACK 时立即重传丢失的包。
  - **快速恢复**：重传后直接进入拥塞避免阶段，避免过度降低发送速率。

---

### 13. 进程间通信（IPC）的方式

进程间通信的常见方式包括：
1. **管道（Pipe）**：
   - 单向通信，适用于父子进程。
   - 例如：`pipe()` 系统调用。
2. **命名管道（FIFO）**：
   - 可以在无关进程间使用，通过文件系统路径访问。
   - 例如：`mkfifo()`。
3. **消息队列**：
   - 通过消息队列传递数据，支持多对多通信。
   - 例如：`msgget()`、`msgsnd()`、`msgrcv()`。
4. **共享内存**：
   - 多个进程共享同一块内存区域，通信速度最快。
   - 例如：`shmget()`、`shmat()`。
5. **信号量**：
   - 用于进程间的同步，避免竞争条件。
   - 例如：`semget()`、`semop()`。
6. **套接字（Socket）**：
   - 支持网络通信和本地进程间通信。
   - 例如：`socket()`、`bind()`、`connect()`。
7. **信号（Signal）**：
   - 用于通知进程某个事件的发生。
   - 例如：`kill()`、`signal()`。

---

### 14. 生产者消费者问题的处理思路

生产者消费者问题是经典的同步问题，解决思路如下：
1. **共享缓冲区**：
   - 生产者将数据放入缓冲区，消费者从缓冲区取出数据。
2. **同步机制**：
   - **互斥锁（Mutex）**：保证同一时刻只有一个线程访问缓冲区。
   - **信号量（Semaphore）**：
     - 一个信号量表示缓冲区空闲空间（初始值为缓冲区大小）。
     - 另一个信号量表示缓冲区中数据的数量（初始值为 0）。
3. **流程**：
   - 生产者：
     1. 等待空闲空间信号量。
     2. 获取互斥锁。
     3. 将数据放入缓冲区。
     4. 释放互斥锁。
     5. 增加数据数量信号量。
   - 消费者：
     1. 等待数据数量信号量。
     2. 获取互斥锁。
     3. 从缓冲区取出数据。
     4. 释放互斥锁。
     5. 增加空闲空间信号量。

---

### 15. 平衡二叉树与最大堆

#### 平衡二叉树
- **定义**：
  - 平衡二叉树是一种二叉搜索树（BST），且满足以下条件：
    - 左右子树的高度差不超过 1。
    - 左右子树也是平衡二叉树。
- **常见实现**：
  - AVL 树、红黑树。
- **特点**：
  - 查找、插入、删除的时间复杂度为 \(O(\log n)\)。

#### 最大堆
- **定义**：
  - 最大堆是一种完全二叉树，且满足以下条件：
    - 每个节点的值大于或等于其子节点的值。
    - 根节点是堆中的最大值。
- **特点**：
  - 常用于优先队列。
  - 插入和删除的时间复杂度为 \(O(\log n)\)。
  - 获取最大值的时间复杂度为 \(O(1)\)。

---

### 总结
- TCP 通过 ACK 确认机制和拥塞控制保证可靠传输。
- 进程间通信方式包括管道、消息队列、共享内存等。
- 生产者消费者问题通过互斥锁和信号量解决同步问题。
- 平衡二叉树和最大堆是两种重要的数据结构，分别用于高效查找和优先队列。

# 3243 新增道路查询后的最短距离

```c++
class Solution {
public:
    int bfs(vector<vector<int>>& graph, int start, int end)
    {
        queue<int> que;
        int n = graph.size();
        vector<int> dist(n, -1); //记录起点到当前的最短距离
        dist[start] = 0; //
        que.push(start);
        while(!que.empty())
        {
            int cur = que.front();
            que.pop();
            for(int v: graph[cur])
            {
                if(dist[v]>0) continue; //意味着已经有算过一次了,这次不会比上次计算的更短,因为是BFS
                dist[v] = dist[cur] + 1;
                que.push(v);
            }
        }
        return dist[end];
    }
    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        //bfs
        vector<vector<int>> graph(n);
        for(int i=0;i<n-1;i++)
        {
            graph[i].push_back(i+1);
        }
        vector<int> res;
        for(int i=0;i<queries.size();i++)
        {
            graph[queries[i][0]].push_back(queries[i][1]);
            res.emplace_back(bfs(graph, 0, n-1));
        }
        return res;
    }
};
```



# 1311. 获取你好友已观看的视频

```c++
class Solution {
public:
    using PSI = pair<string, int>;
    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {
        //bfs
        queue<int> que;
        que.push(id); //把要找的id放进去
        unordered_map<string, int> freq; //key:视频名字, value:观看次数
        vector<int> visited(friends.size(), 0); //无向图,需要记录visited
        visited[id] = 1;
        int k=0;

        //先找到第level层的好友
        while(level--)
        {
            int size = que.size();
            for(int i=0;i<size;i++)
            {
                int cur = que.front();
                que.pop();
                for(int v: friends[cur])
                {
                    if(!visited[v])
                    {
                        visited[v]=1;
                        que.push(v);
                    }
                }
            }
        }
        while(!que.empty())
        {
            int cur = que.front(); //当前层的记录
            cout<<cur<<endl;
            que.pop(); 
            for(string s: watchedVideos[cur]) //把这个好友看过的所有视频记录一下
            {
                freq[s] += 1;
            }
        }
        vector<PSI> vec(freq.begin(), freq.end());
        sort(vec.begin(), vec.end(), [](const PSI& p, const PSI& q){
            return p.second < q.second || (p.second==q.second && p.first < q.first);
        });
        vector<string> res;
        for(const PSI& p: vec)
        {
            res.emplace_back(p.first);
        }
        return res;
    }
};
```



# 931. 下降路径最小和

```c++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        //参考三角形那题试一次即可
        int n = matrix.size();
        vector<vector<int>> dp(n, vector<int>(n,0));
        //给第一行赋值
        for(int i=0;i<n;i++) dp[0][i]=matrix[0][i];
        //开始计算后面的行
        for(int i=1;i<n;i++)
        {
            dp[i][0]=min(dp[i-1][0], dp[i-1][1])+matrix[i][0];
            for(int j=1;j<n-1;j++) //中间的
            {
                dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]), dp[i-1][j+1])+matrix[i][j];
            }
            //最右侧的
            dp[i][n-1] = min(dp[i-1][n-1], dp[i-1][n-2])+matrix[i][n-1];
        }
        //最下面一行做判断
        int res = INT_MAX;
        for(int i=0;i<n;i++) res = min(res, dp[n-1][i]);
        return res;
    }
};
```



# ==2684. 矩阵中移动的最大次数==

> 写的不好。。。题单虽然在动规里，但其实用BFS或者DFS可能会更快，可以尝试一下学完教我！

```c++
class Solution {
public:
    int maxMoves(vector<vector<int>>& grid) {
        //这个做法有点邪门,是用dp做的,复杂度挺高,其实用bfs和dfs也可以做,先不做了
        //每次col一定会+1,所以跟前面的题是类似的
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n)); //dp记录是否可达,1表示可达,0表示不可达
        //第一列赋初值,其实都是1了,第一列都可达
        for(int i=0;i<m;i++) dp[i][0]=1;
        //开始dp,注意从左扫到右
        int res = 0;
        for(int j=1;j<n;j++)
        {
            //dp关注的几个值
            for(int i=0;i<m;i++)
            {
                int l=(grid[i][j-1]<grid[i][j])? dp[i][j-1]:0;  //是否从左侧可达?
                int lu = (i>0 && grid[i-1][j-1]<grid[i][j])? dp[i-1][j-1]:0; //是否从左上侧可达?
                int ld = (i<m-1 && grid[i+1][j-1]<grid[i][j])? dp[i+1][j-1]:0; //是否从左下侧可达?
                dp[i][j] = (l || lu || ld); 
                if(dp[i][j]==1) res = j;
            }
        }
        return res;
    }
};
```





# [1129. 颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/)

```c++
class Solution {
public:
    vector<vector<int>> bfs(vector<vector<vector<int>>>& graph)
    {
        //并没有说先从蓝色边还是先从红色边开始,都要尝试一下
        int n = graph[0].size();
        vector<vector<int>> dist(2, vector<int>(n, INT_MAX));
        dist[0][0] = 0;
        dist[1][0] = 0;
        queue<pair<int, int>> que; //pair<int,int>的第一个值表示红/蓝,第二个值跟原来BFS存的东西一样
        que.push({0,0});
        que.push({1,0});
        while(!que.empty())
        {
            auto cur = que.front();
            que.pop();
            int t = cur.first;
            for(int v: graph[1-t][cur.second])
            {
                if(dist[1-t][v] != INT_MAX) continue; //说明在BFS的过程中已经访问过,因为没权重,所以一定是最短的,跟之前的题目类似
                dist[1-t][v] = dist[t][cur.second] + 1; //注意更新的逻辑
                que.push({1-t, v});
            }
        }
        //cout<<"dist.size "<<dist[0].size()<<endl;
        return dist;
    }
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        //红蓝交替,存两个graph
        vector<vector<vector<int>>> graphs(2, vector<vector<int>>(n));
        //把红色的graph构建好,红色的放在graph[0]里面,蓝色的放在graph[1]里面
        for(int i=0;i<redEdges.size();i++)
        {
            graphs[0][redEdges[i][0]].emplace_back(redEdges[i][1]); //注意是有向图
        }
        //蓝色的构建好
        for(int i=0;i<blueEdges.size();i++)
        {
            graphs[1][blueEdges[i][0]].emplace_back(blueEdges[i][1]);
        }

        vector<vector<int>> dist = bfs(graphs);
        vector<int> res;
        for(int i=0;i<dist[0].size();i++)
        {
            int mi = min(dist[0][i], dist[1][i]);
            if(mi == INT_MAX) mi = -1;
            res.push_back(mi);
        }
        return res;
    }
};
```







# [2304. 网格中的最小路径代价](https://leetcode.cn/problems/minimum-path-cost-in-a-grid/)

```c++
class Solution {
public:
    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {
        //跟前面的题目类似
        int m = grid.size(); //行数
        int n = grid[0].size(); //列数
        vector<vector<int>> dp(m, vector<int>(n,0)); //dp记录抵达当前位置的最小代价,把当前格子算上
        //初始化：最上面一行
        for(int i=0;i<n;i++) dp[0][i]=grid[0][i]; 
        //dp过程，j由列来自0~j的共同决定
        for(int i=1;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                dp[i][j] = INT_MAX;
                for(int k=0;k<n;k++)
                {
                    //题目的难点在于数组对应的索引比较绕
                    //cout<<moveCost[grid[i-1][k]][j]<<endl;
                    dp[i][j]=min(dp[i][j], dp[i-1][k]+moveCost[grid[i-1][k]][j]+grid[i][j]);
                } 
                //cout<<i<<" "<<j<<" "<<dp[i][j]<<endl;
            }
        }
        //找最后一行的最小值
        int res = INT_MAX;
        for(int i=0;i<n;i++) res=min(res, dp[m-1][i]); 
        return res;

    }
};
```



# [1289. 下降路径最小和 II](https://leetcode.cn/problems/minimum-falling-path-sum-ii/)

普通做法：

```c++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& grid) {
        //要全部遍历一下
        int n = grid.size();
        if(n==1) return grid[0][0];
        vector<vector<int>> dp(n, vector<int>(n)); 
        //初始化dp数组
        for(int i=0;i<n;i++) dp[0][i]=grid[0][i];
        for(int i=1;i<n;i++) //遍历行
        {
            for(int j=0;j<n;j++)  //遍历列
            {
                dp[i][j] = INT_MAX;
                for(int k=0;k<n;k++)
                {
                    if(k!=j) dp[i][j]=min(dp[i][j], dp[i-1][k]+grid[i][j]);
                }
            }
        }
        int res = INT_MAX;
        for(int i=0;i<n;i++)
            res = min(res, dp[n-1][i]);
        return res;
    }
};
```

从击败结果来看不太理想hhh，学习一下比较快的解法的思路（很是优化啊，但代码是真不好写）：

```c++
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& grid) {
        //实际上这题都不需要dp数组，根据刚才的做法每一行的最小值可以由上一行的最小值或者上一行的次小值推导而来
        int minValue = INT_MAX; //最小值
        int subMinValue = INT_MAX; //次小值
        int minValueIndex=-1; //最小值的索引
        int n = grid.size();
        if(n==1) return grid[0][0];
        //思考dp状态
        //if i==0: dp[i][j] = grid[i][j];
        //if i>0:
        //  理论上： dp[i][j]=min(dp[i-1][k])+grid[i][j], k \in [0, n) 且 k!=j
        //  那么就可以优化：min(dp[i-1][k])实际上就是上一行的最小值，记录其索引，如果索引=当前j，则选择次小值作为结果
        
        //先算第一行，求出最小值，次小值和最小值对应列索引,此时比较的值就是grid[0][i]
        for(int i=0;i<n;i++)
        {
            if(grid[0][i]<minValue)
            {
                subMinValue = minValue;
                minValue = grid[0][i];
                minValueIndex = i;
            }
            else if(grid[0][i]<subMinValue) subMinValue = grid[0][i]; 
        }
        int sumMinValue = minValue;
        int sumSubMinValue = subMinValue;
        int g_minIndex = minValueIndex;
        for(int i=1;i<n;i++)
        {
            minValue = INT_MAX, subMinValue = INT_MAX, minValueIndex = -1;
            for(int j=0;j<n;j++)
            {
                int pre = 0;
                if(j==g_minIndex) pre = sumSubMinValue;
                else pre = sumMinValue;
                if(pre+grid[i][j]<minValue)
                {
                    subMinValue = minValue;
                    minValue = pre+grid[i][j];
                    minValueIndex = j;
                }
                else if(pre+grid[i][j]<subMinValue) subMinValue = pre+grid[i][j];
            }
            sumMinValue= minValue;
            sumSubMinValue = subMinValue;
            g_minIndex = minValueIndex;
        }
        return minValue;
    }
};
```

> 感慨：多学点算法，多写点代码，以后做单效率又高，代码质量又好。



# [3418. 机器人可以获得的最大金币数](https://leetcode.cn/problems/maximum-amount-of-money-robot-can-earn/)

```c++
class Solution {
public:
    int maximumAmount(vector<vector<int>>& coins) {
        //之前那个为了简化初始化等过程，可读性比较差，这里来一个正常的版本
        int m = coins.size();
        int n = coins[0].size();
        vector dp(m+1, vector(n+1, array<int,3>{INT_MIN/2, INT_MIN/2, INT_MIN/2}));
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                int x = coins[i-1][j-1];
                if(i==1&&j==1)
                {
                    //特殊计算第一个值
                    dp[i][j] = {x, max(0, x), max(0, x)};
                }
                else
                {
                    dp[i][j][0] = max(dp[i-1][j][0], dp[i][j-1][0])+x;
                    dp[i][j][1] = max({dp[i-1][j][1]+x, dp[i][j-1][1]+x, dp[i-1][j][0], dp[i][j-1][0]});
                    dp[i][j][2] = max({dp[i-1][j][2]+x, dp[i][j-1][2]+x, dp[i-1][j][1], dp[i][j-1][1]});
                }
                
            }
        }
        return max({dp[m][n][0], dp[m][n][1], dp[m][n][2]});
    }
};

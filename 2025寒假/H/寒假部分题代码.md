# 3243 新增道路查询后的最短距离

```c++
class Solution {
public:
    int bfs(vector<vector<int>>& graph, int start, int end)
    {
        queue<int> que;
        int n = graph.size();
        vector<int> dist(n, -1); //记录起点到当前的最短距离
        dist[start] = 0; //
        que.push(start);
        while(!que.empty())
        {
            int cur = que.front();
            que.pop();
            for(int v: graph[cur])
            {
                if(dist[v]>0) continue; //意味着已经有算过一次了,这次不会比上次计算的更短,因为是BFS
                dist[v] = dist[cur] + 1;
                que.push(v);
            }
        }
        return dist[end];
    }
    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        //bfs
        vector<vector<int>> graph(n);
        for(int i=0;i<n-1;i++)
        {
            graph[i].push_back(i+1);
        }
        vector<int> res;
        for(int i=0;i<queries.size();i++)
        {
            graph[queries[i][0]].push_back(queries[i][1]);
            res.emplace_back(bfs(graph, 0, n-1));
        }
        return res;
    }
};
```



# 1311. 获取你好友已观看的视频

```c++
class Solution {
public:
    using PSI = pair<string, int>;
    vector<string> watchedVideosByFriends(vector<vector<string>>& watchedVideos, vector<vector<int>>& friends, int id, int level) {
        //bfs
        queue<int> que;
        que.push(id); //把要找的id放进去
        unordered_map<string, int> freq; //key:视频名字, value:观看次数
        vector<int> visited(friends.size(), 0); //无向图,需要记录visited
        visited[id] = 1;
        int k=0;

        //先找到第level层的好友
        while(level--)
        {
            int size = que.size();
            for(int i=0;i<size;i++)
            {
                int cur = que.front();
                que.pop();
                for(int v: friends[cur])
                {
                    if(!visited[v])
                    {
                        visited[v]=1;
                        que.push(v);
                    }
                }
            }
        }
        while(!que.empty())
        {
            int cur = que.front(); //当前层的记录
            cout<<cur<<endl;
            que.pop(); 
            for(string s: watchedVideos[cur]) //把这个好友看过的所有视频记录一下
            {
                freq[s] += 1;
            }
        }
        vector<PSI> vec(freq.begin(), freq.end());
        sort(vec.begin(), vec.end(), [](const PSI& p, const PSI& q){
            return p.second < q.second || (p.second==q.second && p.first < q.first);
        });
        vector<string> res;
        for(const PSI& p: vec)
        {
            res.emplace_back(p.first);
        }
        return res;
    }
};
```



# [1129. 颜色交替的最短路径](https://leetcode.cn/problems/shortest-path-with-alternating-colors/)

```c++
class Solution {
public:
    vector<vector<int>> bfs(vector<vector<vector<int>>>& graph)
    {
        //并没有说先从蓝色边还是先从红色边开始,都要尝试一下
        int n = graph[0].size();
        vector<vector<int>> dist(2, vector<int>(n, INT_MAX));
        dist[0][0] = 0;
        dist[1][0] = 0;
        queue<pair<int, int>> que; //pair<int,int>的第一个值表示红/蓝,第二个值跟原来BFS存的东西一样
        que.push({0,0});
        que.push({1,0});
        while(!que.empty())
        {
            auto cur = que.front();
            que.pop();
            int t = cur.first;
            for(int v: graph[1-t][cur.second])
            {
                if(dist[1-t][v] != INT_MAX) continue; //说明在BFS的过程中已经访问过,因为没权重,所以一定是最短的,跟之前的题目类似
                dist[1-t][v] = dist[t][cur.second] + 1; //注意更新的逻辑
                que.push({1-t, v});
            }
        }
        //cout<<"dist.size "<<dist[0].size()<<endl;
        return dist;
    }
    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {
        //红蓝交替,存两个graph
        vector<vector<vector<int>>> graphs(2, vector<vector<int>>(n));
        //把红色的graph构建好,红色的放在graph[0]里面,蓝色的放在graph[1]里面
        for(int i=0;i<redEdges.size();i++)
        {
            graphs[0][redEdges[i][0]].emplace_back(redEdges[i][1]); //注意是有向图
        }
        //蓝色的构建好
        for(int i=0;i<blueEdges.size();i++)
        {
            graphs[1][blueEdges[i][0]].emplace_back(blueEdges[i][1]);
        }

        vector<vector<int>> dist = bfs(graphs);
        vector<int> res;
        for(int i=0;i<dist[0].size();i++)
        {
            int mi = min(dist[0][i], dist[1][i]);
            if(mi == INT_MAX) mi = -1;
            res.push_back(mi);
        }
        return res;
    }
};
```


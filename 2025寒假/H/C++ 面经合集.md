# C++ 面经合集

这篇笔记记录所有牛客和其他地方见到的C++面经题目，由于内容非常多，因此比较基础的部分不会给出完全详细的解答，但会给出参考的链接。对于一些题目来说，会给出可执行的代码以方便理解。



# 一、关键词相关

## 1.C++中static和const的区别

### （1）static关键字

【参考资料】《游戏引擎架构》P111、[static静态局部变量初始化问题 - 不想写代码的DBA - 博客园](https://www.cnblogs.com/novice-dxx/p/7094690.html)

static即静态的意思，可以对变量和函数进行修饰。分三种情况：

- （1）当用于文件作用域的时候（即在.h/.cpp文件中直接修饰变量和函数），static意味着这些变量和函数只在本文件可见，其他文件是看不到也无法使用的，可以避免重定义的问题。
- （2）当用于函数作用域时，即作为局部静态变量时，意味着这个变量是全局的，只会进行一次初始化，不会在每次调用时进行重置，但只在这个函数内可见。
- （3）当用于类的声明时，即静态数据成员和静态成员函数，static表示这些数据和函数是所有类对象共享的一种属性，而非每个类对象独有。
  - static变量在类的声明中不占用内存，**因此必须在.cpp文件中定义类静态变量以分配内存。**文件域的静态变量和类的[静态成员变量](https://zhida.zhihu.com/search?content_id=180938976&content_type=Article&match_order=1&q=静态成员变量&zhida_source=entity)在main执行之前的静态初始化过程中分配内存并初始化；局部静态变量在第一次使用时分配内存并初始化。

> 这篇也值得看一下：[C++中static变量的初始化_static 变量初始化-CSDN博客](https://blog.csdn.net/qq_34139994/article/details/105157313)，有一些关于初始化时机的问题。渲染器中有遇到过类的static成员需要在外面初始化的问题。



### （2）const关键字

这里提及三件事：（1）**const的作用？** （2）**指针常量与常量指针** （3）**const重载问题**

【参考资料】《C++ Primer 第五版》2.4节。

#### （a）const的基本知识点

- const对象一旦创建后其值就不能改变，因此const对象必须初始化。
- 默认情况下，const对象只对文件内有效。默认当多个文件中出现了同名的const变量时，等同于在不同文件中分别定义了独立变量；如果想要跨文件共享，在const变量的声明和定义前都加`extern`关键字即可。
- 以下代码会有问题么？答案在C++ Primer p55页，是非法的

```c++
double dval = 3.14;
const int& val = dval;
int& val2 = val; //非法行为，C++的实现是用了一个temp值
```

- const修饰符用来定义常量，具有不可变性。在类中，被const修饰的成员函数，不能修改类中的数据成员；



#### （b）指针和const

以下是一个常量指针（指向常量的指针，不能改变指向对象的值，但是可以改变指向）的例子：

```c++
const double pi = 3.14;
const double* p = &pi; //常量const 指针*， 所以是常量指针，回忆一下解释p是什么的时候我们会从右往左解释，p is a pointer which point to const

//*p = 5.0; //非法
const double e = 2.71828;
p = &e; //ok
```



而以下则是一个指针常量（指针本身是常量，指向不能改，但指向的对象可以改）

```c++
int pi = 3.14;
//int* const p; //Error,必须要初始化
int* const q = &pi; //中文读：指针 常量，英文意思从右往左看
*q = 3.15; //ok  
```

> 总结：**指针常量指的是该指针本身是一个常量，不能被修改，但是指针指向的对象可以被修改，常量指针指的是这个指针指向的对象是一个常量，不能被修改，但是指针本身可以被修改。**
>
> 这涉及到一个顶层const和底层const的概念：顶层const，本身是const，底层const，指向的对象是const；



##### 顶层const与底层const

指针本身是一个对象，它又可以指向另一个对象，这其实是两个相互独立的问题。这就引出了顶层const与底层const的概念。顶层const意味着指针本身是const，而底层const则表示指针所指向的对象是const。更一般地，**顶层const可以表示任意的对象是常量（包括指针、类、基本数据类型等）**，底层const则与指针或引用的基本类型部分有关。指针既可以是顶层const也可以是底层const，来看下面这个例子：
```c++
int i = 0;
int* const p1 = &i; //指针是顶层const
const int c1 = 42; //顶层const,基本数据类型
const int *p2 = &c1; //底层const
const int* const p3 = p2; //靠右的const是顶层const,靠左的const是底层const
const int& r = c1; //底层const,声明引用的const都是底层const
```

当执行对象的拷贝操作时，常量是顶层const和底层const具有明显的差异。其中顶层const并不会有什么影响：

```c++
 i = c1; //没有问题, c1是顶层const,对此操作无影响
 p2 = p3; //没有问题,p2和p3指向的对象类型相同,p3顶层const的部分不影响
```

执行拷贝操作并不会改变被拷贝对象的值，因此被拷入拷出的对象是否为常量都不影响。**但注意，在拷贝的过程中，拷入和拷出的对象必须具备相同的底层const资格。一般来说，非常量可以转换为常量，而反过来则不行。**来看下面这个例子：

```c++
//int *p = p3; //Error,p3包含底层const的定义,而p则没有
p2 = p3; //没有问题,p2是底层const,而p3也有底层const的定义
p2 = &i; //正确,int* 可以转换为const int*
//int &r = c1; //Error,c1不具备底层const的含义
const int &r2 = i; //可以
```

> 吐槽：C++。。。



#### （c）const成员函数重载问题

- const修饰的函数可以重载。
- const成员函数既不能改变类内的数据成员，也无法调用非const的成员函数；
- const类对象只能调用const成员函数，非const对象无论是否是const成员函数都能调用，**但是如果有重载的非const函数，非const对象会优先调用重载后的非const函数。**

> 这部分剩下的遇到题再整理吧。



### （3）二者联系

[C++ static、const 和 static const 类型成员变量声明以及初始化 | 菜鸟教程](https://www.runoob.com/w3cnote/cpp-static-const.html)

一个结论：

- **`static` 对象**：
  - 存放在静态存储区。
  - 在程序启动时初始化。
    - 注：函数内的 `static` 变量采用了懒汉式初始化（Lazy Initialization），即只有在第一次被访问时才会进行初始化。这种特性使得函数内部的 `static` 变量具有延迟加载的优点。
    - C++11 及以后的标准保证了对函数内 `static` 变量的初始化是线程安全的，即多线程环境下，多个线程不会竞态地初始化同一个 `static` 变量。（游戏开发对多线程暂时是不是不需要了解这么多？有被问到或者复习到了再说吧）
- **`const` 对象**：
  - 可以存放在静态存储区或栈上，具体取决于它的定义上下文。
  - 全局和静态 `const` 对象在程序启动时初始化，局部 `const` 对象在其作用域内初始化。



## 2.new/delete、malloc/free

Q：C++和C分别使用什么函数来做内存的分配和释放？有什么区别，能否混用？

可以参考的链接：[C++中new申请的内存， 可以用free释放吗？_new一个数组用free来释放-CSDN博客](https://blog.csdn.net/Dream_xun/article/details/50347139)

> C使用malloc/free，C++使用new/delete，前者是C语言中的库函数，后者是C++语言的运算符，对于自定义对象，malloc/free只进行分配内存和释放内存，无法调用其构造函数和析构函数，只有new/delete能做到，完成对象的空间分配和初始化，以及对象的销毁和释放空间，**不能混用**，具体区别如下：
>
> （1）new分配内存空间无需指定分配内存大小，malloc需要；
>
> （2）new返回类型指针，类型安全，malloc返回void*，再强制转换成所需要的类型；
>
> （3）new是从自由存储区获得内存，malloc从堆中获取内存；
>
> （4）**对于类对象，new会调用构造函数和析构函数，malloc不会（核心）**。

其他可能的考点：

- C++中的自由存储区：通过new和delete分配和释放空间的内存，具体实现可能是堆或者内存池。
  - 补充：堆是C和操作系统的术语，自由存储区是C++的术语，指的是通过new和delete动态分配和释放对象的抽象概念；基本上C++也会用堆区实现自由存储，但程序员可以通过重载操作符，改用其他内存实现自由存储，比如全局变量做的对象池。
- ==todo:C++ 重载new运算符（能否重载delete？）自由存储区创建的demo，后面整理到其他部分.==



# 二、常见基础问题

## 1.面向对象三大特征

[面向对象的三大基本特征，五大基本原则 - 风之之 - 博客园](https://www.cnblogs.com/fzz9/p/8973315.html)

这里对访问修饰符的复习可以看这里：[C++ 类访问修饰符 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-class-access-modifiers.html)。这个链接中关于继承的访问修饰符有一些说明，可以复习的时候看。

> 这里补充一下关于protected访问修饰符的概念：**protected（受保护）**成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。看下面这个例子理解protected的作用：
> ```c++
> #include <iostream>
> using namespace std;
> 
> class Rectangle
> {
>     protected:
>         double w,h;
>     public:
>         Rectangle(double w, double h): w(w), h(h){}
>         virtual void print()
>         {
>             cout<< " Rectangle "<<endl;
>             cout<<w<< " "<<h<<endl;
>         }
> };
> 
> class Square: Rectangle //注意：默认的是private继承，此时父类的protected变量在子类会降级为private，这样继承自Square的类就无法再访问w和h变量了
> {
> public:
>     // Square 类的构造函数应确保通过 Rectangle 的构造函数初始化宽度和高度。直接赋值w(r),h(r)是错误的,
>     // 因为派生类需要通过调用基类的构造函数来正确地初始化基类部分。只有在基类的构造函数被调用后，基类的成员变量才会被正确地构造。
>     Square(double r): Rectangle(r,r){}
>     virtual void print() override //使用 override 明确表示覆盖基类虚函数
>     {
>         cout<< " Square "<<endl;
>         cout<<w<< " "<<h<<endl;
>     }
> };
> 
> int main()
> {
>     Rectangle r(3.5, 1.5);
>     r.print(); //这么调用是无法找到r的private和protected的变量的,但在类中的代码可以直接访问protected变量,private依旧不可访问
>     Square s(5);
>     s.print();
>     return 0;
> }
> ```

注：类外不能访问private和protected成员。



# 三、重要专题部分

> 由于篇幅限制，这一部分的一些专题会被整理进笔记文件夹的单独md文件中，这里会给出对应的md文档名，方便复习。



## 1.虚函数/虚函数表专题

见`C++虚表相关.md`，在八股文/C++文件夹当中。以下是一些常见题目：

- 什么是多态？C++的多态是如何实现的？
- 虚函数的实现机制是什么？
- 虚函数调用是在编译时确定还是运行时确定的？如何确定调用哪个函数？
- 虚函数是存在类中还是类对象中（即是否共享虚表）？
- **在(基类的)构造函数和析构函数中调用虚函数会怎么样**？
- 子类的构造函数中能调用虚函数么？
- 内联函数可以是虚函数么？
- 析构函数可以是虚函数么？&虚析构函数



## 2.类的存储/C++的内存布局

**Q：c++中类对象的内存模型(布局)是怎么样的？**

答：一般遵循以下几点原则：

（1）如果是有虚函数的话，虚函数表的指针始终存放在内存空间的头部；

（2）除了虚函数之外，内存空间会按照类的[继承顺序](https://zhida.zhihu.com/search?content_id=180938976&content_type=Article&match_order=1&q=继承顺序&zhida_source=entity)(父类到子类)和字段的声明顺序布局；

（3）如果有多继承，每个包含虚函数的父类都会有自己的虚函数表，并且按照继承顺序布局(虚表指针+字段）；如果子类重写父类虚函数，都会在每一个相应的虚函数表中更新相应地址；如果子类有自己的新定义的虚函数或者非虚成员函数，也会加到第一个虚函数表的后面；

（4）如果有钻石继承，并采用了虚继承，则内存空间排列顺序为：各个父类(包含虚表)、子类、公共基类(最上方的父类，包含虚表)，并且各个父类不再拷贝公共基类中的数据成员。

可以参考的链接：[C++对象内存布局解析-CSDN博客](https://blog.csdn.net/u012658346/article/details/50775742)，以及[C++内存模型 - MrYun - 博客园](https://www.cnblogs.com/yunlambert/p/9876491.html)。



下面，我们用几个例子来看看C++的内存布局。首先是最简单的内存对齐问题（我是64位机器）：

```c++
#include <iostream>
using namespace std;

class C1
{
public:
    int a;
    char b;
    long long c; //long long 占8个字节
};

class C2
{
public:
    int a;
    long long c;
    char b;
};

int main()
{
    cout<<sizeof(C1)<<endl; //16
    cout<<sizeof(C2)<<endl; //24
}
```

这里不再详细展开说明了，具体的字节对齐规则主要有如下三点（[C++对象内存布局解析-CSDN博客](https://blog.csdn.net/u012658346/article/details/50775742)这篇里面有例子，介绍的不错）：

1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
2) 结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，eg：char型起始地址能被1整除、short型起始地址能被2整除、int型起始地址能被4整除；
3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍。


当C++中一个对象没有继承自其它任何父类，且没有虚函数时，由于类中定义的方法都在方法区，并不在类所在内存中，因此该类型的大小为：**各字段的大小之和+字节对齐**，与C语言中的结构体的内存占用情况完全相同。



那么，有虚函数的时候会怎么样呢？

> 有虚函数 = sizeof(vfptr)+各字段大小之和+内存对齐
>
> - 当该类型中含有虚函数时，则还要考虑虚函数表指针vfptr的大小；当一个类中定义了虚函数时，根据C++对象模型可知，该类型的对象就会产生一个虚函数表vtbl，所有定义的虚函数都会依次排放在该虚函数表中，同时在对象的起始位置分配一个虚函数指针vfptr指向vtbl。在32位机器上，指针为4字节（64位机器上是8字节），因此当一个类函数虚函数时，它对应的对象所占内存大小为：sizeof(vfptr)+各字段大小之和+内存对齐。

比如说下面这个类：

```c++
class C1
{
public:
    int a;
    char b;
    long long c; //long long 占8个字节
    virtual void hello(){}
}; //24字节，比之前的16字节多了8字节的虚表指针
```



现在，我们的C2继承于C1,此时的`sizeof(C2)`结果是什么呢？

```c++
class C2:public C1
{
public:
    int d;
}; //32 = C2的虚表指针8(vptr) + 8:int4 + char1+ padding3 + 8:longlong8 + 8:int4+padding4 = 32
```

> **也就是说，此时对应下面这两种情况的（2）情况（（1）情况比较简单，就不再举例子了）：**
>
> 1）简单直接继承（父类、子类都没有虚函数）
> 这种情况比较简单，父类、子类都没有虚函数，则都没有虚函数表，子类在内存中各成员变量根据其继承和声明顺序依次放在后面，先父类后子类。则子类大小为：**父类各字段大小之和+子类各字段大小之和+字节对齐**
>
> 2）有虚函数（父类或子类中有虚函数）
> 当父类有虚函数表时，则父类中会有一个vfptr指针指向父类虚函数对应的虚表。当一个子类继承自含有虚函数的父类时，就会继承父类的虚函数，因此子类中也会有vfptr指针指向虚函数表。当子类重写了虚函数时，虚表中对应的虚函数就会被子类重写的函数覆盖。此时子类大小就为：sizeof(vfptr) + 父类各字段大小之和 + 子类各字段大小之和+字节对齐。
>
> **注意：经过测试，如果父类变量都是private并且继承也是private的情况，理论上子类无法访问到父类的private对象，但实际上并不会影响内存布局，实操是这样的。**



接下来，是不建议用但C++提供支持的多继承问题，这里怕考也整理一下（==没有验证，有被考到再说吧==）：

（1）当所有的父类都没有虚函数时，这种情况比较简单，子类所占内存的大小为：**所有父类所有字段之和+子类所有字段之和+字节对齐**

```c++
#include <iostream>
using namespace std;

class C1 {
    int a;
    char b;
    long long c; //long long 占8个字节
};

class C2 {
    int d;
    char e;
};

class C: public C1, public C2 {
    int f;
};

int main()
{
    cout<<sizeof(C1)<<endl; //16
    cout<<sizeof(C2)<<endl; //8
    cout<<sizeof(C)<<endl; //32
}
```

（2）父类有虚函数：当一个父类有虚函数时，表明那个父类存在虚函数表，因此在那个父类的结构中会包含一个虚函数指针vfptr。**而当多个父类中定义了虚函数时，则那些父类中都会包含一个vfptr，并且有虚函数的父类会在没有虚函数父类的前面。当子类重写了那些虚函数时，就会在第一个定义了该虚函数的父类的虚函数表中覆盖父类定义的虚函数，当子类增加了新的虚函数时，也会将新增的虚函数增加至那个虚函数表中。**

这个看[C++对象内存布局解析-CSDN博客](https://blog.csdn.net/u012658346/article/details/50775742)这篇文章最下面即可。

> 多继承+虚函数还有一些疑问，但先不管了，再研究就钻牛角尖了。



# 四、STL专题（单独拿出来）

> 这里面的题也是比较多，而且水也比较深，所以单独拿出来。前面几个小节是对单独的STL容器的总结，后面则是一些整体上的和算法上的总结。

## 1.vector



## 2.map&unordered_map



# 杂项

## 1.C++ 编译器调试时看到的地址是物理地址还是逻辑地址?

是**逻辑地址**。这里就需要我们复习一下物理地址和逻辑地址的区别：

> ### 1. 逻辑地址（虚拟地址）
>
> - **定义**：逻辑地址是程序中使用的地址，由编程语言和操作系统提供给应用程序。这些地址是相对于进程的地址空间而言的。
> - 特性：
>   - 每个进程都有自己的逻辑地址空间，**因此同一地址在不同进程中可以指向不同的物理内存位置**。
>   - 操作系统通过内存管理单元（MMU）将逻辑地址转换为物理地址。
>
> ### 2. 物理地址
>
> - **定义**：物理地址是实际存在于计算机硬件（RAM）中的地址。
> - 特性：
>   - 物理地址直接对应于内存芯片上的具体位置。
>   - 程序无法直接访问或看到物理地址，除非在一些特权模式下（例如操作系统内核）。
>
> ### 调试过程中的地址
>
> - 当你在调试器中查看变量、函数或数据结构的地址时，你看到的是逻辑地址。这是因为大多数现代操作系统都采用了虚拟内存技术，允许每个进程在自己的逻辑地址空间中运行，从而避免了不同进程之间的内存冲突。操作系统会负责将这个逻辑地址映射到物理内存中某个物理地址，但这个映射过程对用户和程序员是透明的。



# 总参考链接：

【1】[【游戏开发面经汇总】- 计算机基础篇 - 知乎](https://zhuanlan.zhihu.com/p/417640759)


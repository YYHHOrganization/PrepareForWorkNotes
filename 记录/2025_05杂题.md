# 2025年5月杂题记录

> 注：杂题主要指的是每日一题（懒得分类了），以及一些不好归类的题（比如部分思维题和模拟题）



## [838. 推多米诺](https://leetcode.cn/problems/push-dominoes/)

> `n` 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。
>
> 每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
>
> 如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。
>
> 就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。
>
> 给你一个字符串 `dominoes` 表示这一行多米诺骨牌的初始状态，其中：
>
> - `dominoes[i] = 'L'`，表示第 `i` 张多米诺骨牌被推向左侧，
> - `dominoes[i] = 'R'`，表示第 `i` 张多米诺骨牌被推向右侧，
> - `dominoes[i] = '.'`，表示没有推动第 `i` 张多米诺骨牌。
>
> 返回表示最终状态的字符串。
>
>  
>
> **示例 1：**
>
> ```
> 输入：dominoes = "RR.L"
> 输出："RR.L"
> 解释：第一张多米诺骨牌没有给第二张施加额外的力。
> ```
>
> **示例 2：**
>
> ![img](assets/domino.png)
>
> ```
> 输入：dominoes = ".L.R...LR..L.."
> 输出："LL.RR.LLRRLL.."
> ```
>
>  
>
> **提示：**
>
> - `n == dominoes.length`
> - `1 <= n <= 105`
> - `dominoes[i]` 为 `'L'`、`'R'` 或 `'.'`

### （1）我的方法

这道题核心在于如下的观察（本题使用栈的数据结构，也可以不用栈，用普通的vector即可）：

- 看到中间有（R,L）的对，则对应R到L中间做多米诺的模拟，模拟完视为无效值；
- 剩下的R和L分别模拟，看到R就往右走，直到不是.为止；看到L就往左走，直到不是.为止。因为栈中的元素在pop的过程中对应的索引位一定是从后到前的，所以不会有问题。



```c++
class Solution {
public:
    string pushDominoes(string dominoes) {
        //用栈,找中间的(R,L)
        stack<pair<char, int>> stk; //存储L/R以及索引
        int n = dominoes.size();
        for(int i=0;i<n;i++)
        {
            if(dominoes[i]=='R') stk.push({'R', i});
            else if(dominoes[i]=='L')
            {
                if(!stk.empty() && stk.top().first=='R')
                {
                    int l = stk.top().second;
                    int r = i;
                    while(l<r)
                    {
                        dominoes[l]='R';
                        dominoes[r]='L';
                        l++, r--;
                    }
                    stk.top().second = -1;
                    stk.push({'L', -1});
                }
                else stk.push({'L', i});
            }
        }
        //剩下的一定是LLL..RRR,或者LLLLLL, RRRRRR这种
        //每pop一个R出来,都往右走到第一个不是.的
        while(!stk.empty())
        {
            auto [c, index] = stk.top();
            //cout<<c<<" "<<index<<endl;
            stk.pop();
            if(c=='R'&&index!=-1)
            {
                int start = index+1;
                while(start<n && dominoes[start]=='.')
                {
                    dominoes[start] = 'R';
                    start++;
                }
            }
            else if(c=='L'&&index!=-1)
            {
                int start = index-1;
                while(start>=0 && dominoes[start]=='.')
                {
                    dominoes[start] = 'L';
                    start--;
                }
            }
        }
        return dominoes;
    }
};
```



### （2）其他题解

可以参考这篇题解：[838. 推多米诺 - 力扣（LeetCode）](https://leetcode.cn/problems/push-dominoes/solutions/3667176/fen-lei-tao-lun-jian-ji-xie-fa-pythonjav-bztd/?envType=daily-question&envId=2025-05-02)。其实相当于两个两个处理关键字L和R，分为四种情况讨论：

根据题意，有四种情况：

- L...L：中间的点全部变成 L。
- R...R：中间的点全部变成 R。
- R...L：前一半的点全部变成 R，后一半的点全部变成 L。特别地，如果有奇数个点，则正中间的点不变。
- L...R：不变。

处理两个的逻辑在于记录一个pre和当前的i，做完fill操作后，更新pre=i，然后继续往后走。

代码如下:
```c++
class Solution {
public:
    string pushDominoes(string dominoes) {
       //R....R,或者L...L,中间全部变为R或者L
       //R...L,双指针fill成 RR.LL
       //L...R,不用处理
       //可以添加两个哨兵,方便处理,左边加一个L,右边加一个R
       string s = "L" + dominoes + "R";
       int pre = 0; //记录上一次的L或者R的下标
       int n = s.size();
       for(int i=1;i<n;i++) //注意这里是从1开始,从0开始会报错
       {
            if(s[i]=='.') continue; //不用处理
            if(s[i]==s[pre]) //中间都是L或者都是R,跟s[i]一样
            {
                fill(s.begin()+pre+1, s.begin()+i, s[i]);
            }
            else if(s[i]=='L') //说明是R...L
            {
                int l = pre+1;
                int r = i-1;
                while(l<r)
                {
                    s[l]='R';
                    s[r]='L';
                    l++, r--;
                }
            }
            //说明是L...R,不用处理
            pre = i;
       } 
       return s.substr(1, n-2);
    }
};
```


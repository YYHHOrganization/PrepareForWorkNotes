

4/21

### [2145. 统计隐藏数组数目](https://leetcode.cn/problems/count-the-hidden-sequences/)

![image-20250421193312595](assets/image-20250421193312595.png)

**示例 1：**

```
输入：differences = [1,-3,4], lower = 1, upper = 6
输出：2
解释：符合要求的隐藏数组为：
- [3, 4, 1, 5]
- [4, 5, 2, 6]
所以返回 2 。
```



```C++
class Solution {
public:
    int numberOfArrays(vector<int>& differences, int lower, int upper) {
        //  1 -3 4 相邻元素的插值
        // lower  upper
        // [1,6]
        long long mn=0,mx=0;
        int n = differences.size();
        long long tmp=0;
        for(int i=0;i<n;i++)
        {
            tmp+=differences[i]; 
            mn = min(mn,tmp);
            mx = max(mx,tmp);
        }
        long long len = mx-mn;
        if(len>upper-lower)return 0;
        return upper - (lower+len)+1;
    }
};
```



### [1457. 二叉树中的伪回文路径](https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/)

给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「**伪回文**」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。

请你返回从根到叶子节点的所有路径中 **伪回文** 路径的数目。

**示例 1：**

![img](assets/palindromic_paths_1.png)

```
输入：root = [2,3,1,3,1,null,1]
输出：2 
解释：上图为给定的二叉树。总共有 3 条从根到叶子的路径：红色路径 [2,3,3] ，绿色路径 [2,1,1] 和路径 [2,3,1] 。
     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [2,3,3] 存在回文排列 [3,2,3] ，绿色路径 [2,1,1] 存在回文排列 [1,2,1] 。
```

------

相关标签

[位运算](https://leetcode.cn/tag/bit-manipulation/)[树](https://leetcode.cn/tag/tree/)[深度优先搜索](https://leetcode.cn/tag/depth-first-search/)[广度优先搜索](https://leetcode.cn/tag/breadth-first-search/)[二叉树](https://leetcode.cn/tag/binary-tree/)

优化1：位运算

```C++
class Solution {
public:
    int dfs(TreeNode* node,int path)
    {
        if(node==nullptr)return 0;
        int val = node->val;
        path = path ^ (1<<val);
        if(node->left==nullptr&&node->right==nullptr)
        {
            //叶子节点
            int cnt1 = __builtin_popcount(path);
            if(cnt1<=1)return 1;
            else return 0;
        }
        int left = dfs(node->left,path);
        int right = dfs(node->right,path);
        return left+right;
    }
    int pseudoPalindromicPaths (TreeNode* root) {
        //回文：aa，aab,aabb,aaccffd
        //每个字母出现次数都需要是偶数，只有一个可以是奇数
        // 数位 26位，当有这个值，异或 ，这样如果最后是0，或者只有1个1，就可以
        //从根节点传递到叶子节点，叶子节点来判断
        //2^9
        return dfs(root,0);
    }
};
```

优化2：

实际上我们因为只有1个1，所以只需要`return (path&(path-1))==0;`

```C++
class Solution {
public:
    int dfs(TreeNode* node,int path)
    {
        if(node==nullptr)return 0;
        int val = node->val;
        path = path ^ (1<<val);
        if(node->left==nullptr&&node->right==nullptr)
        {
            //叶子节点
            return (path&(path-1))==0;
        }
        return dfs(node->left,path)+dfs(node->right,path);
    }
    int pseudoPalindromicPaths (TreeNode* root) {
        return dfs(root,0);
    }
};
```







### [2734. 执行子串操作后的字典序最小字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/)

给你一个仅由小写英文字母组成的字符串 `s` 。在一步操作中，你可以完成以下行为：

- 选择 `s` 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。

返回执行上述操作 **恰好一次** 后可以获得的 **字典序最小** 的字符串。

**子字符串** 是字符串中的一个连续字符序列。

现有长度相同的两个字符串 `x` 和 字符串 `y` ，在满足 `x[i] != y[i]` 的第一个位置 `i` 上，如果 `x[i]` 在字母表中先于 `y[i]` 出现，则认为字符串 `x` 比字符串 `y` **字典序更小** 。

**示例 1：**

```
输入：s = "cbabc"
输出："baabc"
解释：我们选择从下标 0 开始、到下标 1 结束的子字符串执行操作。 
可以证明最终得到的字符串是字典序最小的。
```



写法1:

```C++
class Solution {
public:
    string smallestString(string s) {
        //换前面的字符
        //a跳过
        //从非a到非a
        //如果全是a 就最后一个a换为z
        int n = s.size();
        for(int i=0;i<n;i++)
        {
            if(s[i]!='a')
            {
                for(;i<n&&s[i]!='a';i++)
                {
                    s[i] = s[i]-1;
                }
                return s;
            }
        }
        s[n-1] = 'z';
        return s;
    }
};
```

写法2:

```C++
class Solution {
public:
    string smallestString(string s) {
        //换前面的字符
        //a跳过
        //从非a到非a
        //如果全是a 就最后一个a换为z
        int n = s.size();
        bool start=false;
        bool hasChange=false;
        for(int i=0;i<n;i++)
        {
            if(!start)
            {
                if(s[i]!='a')
                {
                    start=true;
                    hasChange = true;
                    s[i] = s[i]-1;
                }
            }
            else if(start)
            {
                if(s[i]!='a')
                {
                    s[i] = s[i]-1;
                }
                else if(s[i]=='a')
                {
                    start = false;
                    break;
                }
            }
        }
        if(hasChange==false)
        {
            s[n-1] = 'z';
        }
        return s;
    }
};
```



### [1410. HTML 实体解析器](https://leetcode.cn/problems/html-entity-parser/)

「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。

HTML 里这些特殊字符和它们对应的字符实体包括：

- **双引号：**字符实体为 `"` ，对应的字符是 `"` 。
- **单引号：**字符实体为 `'` ，对应的字符是 `'` 。
- **与符号：**字符实体为 `&` ，对应对的字符是 `&` 。
- **大于号：**字符实体为 `>` ，对应的字符是 `>` 。
- **小于号：**字符实体为 `<` ，对应的字符是 `<` 。
- **斜线号：**字符实体为 `⁄` ，对应的字符是 `/` 。

给你输入字符串 `text` ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。

**示例 1：**

```
输入：text = "&amp; is an HTML entity but &ambassador; is not."
输出："& is an HTML entity but &ambassador; is not."
解释：解析器把字符实体 &amp; 用 & 替换
```



```C++
class Solution {
public:
    string entityParser(string s) {
        int n=s.size();
        //找到& 往后从3位找到（最多找6位）看有没有“；”
        //找到了就比较一下是否等于其中哪个字符
        //如果== 就替换，否则不管
        //&frasl;
        //0123456
        //i
        string res; 
        unordered_map<string,char> umap;
        umap["quot"] = '\"';
        umap["apos"] = '\'';
        umap["amp"] = '&';
        umap["gt"] = '>';
        umap["lt"] = '<';
        umap["frasl"] = '/';
        for(int i=0;i<n;i++)
        {
            if(s[i]=='&')
            {
                for(int j=i+3;j<=i+6&&j<n;j++)
                {
                    if(s[j]==';')
                    {
                        string str = s.substr(i+1,j-i-1);
                        if(umap.contains(str))
                        {
                            res.push_back(umap[str]);
                            i=j+1;
                            continue;
                        }
                    }
                }
            }
            if(i<n)res.push_back(s[i]);
        }
        return res;
    }
};
```

别的语言都可以直接用replace函数，C++应该也有吧，有空看看



### [2437. 有效时间的数目](https://leetcode.cn/problems/number-of-valid-clock-times/)

给你一个长度为 `5` 的字符串 `time` ，表示一个电子时钟当前的时间，格式为 `"hh:mm"` 。**最早** 可能的时间是 `"00:00"` ，**最晚** 可能的时间是 `"23:59"` 。

在字符串 `time` 中，被字符 `?` 替换掉的数位是 **未知的** ，被替换的数字可能是 `0` 到 `9` 中的任何一个。

请你返回一个整数 `answer` ，将每一个 `?` 都用 `0` 到 `9` 中一个数字替换后，可以得到的有效时间的数目。

**示例 1：**

```
输入：time = "?5:00"
输出：2
解释：我们可以将 ? 替换成 0 或 1 ，得到 "05:00" 或者 "15:00" 。注意我们不能替换成 2 ，因为时间 "25:00" 是无效时间。所以我们有两个选择。
```



```C++
class Solution {
public:
    int countTime(string time) {
        //"?5:00"
        //1234位
        //12:??,24
        //1?:a?,if(a<2)b=0-9;
        //      else a==2,b=0-3 
        //?2:?b,b>=4 a=0-1
        //      else a=0-2
        
        //a? ,  b 0-9
        //?b ,  b 0-5

        int h=1;
        char a = time[0],b=time[1];
        if(a=='?'&&b=='?')h = 24;
        else if(b=='?')  
        {
            if(a-'0'<2) h=10;
            else h=4;
        }
        else if(a=='?')
        {
            if(b-'0'>=4)h=2;
            else h=3;
        }

        int m=1;
        a = time[3],b=time[4];
        if(a=='?'&&b=='?')m=60;
        else if(b=='?')m=10;
        else if(a=='?')m=6;

        return m*h;
    }
};
```



或者枚举每个时间，看是否合法(0X3F)：

```C++
class Solution {
    int count(string t, int period) {
        int ans = 0;
        for (int i = 0; i < period; i++)
            if ((t[0] == '?' || i / 10 == t[0] - '0') &&
                (t[1] == '?' || i % 10 == t[1] - '0'))
                ans++;
        return ans;
    }
public:
    int countTime(string time) {
        return count(time.substr(0, 2), 24) * count(time.substr(3), 60);
    }
};
作者：灵茶山艾府
链接：https://leetcode.cn/problems/number-of-valid-clock-times/solutions/1895227/cheng-fa-yuan-li-fen-bie-ji-suan-xiao-sh-66d9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### [2678. 老人的数目](https://leetcode.cn/problems/number-of-senior-citizens/)

给你一个下标从 **0** 开始的字符串 `details` 。`details` 中每个元素都是一位乘客的信息，信息用长度为 `15` 的字符串表示，表示方式如下：

- 前十个字符是乘客的手机号码。
- 接下来的一个字符是乘客的性别。
- 接下来两个字符是乘客的年龄。
- 最后两个字符是乘客的座位号。

请你返回乘客中年龄 **严格大于 60 岁** 的人数。

 

**示例 1：**

```
输入：details = ["7868190130M7522","5303914400F9211","9273338290F4010"]
输出：2
解释：下标为 0 ，1 和 2 的乘客年龄分别为 75 ，92 和 40 。所以有 2 人年龄大于 60 岁。
```



```C++
class Solution {
public:
    int countSeniors(vector<string>& details) {
        // d[i][11],d[i][12]
        int cnt=0;
        for(int i=0;i<(int)details.size();i++)
        {
            //记得 是字符串 需要-'0'
            if(details[i][11]-'0'>6 ||((details[i][11]-'0'==6)&&details[i][12]-'0'>0))
            {
                cnt++;
            }
        }
        return cnt;
    }
};
```



### [2679. 矩阵中的和](https://leetcode.cn/problems/sum-in-a-matrix/)

给你一个下标从 **0** 开始的二维整数数组 `nums` 。一开始你的分数为 `0` 。你需要执行以下操作直到矩阵变为空：

1. 矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。
2. 在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 **分数** 中。

请你返回最后的 **分数** 。

**示例 1：**

```
输入：nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]
输出：15
解释：第一步操作中，我们删除 7 ，6 ，6 和 3 ，将分数增加 7 。下一步操作中，删除 2 ，4 ，5 和 2 ，将分数增加 5 。最后删除 1 ，2 ，3 和 1 ，将分数增加 3 。所以总得分为 7 + 5 + 3 = 15 。
```



```C++
class Solution {
public:
    int matrixSum(vector<vector<int>>& nums) {
        // sort 
        int n = nums.size();
        for(int i=0;i<n;i++)
        {
             sort(nums[i].begin(),nums[i].end());   
        }
        // 1 2 7
        // 2 4 6
        // nums[i][m-1]
        int m = nums[0].size();
        int maxNum=INT_MIN;
        int res=0;
        for(int j=m-1;j>=0;j--)
        {
            maxNum=INT_MIN;
            for(int i=0;i<n;i++)
            {
                maxNum = max(maxNum,nums[i][j]);
            }
            res+=maxNum;
        }
        return res;
    }
};
```



### [2680. 最大或值](https://leetcode.cn/problems/maximum-or/)

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `k` 。每一次操作中，你可以选择一个数并将它乘 `2` 。

你最多可以进行 `k` 次操作，请你返回 `nums[0] | nums[1] | ... | nums[n - 1]` 的最大值。

`a | b` 表示两个整数 `a` 和 `b` 的 **按位或** 运算。

**示例 1：**

```
输入：nums = [12,9], k = 1
输出：30
解释：如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。
```



```C++
class Solution {
public:
    long long maximumOr(vector<int>& nums, int k) {
        // 乘最长的那些数字是最好的
        //枚举所有最长的数字。对其进行k次*2 / <<
        int n=nums.size();
        //前后缀异或
        // 8  1 2
        // 0  8 8^2
        //1^2 2 0

        // 0011
        // 0001
        vector<long long> suf(n,0);
        for(int i=n-2;i>=0;i--)
        {
            suf[i] = suf[i+1]|nums[i+1];
        }
        long long pre=0;
        long long res=0;
        for(int i=0;i<n;i++)
        {
            long long tmp = pre | ((long long)nums[i]<<k) |  suf[i];
            pre = pre |  nums[i];
            res = max(res,tmp);
        }
        return res;
    }
};
```



### [2681. 英雄的力量](https://leetcode.cn/problems/power-of-heroes/) 困难题

给你一个下标从 **0** 开始的整数数组 `nums` ，它表示英雄的能力值。如果我们选出一部分英雄，这组英雄的 **力量** 定义为：

- `i0` ，`i1` ，... `ik` 表示这组英雄在数组中的下标。那么这组英雄的力量为 `max(nums[i0],nums[i1] ... nums[ik])^2 * min(nums[i0],nums[i1] ... nums[ik])` 。

请你返回所有可能的 **非空** 英雄组的 **力量** 之和。由于答案可能非常大，请你将结果对 `109 + 7` **取余。**

**示例 1：**

```
输入：nums = [2,1,4]
输出：141
解释：
第 1 组：[2] 的力量为 22 * 2 = 8 。
第 2 组：[1] 的力量为 12 * 1 = 1 。
第 3 组：[4] 的力量为 42 * 4 = 64 。
第 4 组：[2,1] 的力量为 22 * 1 = 4 。
第 5 组：[2,4] 的力量为 42 * 2 = 32 。
第 6 组：[1,4] 的力量为 42 * 1 = 16 。
第 7 组：[2,1,4] 的力量为 42 * 1 = 16 。
所有英雄组的力量之和为 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141 。
```



贡献法：

请看题解：

**https://leetcode.cn/problems/power-of-heroes/solutions/2268792/gong-xian-fa-pythonjavacgo-by-endlessche-d4jx/**

```C++
class Solution {
public:
    int sumOfPower(vector<int>& nums) {
        // 贡献法
        // 1 2 4 7 9
        // 9*9 *1 情况有 /2^3  选或者不选
        // 9*9 *2 情况有 /2^2  选或者不选
        // 9*9 *4  /2^1
        // 9*9 *7  /2^0=1
        // 9*9 *9  /1
        // res += (x*x*(x+s));
        // s = 2*s+nums[i]
        //每个数字作为最大值的贡献
        sort(nums.begin(),nums.end());
        int n = nums.size();
        const int MOD =1e9+7;
        long long res=0;
        long long s=0;
        for(long long x:nums)
        {
            res = (res + x*x%MOD*(x+s)) %MOD;
            s = (2*s + x) %MOD;
        }
        return res;
        
    }
};
```





### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

![image-20250423201346432](assets/image-20250423201346432.png)

```C++
class MyQueue {
public:
    //操作  加 1 2 3-- pop          --pop
    // stkIn  1 2 3--empty-- empty  -- 4 5 
    // stkOut empty--3 2 1-- 3 2    --3   

    stack<int> stkIn;
    stack<int> stkOut;
    MyQueue() {
        
    }
    
    void push(int x) {
        stkIn.emplace(x);
    }
    
    int pop() {
        if(!stkOut.empty())
        {
            int tmp = stkOut.top();
            stkOut.pop();
            return tmp;
        }
        while(!stkIn.empty())
        {
            int tmp = stkIn.top();
            stkIn.pop();
            stkOut.emplace(tmp);
        }
        if(!stkOut.empty())
        {
            int tmp = stkOut.top();
            stkOut.pop();
            return tmp;
        }
        return -1;
    }
    
    int peek() {
        if(!stkOut.empty())
        {
            int tmp = stkOut.top();
            return tmp;
        }
        while(!stkIn.empty())
        {
            int tmp = stkIn.top();
            stkIn.pop();
            stkOut.emplace(tmp);
        }
        if(!stkOut.empty())
        {
            int tmp = stkOut.top();
            return tmp;
        }
        return -1;
    }
    
    bool empty() {
        return stkIn.empty()&&stkOut.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

简洁点：

```C++
class MyQueue {
private:
    std::stack<int> A, B;

public:
    MyQueue() {}

    void push(int x) {
        A.push(x);
    }

    int pop() {
        int peek = this->peek();
        B.pop();
        return peek;
    }

    int peek() {
        if (!B.empty()) return B.top();
        if (A.empty()) return -1;
        while (!A.empty()){
            B.push(A.top()), A.pop();
        }
        int res = B.top();
        return res;
    }

    bool empty() {
        return A.empty() && B.empty();
    }
};

链接：https://leetcode.cn/problems/implement-queue-using-stacks/solutions/2363977/232-yong-zhan-shi-xian-dui-lie-qing-xi-t-pi4l/
```



### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

**注意：**

- 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。



记住，是push的时候做的操作。

#### M1: 两个队列

<img src="assets/1449aaa9ab98595aee4c16f030677765.png" alt="1449aaa9ab98595aee4c16f030677765" style="zoom: 33%;" />

```C++
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;
    MyStack() {
        
    }
    
    void push(int x) {
        que2.push(x);
        while(!que1.empty())
        {
            que2.push(que1.front());
            que1.pop();
        }
        swap(que1,que2);
    }
    
    int pop() {
        if(que1.empty())return -1;
        int tmp = que1.front();
        que1.pop();
        return tmp;
    }
    
    int top() {
        if(que1.empty())return -1;
        return que1.front();
    }
    
    bool empty() {
        return que1.empty();
    }
};
```



#### M2: 一个队列

```C++
class MyStack {
public:
    queue<int> que;
    MyStack() {
        
    }
    
    void push(int x) {
        int n = que.size();
        que.push(x);
        while(n>0)
        {
            que.push(que.front());
            que.pop();
            n--;
        }
    }
    
    int pop() {
        if(que.empty())return -1;
        int tmp = que.front();
        que.pop();
        return tmp;
    }
    
    int top() {
        if(que.empty())return -1;
        return que.front();
    }
    
    bool empty() {
        return que.empty();
    }
};
```



### 【4/23 每日一题】[1399. 统计最大组的数目](https://leetcode.cn/problems/count-largest-group/)

给你一个整数 `n` 。请你先求出从 `1` 到 `n` 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。

请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。

**示例 1：**

```
输入：n = 13
输出：4
解释：总共有 9 个组，将 1 到 13 按数位求和后这些组分别是：
[1,10]，[2,11]，[3,12]，[4,13]，[5]，[6]，[7]，[8]，[9]。总共有 4 个组拥有的数字并列最多。
```



#### M1：暴力枚举

```C++
class Solution {
public:
    int countLargestGroup(int n) {
        // 1-n
        // 1-1 2-2.....10-1 11-2
        // 10000
        // 9999
        //36
        vector<int> v(37,0);
        int maxNum=0;
        for(int i=1;i<=n;i++)
        {
            int a = i;
            int sum=0;
            while(a)
            {
                sum += a%10;
                a/=10;
            }
            v[sum]++;
            maxNum = max(maxNum,v[sum]);
        }
        int res=0;
        for(int i=0;i<37;i++)
        {
            if(v[i]==maxNum)
            {
                res++;
            }
        }
        return res;
    }
};
```



#### M2 ：数位DP

```C++
class Solution {
public:
    int countLargestGroup(int n) {
        // 1-n
        // 1-1 2-2.....10-1 11-2
        // 10000
        // 9999
        //36
        // dp digitSum 
        // n=4567
        // 1-36
        // 34** 与下面可以记忆化，能构成的某种digitSum的情况是一样的，能构成digitSum = 30的个数
        // 16**
        // 45** 与下面不能记忆化
        // 09**
        //digitSum = k
        //有多少个
        
        //i,sum
        
        string s = to_string(n);
        int m = s.size();
        vector<vector<int>> dp(m,vector<int>(m*9+1,-1));
        // n=4567
        auto dfs = [&](this auto &&dfs,int i,int sum,bool is_limit)->int
        {
            if(i==m)return (sum==0);
            if(!is_limit&&dp[i][sum]!=-1)return dp[i][sum]; 
            int up = is_limit?s[i]-'0':9;
            int res=0;
            //sum-d>=0,d<=sum ！！
            for(int d=0;d<=min(up,sum);d++) // ！！别忘了 min(up,sum)
            {
                res += dfs(i+1,sum-d,is_limit&&d==up);  
            }
            if(!is_limit)dp[i][sum] = res;
            return res;
        };
        vector<int> Num(37,0);
        int maxNum=0;
        for(int i=1;i<m*9+1;i++)
        {
            Num[i] = dfs(0,i,true);
            maxNum = max(Num[i],maxNum);
        }
        int res=0;

        for(int i=1;i<m*9+1;i++)
        {
            if(Num[i] == maxNum) res++;
        }
        return res;
    }
};
```


# C++ set unordered_set

https://blog.csdn.net/yas12345678/article/details/52601454

**insert**

**erase(iterator) ,删除定位器iterator指向的值**

**erase(first,second),删除定位器first和second之间的值**

**erase(key_value),删除键值key_value的值**



**（1）为何map和set的插入删除效率比用其他序列容器高？**

大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：

 

　　A
　 / \
　 B C
　/ \ / \
 D E F G

因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。



**（2）为何每次insert之后，以前保存的iterator不会失效？**

iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。



##  unordered_set

### 1. **`insert` 的迭代器影响**：可能不失效

- **插入不会导致迭代器失效**，**除非触发重哈希**（例如插入元素后，容器的负载因子超过阈值，导致内部重新分配存储空间）。
- 如果未发生重哈希，所有现有迭代器（包括 `end()`）保持有效。
- 如果发生重哈希，**所有迭代器都会失效**，但元素本身的引用（指针）仍然有效。



### 2. **`erase` 的迭代器影响**：失效

- **被删除元素的迭代器会立即失效**。
- 其他未删除元素的迭代器是否失效**取决于具体实现**，但标准不保证它们有效。因此，**必须假设在 `erase` 后其他迭代器可能失效**。
# Leetcode——位运算（基础/性质/拆位/试填/恒等式/思维）

推荐先阅读：[从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)

## 一、基础题

### [3370. 仅含置位位的最小整数](https://leetcode.cn/problems/smallest-number-with-all-set-bits/) 1199

给你一个正整数 `n`。

返回 **大于等于** `n` 且二进制表示仅包含 **置位** 位的 **最小** 整数 `x` 。

**置位** 位指的是二进制表示中值为 `1` 的位。

**示例 1：**

**输入：** n = 5

**输出：** 7

**解释：**

7 的二进制表示是 `"111"`。



#### 法1：

```C++
class Solution {
public:
    int smallestNumber(int n) 
    {
        //101
        //111

        //1010
        //1111
        //寻找>这个数字的二进制，-1就是了

        //取出n第一位是k位，这个1<<(k+1)-1;
        int k=0;
        while(n)
        {
            k++;
            n=n>>1;
        }
        return (1<<(k))-1;

    }
};
```

#### 法2： O(1)

![image-20250228175115378](assets/image-20250228175115378.png)

```C++
class Solution {
public:
    int smallestNumber(int n) 
    {
        return (1<<(bit_width((unsigned)n)))-1;
    }
};
```

或者__lg  

```C++
        return (1<<(__lg(n)+1))-1;
```

或者 log2  

```C++
return (1<<  ((int)log2(n)+1) )   -1;
```

>        //1010 。log2n = 3
>        //1111 .1<<(3+1)-1
>        //寻找>这个数字的二进制，-1就是了



deepseek关于这三个函数的说法：（未校准 不知道对不对）

>在 C++ 中，`log2`、`__lg()` 和 `bit_width` 的实现涉及不同层次的优化和硬件特性，以下是它们的典型实现方式：
>
>---
>
>### 1. **数学函数 `std::log2`**
>**作用**：计算浮点数的以 2 为底的对数。
>
>#### 实现方式：
>- **硬件指令**：现代 CPU 可能直接提供 `FYL2X`（x86）或类似指令计算对数，编译器会生成相关指令。
>- **软件近似**：若无硬件支持，数学库（如 glibc 或 Intel MKL）会使用多项式逼近或查表法：
>  1. 将浮点数 `x` 分解为指数 `e` 和尾数 `m`（IEEE 754 格式）：`x = 2^e * (1 + m)`。
>  2. 计算 `log2(x) = e + log2(1 + m)`，其中 `log2(1 + m)` 用多项式（如泰勒展开）近似。
>- **边界处理**：需处理负数、0、NaN 和无穷大，例如 `log2(0)` 返回 `-inf`。
>
>---
>
>### 2. **编译器内置函数 `__lg()`**
>**作用**：快速计算整数 `n` 的最高有效位位置（即 `floor(log2(n))`）。
>
>#### 实现方式：
>- **硬件指令**：
>  - x86 使用 `BSR`（Bit Scan Reverse）指令直接获取最高位位置。
>  - ARM 使用 `CLZ`（Count Leading Zeros）指令，结果转换为 `31 - CLZ(n)`。
>- **软件回退**（无指令支持时）：
>  ```cpp
>  int __lg(uint32_t n) {
>    if (n == 0) return -1; // 未定义行为通常要求 n > 0
>    int pos = 0;
>    while (n >>= 1) pos++;
>    return pos;
>  }
>  ```
>- **优化技巧**：二分查找或分块判断（如先判断高 16 位是否有 1）。
>
>---
>
>### 3. **C++20 标准函数 `std::bit_width`**
>**作用**：返回表示无符号整数所需的最小位数（例如 `0b10011` 需要 5 位）。
>
>#### 实现方式：
>- **直接关联**：对于非零数，`bit_width(n) = __lg(n) + 1`。
>- **零值处理**：若 `n = 0`，返回 0。
>- **编译器优化**：
>  ```cpp
>  int bit_width(uint32_t n) {
>    return (n == 0) ? 0 : (32 - __builtin_clz(n));
>  }
>  ```
>  其中 `__builtin_clz` 计算前导零数目（例如 `0b0010` 的 `CLZ` 为 30，`32-30=2`）。
>
>---
>
>### **关键差异与总结**
>| 函数        | 输入类型   | 目的                             | 底层依赖                 |
>| ----------- | ---------- | -------------------------------- | ------------------------ |
>| `std::log2` | 浮点数     | 精确计算以2为底的对数            | 硬件指令或数学库近似     |
>| `__lg()`    | 整数       | 快速获取最高位位置（log2下取整） | BSR/CLZ 指令或位操作循环 |
>| `bit_width` | 无符号整数 | 最小表示位数（log2上取整+1）     | `__lg()` 或 CLZ 指令变换 |
>
>实际实现因编译器和平台而异，例如：
>- GCC/Clang 的 `__lg(x)` 直接映射为 `31 - __builtin_clz(x)`。
>- MSVC 可能用 `_BitScanReverse` 实现类似逻辑。

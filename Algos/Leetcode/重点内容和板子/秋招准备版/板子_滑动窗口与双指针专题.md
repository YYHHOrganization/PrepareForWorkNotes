# 板子——滑动窗口与双指针专题

# 一、定长滑动窗口

【板子题】[1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/)

> 给你一个整数数组 `arr` 和两个整数 `k` 和 `threshold` 。
>
> 请你返回长度为 `k` 且平均值大于等于 `threshold` 的子数组数目。

```c++
class Solution {
public:
    int numOfSubarrays(vector<int>& arr, int k, int threshold) {
        int n=arr.size();
        int res=0;
        int sum=0;
        int thresholdSum = threshold*k;
        for(int i=0;i<n;i++)
        {
            //1、inset
            sum+=arr[i];//假设k是3个 inset步骤 从2加到3
            if(i<k-1)continue;//判断下标是否小于2(是否小于3个元素) 是的话就continue
            //2、update
            if(sum>=thresholdSum)res+=1;//判断一下总的sum,因为现在是3个元素
            //3、delete
            sum-=arr[i-k+1];//扣掉一个元素 回到2个元素
        }
        return res;
    }
};
```

重点是下面这段：
```c++
for(int i=0;i<n;i++)
{
    //1、inset
    sum+=arr[i];//假设k是3个 inset步骤 从2加到3
    if(i<k-1)continue;//判断下标是否小于2(是否小于3个元素) 是的话就continue
    //2、update
    if(sum>=thresholdSum)res+=1;//判断一下总的sum,因为现在是3个元素
    //3、delete
    sum-=arr[i-k+1];//扣掉一个元素 回到2个元素
}
```

以下整理一些比较值得注意的题目，和对应的思路。



## 1.重点题目和思路

### （1）爱生气的书店老板

> 抽象版：数组中有一些正数，同时有一个mask数组（由0，1组成，1表示选，0表示不选），你可以将mask数组连续k个数改成1（有一次机会，意味着将长度为k的窗口内本来不可选的变为可选），问此时数组的最大和是多少（只能选允许选的数）？

`customers[i]` 是在第 `i` 分钟开始时进入商店的顾客数量，所有这些顾客在第 `i` 分钟结束后离开。

在某些分钟内，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。

当老板生气时，那一分钟的顾客就会不满意，否则如果老板不生气则顾客满意。

现在，老板可以让自己**连续minutes分钟不生气，只能使用一次**。请问**一天下来，最多多少顾客能感到满意？**

```
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3 
输出：16
老板在最后三分钟保持冷静即可。
```

代码如下：

```c++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        //记录minutes分钟内不生气带来的增量收益
        int temp = 0;
        int resMax = 0;
        int normal=0;
        for(int r=0;r<customers.size();r++)
        {
            //计算正常收益
            if(grumpy[r]==0)
            	normal += customers[r];
            else
                temp += customers[r]; //能挽救多少顾客（不生气可以新增窗口内多少满意顾客）
            if(r<minutes-1)continue;
            //update
            resMax = max(resMax,temp);
            //out
            if(grumpy[r-minutes+1]==1) temp-=customers[r-minutes+1];
        }
        return normal+resMax;
    }
};
```



### （2）从数组两侧取k个数的最大值——转换为n-k的滑动窗口的和最小值

- ==务必注意窗口大小为0的情况，有可能的话可以特判。==以下给出不特判的问题：

```c++
for(int i=0;i<n;i++)
{
    //1、inset
    sum+=arr[i];
    if(i<k-1)continue; //思考一下：如果k是0，那么理论上是不允许选择数的，但此时i=0时k-1=-1，判断i>=k-1会更新下面的sum值，造成错误
    //2、update
    if(sum>=thresholdSum)res+=1;
    //3、delete
    sum-=arr[i-k+1];
}
```



### （3）另一种针对窗口内求和的定长滑动窗口写法——一次更新两端

```c++
class Solution {
public:
    int maxScore(vector<int>& cardPoints, int k) {
        //用求和函数加快计算
        int n = cardPoints.size();
        int sum = accumulate(cardPoints.begin(), cardPoints.end(), 0); //别忘了最后一个参数
        if(n==k) return sum; //注意特殊情况判断
        int tmpSum = accumulate(cardPoints.begin(), cardPoints.begin()+n-k, 0); //前n-k个值之和
        int res = tmpSum;
        
        //求解窗口大小为n-k的最小点数，重点看下面的逻辑
        for(int i=n-k;i<n;i++){
            tmpSum += (cardPoints[i] - cardPoints[i-(n-k)]); //一次更新两端
            res = min(res, tmpSum);
        }
        return sum - res;
    }
};
```



### （4）滑动窗口——针对循环数组

**要点：取余**，并且自己可以画图确定一下索引，同时务必注意负数取余的问题，比如：i-k+1<0，那么就得是：

```c++
nums[(i-k+1 + n)%n] //务必注意这里的负数取余的+n问题
```



### （5）维护“至多k个”的和的最大值，定长滑动窗口怎么写比较好？（都是正数）

相当于窗口内最多k个元素是合法的，少于k个元素也是合法的，此时res的update逻辑位置需要发生变化，类似于：

```c++
for(int i=0;i<=n;i++)
{
    //1.inset
    sum += nums[i];
    //2.update,本题最大k,直接更新即可
    ans = max(ans, sum); //把更新的逻辑写在if(i<k-1) continue;的前面，意味着一开始窗口内元素不到k个也是没问题的
    if(i<k-1) continue;
    sum -= nums[i-k+1];
}
```



### （6）如果发现可以尝试定长滑动窗口（有个固定的k值在），可以尝试以下预处理思路：

- （a）**排序后滑动窗口：**比如原数组选k个数，使得这k个数的最大值与最小值的差最小，则对原数组从小到大排序后做滑动窗口（有点贪心意思在里面）；
- （b）**转换维护的内容**：比如[3439. 重新安排会议得到最多空余时间 I](https://leetcode.cn/problems/reschedule-meetings-for-maximum-free-time-i/)，这道题，可以重新安排 **至多** `k` 个会议，安排的规则是将会议时间平移，且保持原来的 **会议时长** ，你的目的是移动会议后 **最大化** 相邻两个会议之间的 **最长** 连续空余时间。

![image-20250416202219893](assets/image-20250416202219893.png)

- 题目要求会议之间的相对顺序需要保持不变，这意味着我们只能合并相邻的空余时间段，所以重新安排至多 *k* 个会议等价于如下问题：

  - 给你 *n*+1 个空余时间段，合并其中 *k*+1 个**连续**的空余时间段，得到的最大长度是多少？



### （7）给你一个 **二进制环形** 数组 `nums`（数组中只有0和1） ，返回在 **任意位置** 将数组中的所有 `1` 聚集在一起需要的最少交换次数。

要点：先计算整个数组中有几个1（假设为m），那么所有1聚集在一起的结果就一定有m个1，因此维护一个长度为m的窗口，里面的1越多，那么需要通过交换换过来的1就越少，因此只要求长度为m的窗口内最多有几个1即可。

代码如下：

```c++
class Solution {
public:
    int minSwaps(vector<int>& nums) {
        //环形数组,先看看有多少1
        int cnt = 0;
        for(int num: nums)
        {
            if(num==1) cnt++;
        }
        int k = cnt; //窗口大小,要看窗口里的1最多,即0最少
        int n = nums.size();
        int countZero = 0;
        int ans = k; //要最少的0
        for(int i=0;i<n+k;i++) //用环形数组来做
        {
            //1.inset
            countZero += (nums[i%n]==0);
            //2.update
            if(i<k-1) continue;
            ans = min(ans, countZero);
            //3.delete
            countZero -= (nums[(i-k+1+n)%n]==0);  //环形数组，务必小心负数取余的问题
        }
        return ans;
    }
};
```



# 二、不定长滑动窗口

个人理解，做题目的时候需要考虑好数组中数的范围，比如是否有负数，有0，这种情况下单纯的`while(sum>=target)`可能会失效，有时需要加上`while(sum>=target && l<=r)`做进一步判断。

（想象一下缩左指针，结果窗口内有负数，越缩sum越大，有可能会越界。）

> 有负数务必小心，注意看1.（4）的那道题

## 1.求最长/最大

一般题目都有「至多」的要求。

- 与定长滑动窗口套路是类似的，在外层`for`循环中维护r指针，如果不满足要求则移动`l`指针直到满足要求为止。

板子题——**无重复字符的最长子串：**

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> umap; //存储每个字符出现的次数
        int res = 0;
        int l=0;
        for(int r=0;r<s.size();r++){
            umap[s[r]]++;
            while(umap[s[r]]>1){
                umap[s[l]]--;
                l++;
            }
            if(l<=r) res = max(res, r-l+1); //这里以防万一，可以都写一下l<=r，反正多写也不影响结果
        }
        return res;
    }
};
```



### （1）[1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

给你一个二进制数组 `nums`（nums中只会有0或者1） ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

> 本题可以转换为维护窗口内“最多有一个0”的最长子数组。

代码如下：
```c++
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        //其实就是最多包含1个0的最长数组长度
        int zeroCnt = 0;
        int n = nums.size();
        int left = 0;
        int ans = 1;
        for(int right = 0;right<n;right++)
        {
            zeroCnt += (nums[right] == 0);
            while(zeroCnt > 1)
            {
                zeroCnt -= (nums[left] == 0);
                left++;
            }
            ans = max(ans, right - left + 1);
        }
        return ans - 1; //删掉一个元素之后的最长长度
    }
};
```



### （2）维护窗口里最多有一对相邻相等数的最长窗口长度

> 给你一个下标从 **0** 开始的字符串 `s` ，这个字符串只包含 `0` 到 `9` 的数字字符。
>
> 如果一个字符串 `t` 中至多有一对相邻字符是相等的，那么称这个字符串 `t` 是 **半重复的** 。例如，`"0010"` 、`"002020"` 、`"0123"` 、`"2002"` 和 `"54944"` 是半重复字符串，而 `"00101022"` （相邻的相同数字对是 00 和 22）和 `"1101234883"` （相邻的相同数字对是 11 和 88）不是半重复字符串。
>
> 请你返回 `s` 中最长 **半重复** 子字符串 的长度。

可以记录每次重复的位置下标，还有一种比较好写代码的方式是维护一个isSame值，表示窗口内现在有几对相邻相等的数对，如果isSame=2，则移动左指针直到`nums[left]==nums[left-1]`,那么此时right-left+1即为所求，同时更新isSame=1。

代码如下：

```c++
class Solution {
public:
    int longestSemiRepetitiveSubstring(string s) {
        int ans = 1, same = 0, left = 0;
        for (int right = 1; right < s.length(); right++) {
            if (s[right] == s[right - 1]) {
                same++;
            }
            if (same > 1) { // same == 2
                left++;
                while (s[left] != s[left - 1]) {
                    left++;
                }
                same = 1;
            }
            ans = max(ans, right - left + 1);
        }
        return ans;
    }
};
```



### （3）可能要预处理——比如排序

以下是一道例题：

> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个 **非负** 整数 `k` 。
>
> 在一步操作中，你可以执行下述指令：
>
> - 在范围 `[0, nums.length - 1]` 中选择一个 **此前没有选过** 的下标 `i` 。
> - 将 `nums[i]` 替换为范围 `[nums[i] - k, nums[i] + k]` 内的任一整数。
>
> 数组的 **美丽值** 定义为数组中由相等元素组成的最长子序列的长度。
>
> 对数组 `nums` 执行上述操作任意次后，返回数组可能取得的 **最大** 美丽值。
>
> **注意：**你 **只** 能对每个下标执行 **一次** 此操作。

这道题目会有一些思维上的难度。对于笔试题来说为了快速尝试能否通过这道题，可以大胆对数组进行预处理，比如排序（排序也就nlogn，别担心复杂度）。

```c++
class Solution {
public:
    int maximumBeauty(vector<int>& nums, int k) {
        //排序后,维护窗口内元素差<=2*k的最大长度,此时才能保持这一部分都变成同一个值
        sort(nums.begin(), nums.end());
        int l=0;
        int res=1; //最起码美丽值也得是1
        int n = nums.size();;
        for(int r=1;r<nums.size();r++){
            while(nums[r]-nums[l]>2*k){
                l++;
            }
            res = max(res, r-l+1);
        }
        return res;
    }
};
```



### （4）与定长滑动窗口类似，务必注意为负数的情况！注意下面的例题

> 给你一个整数数组 `nums` 和一个整数 `x` 。每一次操作时，你应当移除数组 `nums` 最左边或最右边的元素，然后从 `x` 中减去该元素的值。请注意，需要 **修改** 数组以供接下来的操作使用。
>
> 如果可以将 `x` **恰好** 减到 `0` ，返回 **最小操作数** ；否则，返回 `-1` 。

**必须注意的是，本题转换为求窗口内和为totalSum-x的最大窗口长度后**，需要注意totalSum-x可能会<0的情况。代码如下：

```c++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) 
    {
        //转换为 和恰好为 totalSum-x 的最长子字符串
        int target = reduce(nums.begin(),nums.end())-x;
        if(target<0)return -1; //如果不写这句的话，target<0的时候在while循环里l指针会一直往右走，超过r指针，造成错误的结果，最好的方式就是在这里做一下特判
        int l=0;
        int n=nums.size();
        int tempsum=0;
        int maxLen=-1;
        for(int r=0;r<n;r++)
        {
            //in
            tempsum+=nums[r];
            //out
            while(tempsum>target)
            {
                tempsum-=nums[l];
                l++;
            }
            //update
            if(tempsum==target)
            {
                maxLen = max(maxLen,r-l+1);
            }
        }
        return ( (maxLen==(-1))? (-1):(n-maxLen) );
    }
};
```



### （5）





# 分组循环

适用场景：按照题目要求，数组会被分割成若干组，每一组的判断/处理逻辑是相同的。

核心思想：

- 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。
- 内层循环负责遍历组，找出这一组最远在哪结束。


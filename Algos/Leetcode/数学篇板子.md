# 数学篇板子

# 一、数论

## 1.判断质数

以下为写法1：

```c++
bool is_prime(long long n) {
        for (long long i = 2; i * i <= n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return n >= 2;
    }
```



以下为写法2：

```c++
const int MX = 100'000;
bool np[MX + 1];
vector<int> prime_numbers;

int init = []() {
    np[0] = np[1] = true;
    for (int i = 2; i <= MX; i++) {
        if (!np[i]) {
            prime_numbers.push_back(i);
            for (int j = i; j <= MX / i; j++) { // 避免溢出的写法
                np[i * j] = true;
            }
        }
    }
    return 0;
}();

class Solution {
    bool is_prime(long long n) { //试除法，解释见下面
        if (n <= MX) {
            return !np[n];
        }
        for (long long p : prime_numbers) {
            if (p * p > n) {
                break;
            }
            if (n % p == 0) {
                return false;
            }
        }
        return true;
    }
}
```

关于试除法部分的解释：

> 确实，我们在判断一个数 `n` 是否是质数时，只需要检查它能否被小于或等于其平方根的**质数**整除。原因可以这样理解：
>
> ------
>
> ### **为什么只检查质数因子？**
>
> 假设一个合数 `n` 可以被另一个合数 `k` 整除。例如，`n = 30`，`k = 6`。 如果 `n` 能被 `k` 整除，那么 `n = k * m` (其中 `m` 是某个整数)。 由于 `k` 是一个合数，它一定可以被分解成更小的**质数**因子。例如，`6 = 2 * 3`。 所以，如果 `n` 能被 `k` 整除，那么 `n` 必然也能被 `k` 的**所有质数因子**整除。
>
> 因此，如果 `n` 有一个合数因子，它就一定也会有一个**质数因子**。反过来说，如果 `n` 没有任何质数因子（除了它本身），那么它就不可能有任何合数因子，也就意味着它一定是质数。
>
> 所以，为了判断 `n` 是否是质数，我们只需要检查它是否能被任何**质数**整除即可，无需浪费时间检查合数。



### （1）举个例子：[3556. 最大质数子字符串之和](https://leetcode.cn/problems/sum-of-largest-prime-substrings/)

> 给定一个字符串 `s`，找出可以由其 **子字符串** 组成的 **3个最大的不同质数** 的和。
>
> 返回这些质数的 **总和** ，如果少于 3 个不同的质数，则返回 **所有** 不同质数的和。
>
> 质数是大于 1 且只有两个因数的自然数：1和它本身。
>
> **子字符串** 是字符串中的一个连续字符序列。 
>
> **注意：**每个质数即使出现在 **多个** 子字符串中，也只能计算 **一次** 。此外，将子字符串转换为整数时，忽略任何前导零。

代码如下：
```c++
const int MX = 100000;
bool np[MX+1]; //non-prime
vector<int> primes;

int init = []()
{
    //埃氏筛
    np[0] = np[1] = true;
    for(int i=2;i<=MX;i++)
    {
        if(!np[i]) //是质数
        {
            primes.emplace_back(i);
            for(int j=i;j<=MX/i;j++)
            {
                np[i*j] = true;
            }
        }
    }
    return 0;
}();

class Solution {
public:
    bool isPrime(long long x)
    {
        if(x<=MX) return !np[x];
        //试除法
        for(long long p : primes)
        {
            if(p * p > x) break;
            if(x % p == 0) return false;
        }
        return true;
    }
    long long sumOfLargestPrimes(string s) {
        int n = s.size();
        vector<long long> num_primes;
        for(int i=0;i<n;i++)
        {
            long long num = 0;
            for(int j=i;j<n;j++)
            {
                num = num * 10 + (s[j] - '0');
                if(isPrime(num))
                {
                    num_primes.emplace_back(num);
                }
            }
        }
        //去重,排序,取最大的三个
        sort(num_primes.begin(), num_primes.end(), greater<long long>());
        //去重:
        num_primes.erase(std::unique(num_primes.begin(), num_primes.end()), num_primes.end());
        int sz = num_primes.size();
        long long ans = accumulate(num_primes.begin(), num_primes.begin() + min(sz, 3), 0LL);
        return ans;
    }
};
```


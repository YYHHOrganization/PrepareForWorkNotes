# 牛客——C++ 选择

2025.04.21 5题

# C++ 基础

## 1.运算符优先级

![image-20250421231128405](./assets/image-20250421231128405.png)

> 这道题目考察了运算符优先级和逻辑运算的计算过程。让我们按照运算符优先级逐步计算:
>
> 1. 首先计算括号内和除法运算:
>
> \- b / 2 = 3 / 2 = 1(整数除法)
> \- (a + b) = (2 + 3) = 5
>
> 2. 然后计算非运算:
>
> \- !(a + b) = !5 = 0 (非0为假即0,0为真即1)
>
> 3. 接着按照从左到右顺序计算减法和加法:
>
> \- 0 - 4 + 1 = -3
>
> 4. 最后计算逻辑或运算:
>
> \- -3 || (4 + 1) 即 -3 || 5
> \- 在逻辑运算中,任何非0值都当作真(1)
> \- 所以这等价于 1 || 1 = 1
>
> 因此最终结果为1,所以D选项正确。
>
> 分析其他选项:
> A(-2)错误:没有完整考虑逻辑或运算的结果
> B(-1)错误:忽略了逻辑运算将非零值视为1的规则
> C(0)错误:逻辑或运算只要有一个操作数为真,结果就为真(1)

答案：D



## 2.库函数的使用

### （1）printf

![image-20250421231232790](./assets/image-20250421231232790.png)

printf函数中的格式符%5s是用于控制字符串输出格式的说明符。当设置宽度为5时，如果字符串实际长度小于5，则会按照右对齐方式输出，左侧补空格。但是，如果字符串长度大于5，则会按照原字符串的完整长度输出，不会被截断。

答案：B



### (2)gets与strcat

```c++
#include  “stdio.h"  
#include  “string.h"  
int main()  
{  
    char ss[10]="1,2,3,4,5";
    gets (ss); 
    strcat (ss,"6789"); 
    printf ("%s\n",ss); 
    return 0;
}
```

如果输入的是ABC，则输出结果是什么？

> 在提供的代码中，`gets` 和 `strcat` 函数的作用及行为如下：
>
> ### 1. **`gets` 函数的作用与问题**
> - **作用**：`gets(ss)` 从标准输入（如键盘）读取一行数据，直到遇到换行符（`\n`）或文件结束符（EOF）。它会将读取的字符（不包括换行符）存储到 `ss` 数组中，并在末尾自动添加终止符 `\0`。
> - **缓冲区溢出风险**：`gets` **不会检查目标数组 `ss` 的长度**。如果用户输入的字符数超过 `ss` 的容量（代码中 `ss` 的大小为 10，最多存储 9 个字符 + `\0`），会导致缓冲区溢出，引发未定义行为（如程序崩溃或安全漏洞）。因此，`gets` 已被弃用，建议改用 `fgets`。
> - **输入缓冲区的处理**：`gets` 会读取并移除输入缓冲区中的整行数据（包括换行符），但仅将有效字符（换行符前的数据）存储到目标数组。**输入缓冲区中不会残留当前行的数据**，因此 `gets` 不会“清空整个缓冲区”，但会清空当前行的输入。
>
> ### 2. **`strcat` 函数的作用与问题**
> - **作用**：`strcat(ss, "6789")` 将字符串 `"6789"` 追加到 `ss` 的末尾。它会覆盖 `ss` 原有的终止符 `\0`，并在新字符串的末尾添加一个新的 `\0`。
> - **缓冲区溢出风险**：`strcat` **不检查目标数组的剩余空间**。如果 `ss` 在追加后的总长度超过其容量（代码中 `ss` 的大小为 10），会导致缓冲区溢出。
>
> ### 3. **代码示例分析**
> - **初始状态**：`char ss[10] = "1,2,3,4,5";`  
>   初始字符串 `"1,2,3,4,5"` 占用 9 个字符 + `\0`，正好填满 `ss`。
> - **执行 `gets(ss)`**：  
>   用户输入会覆盖 `ss` 的初始内容。例如：
>   - 输入 `"abc"` → `ss` 变为 `"abc\0"`（剩余空间足够）。
>   - 输入 `"1234567890"` → `ss` 溢出（需要 11 字节，但 `ss` 只有 10）。
> - **执行 `strcat(ss, "6789")`**：  
>   假设 `gets` 后 `ss` 有效长度为 `n`，追加 `"6789"` 需要 `n+4+1`（`+1` 为 `\0`）字节。例如：
>   - 若 `ss` 变为 `"abc\0"`，追加后为 `"abc6789\0"`（总长度 7 + `\0`，安全）。
>   - 若 `ss` 已满（如用户输入了 9 字符），追加会导致溢出。
>
> ### 4. **总结**
> - **`gets` 的风险**：始终存在缓冲区溢出风险，应改用 `fgets(ss, sizeof(ss), stdin)`。
> - **`strcat` 的风险**：需确保目标数组有足够空间（可通过 `strncat` 或手动检查长度避免）。
> - **输入缓冲区行为**：`gets` 会读取并清空当前行的输入（换行符前的内容），但不会影响其他行的数据。
>
> ### 代码改进建议
> ```c
> #include <stdio.h>
> #include <string.h>
> 
> int main() {
>     char ss[10] = "1,2,3,4,5";
>     // 使用 fgets 替代 gets，避免溢出
>     if (fgets(ss, sizeof(ss), stdin) == NULL) {
>         // 处理输入错误
>     }
>     // 移除可能的换行符（fgets 会保留换行符）
>     ss[strcspn(ss, "\n")] = '\0';  //https://www.runoob.com/cprogramming/c-function-strcspn.html， 该函数返回 str1 开头连续都不含字符串 str2 中字符的字符数。例如len = strcspn(str1, str2);printf("第一个匹配的字符是在 %d\n", len + 1);
>     
>     // 检查剩余空间再追加
>     if (strlen(ss) + strlen("6789") < sizeof(ss)) {
>         strcat(ss, "6789");
>     } else {
>         // 处理空间不足
>     }
>     printf("%s\n", ss);
>     return 0;
> }
> ```

==strcat会在遇到第一个\0时开始拼接==。



## 3.虚函数

![image-20250421231439317](./assets/image-20250421231439317.png)

> 让我们逐个分析各个选项:
>
> B选项正确:
> 当父类中的虚函数被声明为final时,这意味着该函数不允许被子类重写。这是C++11引入的特性,用于防止继承类修改基类的某些行为。
>
> C选项正确:
> 当类中声明了虚函数时,编译器会为该类自动添加一个虚函数表指针(vptr),该指针指向虚函数表。因此,包含虚函数的类的sizeof值会比不包含虚函数时大4个字节(32位系统)或8个字节(64位系统)。
>
> ==D选项正确:
> 这涉及到C++中的对象切片(Object Slicing)现象。当通过值传递方式将派生类对象赋值给基类对象时,派生类对象会被"切掉",只保留基类部分。因此在这种情况下,即使func是虚函数,a.func()调用的也是基类A中的实现。==
>
> A选项错误:
> 在C++中,父类声明虚函数时确实需要使用virtual关键字,但子类重写虚函数时override关键字是可选的。override关键字是C++11引入的,用于显式声明重写意图,可以帮助编译器进行检查,但不是必需的。
>
> 这道题主要考察了C++中虚函数的特性,包括final关键字的作用、虚函数对对象大小的影响以及对象切片现象对虚函数调用的影响。

答案：BCD



## 4.多线程

### （1）多线程的多种输出结果

程序中thread01和thread02分别是两个线程的入口函数，如下那些选项的输出是可能的？

```c++
#include <iostream>
#include <thread>
#include <Windows.h>
#include <mutex>
 
using namespace std;
 
mutex mu; 
mutex me;
 
int totalNum = 1;
int anotherNum = 0;
void thread01()
{
    while (totalNum > 0)
    {
        mu.lock(); 
        cout << "Thread1, totalNum is "<<totalNum << endl;
        totalNum--;
        me.lock();
        anotherNum++;
        cout <<"Thread1, anotherNum is "<<anotherNum<<endl;
        me.unlock();
        Sleep(100);
        mu.unlock();  
    }
}
void thread02()
{
    while (totalNum > 0)
    {
        me.lock();
        anotherNum += 2;
        mu.lock();
        totalNum--;
        mu.unlock();
        Sleep(100);
        me.unlock();
    }
}
```

![image-20250421233543212](./assets/image-20250421233543212.png)

> 这道题目考察了多线程编程中的互斥锁和线程同步的概念。
>
> 让我们分析代码的执行流程：
>
> 1. 程序中有两个全局变量：totalNum初始值为1，anotherNum初始值为0
> 2. 使用了两个互斥锁mu和me来控制对这些变量的访问
> 3. thread01和thread02是两个并发执行的线程
>
> 
> 选项ABC都是可能的输出，原因如下：
>
> A. "Thread1, totalNum is 1, Thread1, anotherNum is 1"
> 当thread01先获得执行权时，可能出现这种输出。因为此时totalNum还是1，thread01执行后anotherNum增加1。
>
> B. "Thread1, totalNum is 1"
> 当thread01执行到输出totalNum后，还未来得及输出anotherNum时，这个输出是可能的。这种情况下程序可能因为死锁而终止。
>
> C. "Thread1, totalNum is 0, Thread1, anotherNum is 3"
> 如果thread02先执行，将anotherNum增加2，然后thread01执行时totalNum已经为0，且anotherNum再加1，最终anotherNum为3，这种输出也是可能的。
>
> D选项错误，因为不可能出现"totalNum is 1"且同时"anotherNum is 3"的情况。要使anotherNum达到3，必须是thread02执行一次（+2）和thread01执行一次（+1），而这个过程中totalNum必然会减少到0。
>
> 关键点：
>
> 1. 由于多线程的并发性，执行顺序是不确定的
> 2. 互斥锁的使用会影响线程间的同步
> 3. 程序中存在死锁的可能性（当两个线程互相等待对方释放锁时）
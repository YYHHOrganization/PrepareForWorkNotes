# Lesson_6 纹理映射基础

## 1.纹理坐标/UV坐标

​	在之前的文章中，我们渲染出了一些物体，这些物体具有不同的颜色，但总感觉会缺乏一些细节。在这一节中，我们会介绍”纹理“的相关知识，并将其应用在我们的模型上。读者之前可能听说过”贴图“这个概念，实际上贴图一般就是指纹理，是二维空间的一张图。为我们的模型添加纹理本质上就是把这张二维的贴图“贴”在三维的物体上，**而这个过程就被称之为“纹理映射”。**

> 在计算机图形学中，纹理是用来为三维模型表面添加细节和视觉效果的重要元素。为了将这种二维图像（纹理）正确地映射到三维物体上，我们需要使用一种称为纹理坐标的系统。这些坐标通常被称为UV坐标，其中“U”和“V”代表纹理图像中的水平和垂直轴。通过将每个顶点与相应的UV坐标关联起来，计算机能够准确地确定如何将纹理铺展到物体表面，从而实现生动且现实的视觉效果。

​	下图体现了一张纹理贴图在纹理空间（UV空间）下的UV坐标：

![image-20241011152025687](./assets/image-20241011152025687.png)

​	可以看到，U和V的范围都是[0，1]，接下来要做的事就是把这张UV图贴在物体上。以后我们统称上述图所在的空间为UV空间。



## 2.纹理映射

​	容易想到的是，我们可以为模型上的每一个点定义一个在UV空间的坐标，然后采样对应纹理的位置作为模型上这个点的颜色。事实上在类似于obj格式的文件中确实存储着每个顶点的UV坐标，例如下面是一个obj文件的一部分：

```c
vt 0.052860 0.740138  //这里的vt就记录着每个顶点的UV坐标
vt 0.073368 0.751300
vt 0.073806 0.818326
vt 0.067983 0.799840
vt 0.061847 0.779863
vt 0.167926 0.947280  
vt 0.186658 0.941543
//...
f 22255/7017/6478 22258/7020/6481 22256/7018/6479  //这里f表示一个三角形面，一共三项表示三个顶点，每个顶点的a/b/c中的b则表示纹理坐标的索引，例如7017就表示索引到id=7017的顶点的vt坐标，即为纹理采样坐标
f 22259/7021/6482 22258/7020/6481 22255/7017/6478
f 22259/7021/6482 22260/7022/6483 22258/7020/6481
f 22255/7017/6478 22257/7019/6480 22261/7023/6484
f 22259/7021/6482 22255/7017/6478 22261/7023/6484
f 22245/7007/6468 22262/7024/6485 22244/7006/6467
f 22257/7019/6480 22263/7025/6486 22261/7023/6484
```

​	在obj文件中记录了三角形顶点的UV值，而三角形中间像素的UV值可以像之前插值颜色一样，利用三角形的重心坐标进行插值。在Github的仓库中，我们提供了一个可交互式Demo，读者可以拖动UV坐标，屏幕上会呈现出对应该点的UV坐标，并且高亮显示对应的点，读者可以很方便地跟上面的UV空间的UV图做对比，例如下面的动图：

<video src="./assets/demo_01.mp4"></video>

## 3.UV展开及类型

​	现在我们知道了一个模型会记录各个顶点UV坐标，以及纹理映射的概念和过程，读者可能会产生一个疑问，那就是这个UV坐标是怎么生成的？如果是简单的几何体（例如上面展示的球体），可以利用数学关系将几何映射到UV的坐标（比如球体可以将球面坐标映射到UV坐标上），但对于比较复杂的几何体，如人物、场景的模型，这个UV坐标要如何制作映射关系呢？这其实就是类似Maya，Blender等建模软件中的UV Editor的功能了，这些建模软件的UV编辑器的作用就是方便美术工作人员展开模型的UV，并且依据UV绘制对应的贴图，这样在做渲染的时候就可以把UV和贴图对应起来，达到预期的效果。我们以Maya为例，看一下UV Editor的样子：

![image-20241011171535628](./assets/image-20241011171535628.png)

​	可以看到右侧是一个稍微复杂一点的桥的模型，左面则是Maya提供的UV编辑器，这里的创建菜单栏可以帮助我们创建UV Layout，即模型顶点和UV的映射关系，如果我们点击上图的创建->自动，会得到下面的结果：

![image-20241011171703964](./assets/image-20241011171703964.png)

​	Maya会自动展开到对应的UV。左图里面的UV Editor里面的边可以对应到右图模型上的边。以上只是一个例子，真正的美术工作人员需要对展开UV进行规范化处理，例如控制每个UV壳之间的间隙，对UV占用率进行分析等，这里不再过多介绍。注意到创建菜单栏有一些不同的创建UV映射的算法，可以方便人们的编辑。

> 注：Maya等建模软件中提供对已有的UV进行切割、移动、旋转、缩放、重排、展开等操作，以方便进行自由度更高的控制。

在接下来的章节中，我们会介绍纹理的基本属性、纹理的缩放和一些特殊的纹理。



## 2.纹理属性

​	在前面的部分，我们介绍了纹理在图形学中的作用，以及纹理是怎样由艺术家绘制出来的。纹理有很多属性，它们会决定在不同情景下纹理的不同状态。想要学习纹理有哪些属性，最直观的方式是直接看在常见的渲染器，游戏引擎中纹理有哪些可以属性。这里以Unity为例，我们来看一下一张纹理有哪些特征：

​	在Unity中导入一张纹理，然后点击纹理，可以看到如下的界面：

![image-20241014214544898](./assets/image-20241014214544898.png)

​	可以看到，纹理的属性特别多，这里我们会介绍一些常见的纹理属性，并且对他们进行更具体的解释。读者可以对此有个大概的印象，哪个部分不了解的话可以快速跳转到对应的章节。具体介绍的内容有：

- Tiling&Offset : 指的是纹理的重复次数和偏移量；
- Texture Type：纹理的类型，例如Normal Map，Cookie，Lightmap等；
- sRGB：是否使用sRGB色彩空间，也即是否进行Gamma校正；
- Wrap Mode：纹理的重复方式，例如Repeat，Clamp等；
- Filter Mode：纹理的过滤方式，例如Point，Bilinear，Trilinear等；
- Mipmap：纹理的Mipmap，用于提高纹理的渲染效率；
- Aniso Level：各向异性过滤，用于提高纹理的渲染效果；
- Virtual Texture：虚拟纹理，用于提高纹理的渲染效率；
- Compression：纹理的压缩方式，用于减少纹理的内存占用；



### （1）Tiling & Offset

​	虽然再上图中没有显示这个属性，但实际上在纹理采样中tiling&offset是十分重要的参数，这里我们先介绍一下这两个属性。

​	很多时候我们要把一张纹理贴在一个模型上，但是这张纹理的大小和模型的大小并不一定是一样的，这时候我们就需要对纹理进行缩放和偏移。在纹理映射的过程中，我们可以通过Tiling & Offset来控制纹理的重复次数和偏移量。Tiling可以理解为纹理“重复”的次数，Offset表示纹理的偏移量。纹理采样结合tiling和offset之后，UV坐标会变为：

```c
vec2 uv = vUV * _MainTex_ST.xy + _MainTex_ST.zw;
```

​	其中`_MainTex_ST.xy`表示Tiling，`_MainTex_ST.zw`表示Offset，vUV则表示原来的UV值。例如在Unity中，我们可以通过在材质Material的Inspector面板来调整Tiling和Offset的值。在后面的demo演示中，我们也可以更直观地看到Tiling和Offset对纹理采样的影响。以下一组对比图分别是：

（a）默认tiling=1，offset=0（这里为了简化，tiling=tilingX=tilingY=1，offset也是同理，下同）；

（b）tiling=2，offset=0；

（c）tiling=1，offset=0.2；

![image-20241014221822310](./assets/image-20241014221822310.png)

​	通过以上的对比图，相信读者已经对Tiling和Offset有了一定的了解，接下来我们会介绍另外一些纹理的属性。



### （2）Texture Type

![image-20241014221920030](./assets/image-20241014221920030.png)

​	可以看到，类似Unity的引擎支持非常多的Texture类型，并且也支持不同的Texture Shape，例如Cube，2D Array，3D等，这些在后面会进行更详细的介绍。在前面讲解的基础纹理都算是Default类型，也就是默认的纹理（一般用于做普通贴图，附着在模型上），比如前面展示的贴图类型一般是base map。后续会重点介绍的Texture类型如下，读者可以先对他们有一个基本的理解：

- Normal Map：法线贴图，用于模拟表面的凹凸感，使得模型看起来更加真实。

- Cookie：用于实现光照效果，例如在Unity中，我们可以通过Cookie来实现Spot Light的效果。

- Lightmap：用于实现光照效果，例如在Unity中，我们可以通过Lightmap来实现全局光照的效果。

- Shadowmask：用于实现阴影效果，例如在Unity中，我们可以通过Shadowmask来实现阴影的效果。

- Sprite：用于实现2D游戏中的精灵（Sprite）效果，这种效果一般用于2D游戏中，后面会介绍其原理。



### （3）关于sRGB

​	在前面的章节中，我们提到了纹理的颜色，但是在实际的渲染过程中，我们会遇到一个问题，就是颜色在屏幕上的显示。在计算机中，颜色的显示是通过RGB来表示的，但是在显示器上，颜色的显示是通过sRGB的颜色空间来表示的。这里深入探讨的话其实涉及到一个叫做**伽马（gamma）校正**的问题，Unity 中的 sRGB 属性主要用于指示纹理是否以 sRGB 色彩空间存储。如果纹理已被标记为 sRGB，Unity 会在渲染时自动对其进行 gamma 校正，以确保其显示效果符合人眼的感知。

> 简单来说，Gamma 校正是一种非线性操作，它调整图像的亮度信息，以便更好地匹配人类视觉系统的感知。由于人眼对亮度的感知并不是线性的，因此需要通过 gamma 曲线来校正图像。Gamma校正的目的是使图像在显示器上的亮度更符合人眼的感知，从而使图像看起来更加自然。在后面的章节中，我们会详细介绍Gamma校正的原理。

​	例如我们前面那张用于贴在物体表面的纹理，如果它的颜色在制作的时候是在线性色彩空间的（linear，意味着在制作的时候没有考虑gamma校正），那么在显示到屏幕上的时候为了让视觉效果更好，就可以勾选上sRGB属性。



### （4）Wrap Mode





tiling+offset， repeat/clamp，bilinear/point/trilinear（先提一下），mipmap，sRGB，



## 3.纹理相关算法

### （1）纹理的缩放

- point/bilinear
- mipmap ：直接在openGL生成一组mipmap图就可以
- 各向异性过滤



## 4.特殊纹理

### （1）Albedo

### （2）Cubemap

### （3）Normalmap



### （4）三维纹理

讲一下切线空间。



## 5.纹理压缩（给自己的福报）

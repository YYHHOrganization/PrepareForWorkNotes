# 在渲染器中引入动画系统

在这部分中，我们首先介绍《游戏引擎架构》这本书里关于动画系统的介绍，并聚焦于骨骼动画的部分。然后，尝试在我们的渲染器中引入动画系统，实现一个简单的骨骼动画。

# 一、《游戏引擎架构》动画系统精讲（上）

大纲如下（不做非常细节的摘抄，可以看原书pdf 第469页（对应书p448）开始，以下很多知识点只记录页码，到时候回来争取能根据知识要点答出来，就算掌握了。

11.1.1 Sprite Animation，Animated Texture

11.1.2 Rigid Hierarchical Animation（其实就是只有骨骼在动，关节位置产生裂缝，没有蒙皮）

11.1.3 Per-vertex Animation & Morph Target Animation（这个常用于做Face Animation）

11.1.4 蒙皮动画（Skinned Animation）

![image-20241028135234672](./assets/image-20241028135234672.png)



11.1.5 把动画方法视为数据压缩技术

> 简单理解，就是不管是Morph Target还是Skinned Animation，其本质都是在做动画的压缩，而对于动画师而言，Morph Target更多适用于脸部的动画，而Skinned Animation则是骨骼动画（比如四肢的移动）。



## 11.2 骨骼

其实我们说的skeleton很多时候都是指的joint，因为两个相连的joint连在一起就是skeleton。

### 11.2.1 骨骼层阶结构

![image-20241028141303938](./assets/image-20241028141303938.png)



### 11.2.2 在内存中表示骨骼

每个关节的数据结构如下：
```c++
struct Joint
{
    Matrix4x3 m_invBindPose;  //绑定姿势之逆变换，这个在后面会有更加详细的介绍。用于存储模型空间变回到关节空间的矩阵，用于蒙皮，看游戏引擎架构的11.5.2部分，比较清晰
    const char* m_name;  //人类可读的关节名字
    U8 m_iParent; //父索引，或者0xFF表示根骨骼
};
```

关于m_invBindPose这个东西，在骨骼变换的章节还会详细介绍。先放在这里。

此时Skeleton系统的结构如下：
```c++
struct Skeleton
{
    U32 m_jointCount; //关节数目
    Joint* m_aJoint; //关节数组
};
```



## 11.3 姿势

![image-20241028142141592](./assets/image-20241028142141592.png)

### 11.3.1 绑定姿势

bind-pose/reference pose/rest pose：本质上都是一个东西，一般就是比如T Pose/A pose。



### 11.3.2 局部姿势

这里我们需要看一下《游戏引擎架构》这本书的p455页。以下记录重点：

- local pose：局部姿势，描述相对于父的姿势，局部姿势几乎都存储为SQT格式；
- 关节空间：看下图（Maya中应该可以开启或关闭关节空间的显示）：

![image-20241028142618880](./assets/image-20241028142618880.png)

- ![image-20241028142721092](./assets/image-20241028142721092.png)

- 关于关节缩放：看p456，大致是在说引擎一般会对缩放进行限制，比如能否缩放、能否支持非统一缩放，这样做的优劣势等。



#### 11.3.2.2 在内存中表示关节姿势

前面有说，关节姿势一般被保存为SQT格式，C++中一般要把Q放在第一个字段以保证最好的内存对齐（**细节暂可以不考虑，应该就是结构体内存对齐的优化策略**）：

```c++
struct JointPose
{
    Quaternion m_rot; //Q
    Vector3 m_trans;
    F32 m_scale;
};
```

当然，也可以选择允许做非统一缩放，此时就变成了：
```c++
struct JointPose
{
    Quaternion m_rot; //Q
    Vector3 m_trans;
    Vector3 m_scale;
    U8 m_padding[8]; //note：这里的m_padding是什么？真的有必要记录这个么
};
```

![image-20241028143237405](./assets/image-20241028143237405.png)



#### 11.3.2.3 把关节姿势当作基的变更

![image-20241028143513993](./assets/image-20241028143513993.png)

其实就是讲一下，我们上面计算的这个`m_aLoclPose`其实就是$P_(C->P)_j$，也就是这个矩阵记录了在父节点的空间P中子空间的变换，因此通过这个矩阵就可以把子joint转换到其父joint的空间（P），当然也许有时也需要这个逆矩阵，从父joint的空间变换到子joint的空间。



### 11.3.3 全局姿势

在这一节中，我们会介绍如何计算任何一个关节$J$的模型空间姿势。

![image-20241028143733139](./assets/image-20241028143733139.png)

![image-20241028143841659](./assets/image-20241028143841659.png)



#### 11.3.3.1 在内存中表示全局姿势

![image-20241028144012598](./assets/image-20241028144012598.png)

我的理解是提前计算好这个`m_aGlobalPose`，就可以很方便地计算出某个joint空间相对于模型空间的变换（**相当于预计算**），此时就可以在做骨骼动画的时候快速拿到结果。



## 11.4 动画片段

基础原理看《游戏引擎架构》的p459。

**这一部分的要点是理解以下的概念：**

- 局部时钟和全局时钟（note：关于这两种同步方式**有点没看懂，有需要可以讨论一下**）；
- 简单的动画数据格式
- metachannel的定义：我的理解实际上就是在动画文件中记录一些额外的参数，比如光源参数，摄像机参数等。



## 11.5 蒙皮和Matrix Pallete

在前面的学习中，我们已了解如何用旋转、平移及缩放设置骨骼的姿势，也知道任何骨骼姿势都可以用一组局部$P_{j->p(j)}$或全局$(P_{j→m})$关节姿势变换表示。之后，我们会探讨把三维网格顶点联系至骨骼的过程。此过程称为**蒙皮(skinning)。**

### 11.5.1 每顶点的蒙皮信息

![image-20241028153612699](./assets/image-20241028153612699.png)

![image-20241028153707574](./assets/image-20241028153707574.png)



### 11.5.2 蒙皮的数学

这一部分其实就是求解蒙皮矩阵。

![image-20241028153832834](./assets/image-20241028153832834.png)

#### 11.5.2.1 单个关节骨骼的例子

这个看《游戏引擎架构》的p472页，讲的确实不错。

以下为公式11.1：

![image-20241028154636392](./assets/image-20241028154636392.png)



在看完这部分的整理之后，相信我们已然较为了解骨骼系统是怎么运作的了，接下来立刻将骨骼动画应用到我们的渲染器当中！



# 二、将骨骼动画引入渲染器


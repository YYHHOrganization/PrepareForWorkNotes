# 纹理（下）——几种特殊的纹理贴图及应用

​	在上节中，我们依次介绍了纹理贴图的概念、应用、属性，以及纹理放大和纹理缩小时遇到的问题和解决方案。实际上在图形学中，纹理贴图远不止基础纹理这么简单。例如在游戏开发中，常见的纹理贴图可能有40种以上，看起来十分复杂，但基本作用有以下几种：

- （1）存放预计算的结果：在实时渲染中，计算量比较大的运算很难做到及时计算完成，会成为运行的瓶颈。因此很多计算可以提前预计算好，”烘焙“成一张贴图，在渲染的时候读取贴图上的RGBA值作为数据来使用。这类贴图很常见，比如在以后的课程中我们会讲述环境光照的模拟就会用到许多预计算的贴图。
- （2）增加渲染质量：这点也是由于实时渲染的效率决定的。由于实时渲染有速度的要求，很多时候我们甚至希望能到60fps（帧率，每秒60帧）甚至120fps。这就要求渲染要足够快，因此可能直接渲染不容易表现出细节等信息。在本节中，我们会介绍”法线贴图“的原理，并介绍法线贴图是如何”欺骗“观众，从而为模型添加光照的细节的。
- （3）记录数据：最为典型的就是VAT（Vertex Animation Texture），提前在纹理中存放好每个顶点的移动数据，这样在制作顶点动画的时候就可以直接从纹理中拿到每个顶点的运动轨迹，进而做一些类似于旗帜飘动，或者破碎的效果。另外，我们也可能会把环境的信息提前存放在一张环境贴图中，这样在渲染的时候采用一些实时渲染的技术，就可以在运行时没有这个环境的同时，模拟物体在某个环境下的情况。

​	读者不难发现，以上三条其实都有降低实时渲染的计算量的考量。在本节中，我们会着重介绍两种纹理贴图，**法线贴图**和**环境贴图**，并将这两种贴图引入我们的渲染器当中。



# 一、纹理对光照系统的改善作用

## 1.回顾

​	在Blinn-Phong光照模型的相关章节中，我们介绍了环境光项，漫反射项和镜面反射项。复习一下当时的公式：
$$
L = 
L_a + L_d + L_s = k_aI_a + k_d(I/r^2)max(0, \vec{n} · \vec{l}) + L_s = k_s (I/r^2) max(0, \vec{n}·\vec{h})^\alpha
$$
​	那么，能否把纹理引入到光照模型中，加入更多的细节呢？显然是可以的，在光照模型（上）的章节中我们最后渲染出了这张图：

![image-20241107142927179](./assets/image-20241107142927179.png)

​	实际上这里的漫反射项中的$k_d$，即漫反射系数就取自于漫反射贴图。这张贴图长这样：

<img src="./assets/image-20241107143113712.png" alt="image-20241107143113712" style="zoom: 50%;" />

​	显然，我们在做漫反射光照的时候，伪代码应该如下：
```c++
float4 frag(varying input)
{
    float2 uv = input.uv; //片元着色器，插值之后的uv值
    float4 albedo = tex2D(_DiffuseMap, uv); //用上面的uv值对上图漫反射贴图采样，得到对应UV坐标的颜色
    float4 kd = albedo;
    float3 lightDir = GetLightDir();
    float ndotL = dot(input.normal, lightDir);
    float3 diffuse = kd * max(0, ndotL);
    return diffuse;
}
```

​	在工业界，一个模型的相关贴图往往都是由美术工作人员进行绘制的。常见的绘制贴图的软件有比如Photoshop，以及Substance Painter等等。值得注意的是，**漫反射贴图又叫做albedo贴图，在这张贴图中应该只包含基础色相关的内容，不应该将光照信息存储于这张贴图中，否则结果就会不正确。**



## 2.将高光项存储为贴图

​	对于光照章节的模型渲染来说，我们认为模型的材质是“均一的”，也就是说每个位置的镜面反射效果是类似的。但实际上，我们可以用贴图很好地控制不同区域的高光系数$k_s$，以下我们用Substance Painter软件给小星星模型绘制一张Specular贴图，如下图：

<img src="./assets/image-20241107143839228.png" alt="image-20241107143839228" style="zoom:50%;" />

​	我们先来看这样处理之后的高光项的伪代码：
```c++
float4 frag(varying input)
{
    float2 uv = input.uv; //片元着色器，插值之后的uv值
    float4 spec = tex2D(_SpecularMap, uv); //用上面的uv值对上图镜面反射贴图采样，得到对应UV坐标的颜色
    float4 ks = spec;
    float3 lightDir = GetLightDir();
    float3 viewDir = GetViewDir();
    float3 halfDir = normalize(viewDir + lightDir);
    float3 specular = ks * pow(max(0, dot(input.normal, halfDir)), _glossiness);
    return specular;
}
```

​	在之前的光照章节中，我们默认$k_s$是白色的，或者是一个固定值，而这里我们直接从贴图中用UV坐标采样。容易想到，当采样到的$k_s=0$时，就不可能会有高光出现。通过这种方式，我们可以对高光区域有更加精细地控制。将这张贴图引入到高光中，效果如下：

![image-20241107144939301](./assets/image-20241107144939301.png)

​	可以看到，现在的高光区域集中在UV贴图的对应区域了，读者可以跟之前的效果图做对比，体会Specular map对渲染的精细控制。实际上，像高光贴图这种贴图常用于对光照系统的某一项做“指导作用”。比如说，我们也可以把高光系数glossiness存成贴图，在计算Blinn-Phong的高光项的时候对贴图采样，拿到高光系数。读者可以尝试在自己的渲染器中引入更多的贴图，增加渲染的细节。





# 二、法线贴图NormalMap

​	法线贴图是渲染当中一种**无比重要和常见**的贴图类型。一言以蔽之，法线贴图的作用是**通过对法线方向做偏移，欺骗光照系统，使得模型“好像”有了更多细节**。直接看在Substance Painter软件中制作一张法线贴图，贴在我们的小星星模型上的效果吧：

![image-20241107150447585](./assets/image-20241107150447585.png)

​	还是很有意思的，我们的模型好像直接多出了”凹凸感“。但是实际上，这个模型并没有做任何的修改，依然是普通的小星星模型，和之前的章节一样。那么法线贴图是如何神奇地做到这件事呢？我们先来看这张法线贴图长什么样：

<img src="./assets/image-20241107150722263.png" alt="image-20241107150722263" style="zoom: 67%;" />

​	很奇怪，这张贴图大部分的区域呈现蓝紫色，而且我们并不清楚这张贴图为什么能够让模型产生凹凸感呢？别急，我们一点一点来，先来讲述一下这张贴图在光照模型中的作用。根据本节最开始的回顾章节，易知对于Blinn-Phong光照模型来说，抛开视角方向和光源方向，以及常数项，只有表面法线方向会对光照效果产生影响。那么，如果我们通过一张贴图”扰动“了法线的方向，比如说模拟了物体表面有一个坑的时候的法线变化，那么在光照的时候光照模型就会严格使用偏移之后的法线，从而**就像是模型表面本来就有一个深坑一样。**这就是法线贴图的巧妙之处，我们并不需要对模型做任何的细分等操作，就可以”欺骗“观众，为模型带来更多的细节。

## 1.法线贴图的数学原理

​	简单理解了一下法线贴图的本质之后，我们先来思考第一个问题，这张贴图如何制作出来？有几种常见的思路：

- 在工业界中，例如游戏行业，往往由美术人员先在模型上做雕刻，再把雕刻出来的细节烘焙成一张法线贴图，用于在实时渲染的时候供低模（面片数比较低的模型）使用。
- 像上面这张法线贴图，是我们直接绘制出来的，Substance Painter有提供绘制法线贴图的绘制方法。

​	接下来是第二个问题，这张法线贴图为什么基本是蓝色的？如果我们把模型在模型空间或者是世界空间的法线烘焙下来，应该会得到下图的效果：

![image-20241107151654612](./assets/image-20241107151654612.png)

​	很好理解，因为对于整个模型来说，其法线应该各个朝向都有，所以如果把法线方向归一化后的$xyz$值转换为RGB值之后应该是五颜六色的才对，好像跟我们的蓝色贴图有不小的差距，这里就要引入一个新的概念了——**切线空间**。



### （1）切线空间

​	在法线贴图中，切线空间（Tangent Space）指的是一个局部坐标空间，它与每个表面上的顶点相关联。切线空间由三个基向量组成：切线向量（Tangent），副切线向量（Bitangent 或 Binormal），和法线向量（Normal）。这三个向量通常被用来描述表面的局部几何属性。我们不妨先来想想类似上图，把模型空间或者世界空间下的法线烘焙成贴图的**坏处**是什么，有几个常见的劣势：

- （1）假设我们有一个正方体，雕刻了这个正方体的上面的细节，并把模型空间下的法线烘焙成了贴图，那么这张法线贴图就很难有复用性，我们没办法把它直接用在一个球体上；
- （2）上侧面在模型空间的法线烘焙成了法线贴图后，没办法用在前侧面。我们要存储每个面的所有法线信息。

​	其实很好理解，因为我们存储的是模型空间的法线，即**绝对法线信息**，仅可以用于创建时的那个模型，应用到其他模型上就会出问题。而即将引入的在**切线空间下的法线贴图**则记录的是**相对法线信息**，因此具备可复用性，我们马上会看到这样做的明智之处。在这之前，我们先看看切线空间的示意图：

![切线空间的理解（Tangent space） - hellographic - 博客园](./assets/2979982-20221005002602719-1376650509.png)

​	对于切线空间（切线空间针对每个顶点）来说，我们**定义**：

> 切线空间的原点就是该顶点本身，切线空间的Z轴正方向是模型顶点的法线$\vec{N}$方向，而X轴正方向（上图的$\vec{T}$）是切线方向，而切线空间的Y轴正方向可以由叉乘得到：

$$
B = cross(N, T)
$$

​	这个Y轴又被称为副切线方向（bitangent）。现在回归之前的问题，**为什么法线贴图是蓝色的？**从上面的定义可以看到，法线贴图是定义在**切线空间**当中的，假设我们完全不对法线做任何偏移，所有顶点的法线都指向本来切线空间的Z正方向，也就是（x,y,z） = (0，0，1),由于向量每个分量的范围是[-1，1]，而颜色的RGB范围是[0，1]，因此要做一步转换，将向量编码为颜色：
$$
y = 0.5 x + 0.5
$$
​	其中$x$就是输入的向量的单个分量，$y$则是该分量输出的颜色值。带入$(x,y,z) = (0,0,1)$，得到$(R,G,B)=(0.5,0.5,1)$。来看一下这个颜色是什么：

![image-20241107153826915](./assets/image-20241107153826915.png)

​	破案了，这就是法线贴图的一般颜色！这也能够解释为什么法线贴图基本都是蓝色，因为我们实际上并不会对法线偏移地太过分，所以基本都是蓝色的。



## 2.切线空间中的法线贴图的好处

​	引入切线空间中的法线贴图，有如下的好处：

- （1）自由度高。由于切线空间下的法线贴图记录的是相对法线信息，因此即使把这张贴图用到别的模型上面，也可以得到比较合理的结果。

- （2）很好做贴图复用。同样是之前提到的立方体场景，如果使用切线空间下的法线贴图，六个面就可以只是用一张法线贴图，而不用每个面都单独存储了，节省空间；

- （3）方便做UV动画。假设我们想做一个水渲染效果，用一张法线贴图做水表面的凹凸不平的效果。此时模拟水体流动的时候就可以修改采样切线空间的法线贴图的UV坐标即可，伪代码如下：
  ```c++
  float2 uv = float2(uv.x + _Time, uv.y);
  float3 normalMapColor = tex2D(_NormalMap, uv);
  float3 tangentSpaceNormal = unpack(normalMapColor);  //将颜色转换为切线空间下的法线方向
  float3 worldSpaceNormal = ConvertNormalFromTangentToWorldSpace(tangentSpaceNormal); //将切线空间下的法线方向转到世界空间，因为我们的光源方向，视角方向都是世界空间下的。
  //正常做光照模型即可
  ```

  如果法线贴图是做在模型空间的，这样做大概率会得到**完全错误的结果。**而切线空间避免了这个问题。正因为每个顶点的模型空间法线方向都不一样，因此我们记录**相对偏移**就非常便捷了。

总之，使用切线空间中的法线贴图确实好处多多，接下来我们要做的就是将其引入我们的渲染器当中。核心的步骤就是`ConvertNormalFromTangentToWorldSpace`这个函数的实现细节。



## 3.将法线贴图引入渲染器当中

​	现在又有了新的问题，我们已知法线贴图的每个颜色通道的含义了，那么在实际渲染的时候，我们要如何利用这张贴图来偏移法线，进而“欺骗”光照系统，从而“欺骗”观众呢？

> 复习一下，法线贴图的RGB通道分别存储了在切线空间下的修正后的模型顶点法线方向，默认切线空间的X的正方向是切线方向，Z的正方向是法线方向，Y的正方向由叉乘得到，被称为副切线方向。那么我们要做的事情实际上就是在正常渲染的时候**把法线信息从法线贴图里解析出来，转到世界空间，然后在世界空间下正常做光照模型，但法线方向修改为法线贴图解析之后的法线方向。**

### （1）TBN矩阵

​	以上过程中最难的一个步骤是，如何将切线空间的法线转到世界空间当中？



# 三、环境光贴图Cubemap




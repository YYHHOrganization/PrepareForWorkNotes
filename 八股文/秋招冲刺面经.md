# 秋招冲刺面经

# Q1-10

好的，我已经帮你对提供的Markdown内容进行了重新排版和内容校对。

主要调整如下：
1.  **修正了不当的换行**，使标题和正文、列表项和内容都在同一行，格式更加紧凑和规范。
2.  **统一了排版风格**，使用加粗和有序/无序列表来增强可读性。
3.  **校对了内容**，修正了个别术语的拼写错误（如 `Dynamic Dispatch`），并对部分描述进行了微调，使其更加精确。
4.  **优化了结构**，对一些并列关系的概念使用了数字列表，使结构更清晰。

以下是重新排版和校正后的内容：

***

# 秋招冲刺面经

## Q1-10

> ### **一、基础部分 (10题 - 难度: 简单)**
>
> 1.  **请解释C++中栈（Stack）和堆（Heap）的区别，并说明它们的用途。**
>
>     *   **栈（Stack）**
>         *   **特点**：由编译器自动分配和释放，速度快，内存空间有限。主要存放函数参数、局部变量、返回地址等。遵循“先进后出”（LIFO）原则。
>         *   **分配方式**：自动分配。其大小在编译时确定。
>         *   **管理方式**：由编译器自动管理，无需程序员干预。
>         *   **大小**：有限，通常较小（例如几MB）。
>         *   **效率**：高，因为分配和释放是简单的指针移动，没有内存碎片问题。
>         *   **用途**：存储局部变量、函数调用上下文、函数参数等。
>
>     *   **堆（Heap）**
>         *   **特点**：由程序员手动通过 `new` 或 `malloc` 等运算符分配和释放，速度相对较慢，内存空间较大，但可能产生内存碎片。
>         *   **分配方式**：动态分配。
>         *   **管理方式**：由程序员手动管理，若忘记释放，容易造成内存泄漏。
>         *   **大小**：通常较大，受限于系统可用的虚拟内存。
>         *   **效率**：相对较低，因为涉及复杂的内存管理算法和系统调用，且容易产生内存碎片。
>         *   **用途**：存储程序运行时动态创建的数据，如大型对象、数组，以及需要在函数调用结束后仍然存在的数据。
>
> 2.  **引用（Reference）和指针（Pointer）是C++中的两个重要概念，请阐述它们之间的主要区别。**
>
>     *   **本质**：
>         *   **指针**：一个变量，存储了另一个变量的内存地址。
>         *   **引用**：一个已存在变量的别名。它不占用独立内存（或可认为与原变量共享内存），必须在声明时初始化。
>
>     *   **空值**：
>         *   **指针**：可以为空（`nullptr`），表示不指向任何对象。
>         *   **引用**：不能为 `nullptr`，必须引用一个有效的对象。
>
>     *   **初始化**：
>         *   **指针**：可以不初始化，也可以先声明后赋值。
>         *   **引用**：必须在定义时初始化，且一旦初始化后不能再引用其他变量。
>
>     *   **可变性**：
>         *   **指针**：可以改变所指向的对象（即可以指向不同的内存地址）。
>         *   **引用**：一旦初始化，就不能改变它所引用的对象，它终生都是该变量的别名。
>
>     *   **操作**：
>         *   **指针**：需要使用 `*` 运算符进行解引用来访问其指向的值。
>         *   **引用**：可以直接像使用原变量一样使用，无需解引用。
>
>     *   **算术运算**：
>         *   **指针**：支持指针算术运算（如 `++`、`--`、`+`、`-`）。
>         *   **引用**：不支持算术运算。
>
>     *   **代码示例**：
>         ```cpp
>         int x = 10;
>         int* ptr = &x; // 指针：ptr存储x的地址
>         int& ref = x;  // 引用：ref是x的别名
>         
>         *ptr = 20; // 通过指针修改x
>         ref = 30;  // 通过引用修改x
>         
>         // ptr可以指向另一个变量
>         int y = 40;
>         ptr = &y;
>         
>         // ref不能改变引用的对象，下面的操作是把y的值赋给x，而不是让ref引用y
>         ref = y;
>         ```
>
> 3. **`const`关键字在C++中非常常用，请至少说出三种`const`的用法并举例说明。**
>
>    `const`关键字用于定义常量，限制变量、指针、引用、函数等的修改权限，以提高代码的健壮性和可读性。
>
>    1.  **修饰变量（定义常量）**：变量的值在初始化后不能被修改。
>        ```cpp
>        const int MAX_SIZE = 100;
>        // MAX_SIZE = 200; // 错误：不能修改const变量
>        ```
>
>    2.  **修饰指针**：
>        *   **指向常量的指针 (`const int* p` 或 `int const* p`)**：指针指向的内容不能通过该指针修改，但指针本身可以指向其他地址。
>            ```cpp
>            int a = 10, b = 20;
>            const int* p = &a;
>            // *p = 15; // 错误：不能修改指向的内容
>            p = &b;     // 正确：指针可以指向其他地址
>            ```
>        *   **常指针 (`int* const p`)**：指针本身是常量，初始化后不能再指向其他地址，但其指向的内容可以修改。
>            ```cpp
>            int a = 10, b = 20;
>            int* const p = &a;
>            *p = 15;    // 正确：可以修改指向的内容
>            // p = &b;  // 错误：指针本身不能被修改
>            ```
>        *   **指向常量的常指针 (`const int* const p`)**：指针本身和其指向的内容都不能被修改。
>            ```cpp
>            int a = 10;
>            const int* const p = &a;
>            // *p = 15; // 错误
>            // p = &b;  // 错误
>            ```
>
>    3.  **修饰函数参数**：防止参数在函数内部被意外修改，通常与引用结合使用以提高效率。
>        
>        ```cpp
>        void printValue(const int& value) {
>            // value = 100; // 错误：不能修改const引用参数
>            std::cout << value << std::endl;
>        }
>        ```
>        
>    4.  **修饰成员函数 (`const`成员函数)**：表示该成员函数不会修改类的任何非静态成员变量。`const`对象只能调用`const`成员函数。
>        ```cpp
>        class MyClass {
>        public:
>            int getValue() const { // const成员函数
>                // m_value = 10; // 错误：不能修改成员变量
>                return m_value;
>            }
>            void setValue(int val) {
>                m_value = val;
>            }
>        private:
>            int m_value; 
>        };
>        ```
>
> 4.  **什么是虚函数（Virtual Function）？它在C++中主要用来解决什么问题？**
>
>     *   **定义**：虚函数是在基类中使用 `virtual` 关键字修饰的成员函数，派生类可以重写（override）该函数。
>
>     *   **作用**：虚函数的主要作用是实现 **运行时多态（Runtime Polymorphism）**。它允许通过基类指针或引用来调用派生类中重写的同名函数。
>
>     *   **解决的问题**：
>         *   **动态派发（Dynamic Dispatch）**：在面向对象编程中，我们希望根据对象的 **实际类型**（而非指针或引用的声明类型）来调用相应的函数。虚函数机制使得程序在运行时能够做到这一点。
>         *   **代码扩展性与灵活性**：虚函数使得我们可以编写通用的代码来处理不同派生类的对象。当新增派生类时，无需修改原有使用基类指针的代码，只需在新类中实现虚函数即可，符合“开闭原则”。
>
> 5.  **请解释什么是多态（Polymorphism），并说明C++是如何通过虚函数实现运行时多态的。**
>
>     *   **多态（Polymorphism）**：
>         *   多态是面向对象编程的三大特性之一（封装、继承、多态），其字面含义是“多种形态”。在编程中，它指 **同一接口，多种实现**。
>         *   C++中的多态分为两种：
>             *   **编译时多态**：通过函数重载和模板实现。在编译阶段就确定了调用哪个函数版本。
>             *   **运行时多态**：通过虚函数和继承实现。在程序运行阶段根据对象的实际类型来确定调用哪个函数。
>
>     *   **C++通过虚函数实现运行时多态的机制**：
>         1.  **虚函数表（v-table）**：当一个类声明了虚函数（或继承了虚函数），编译器会为该类生成一个虚函数表。这是一个指针数组，存储了类中所有虚函数的地址。
>         2.  **虚函数指针（v-ptr）**：每个包含虚函数的类的对象，其内存布局中都会包含一个虚函数指针。这个指针在对象创建时被初始化，指向其所属类的虚函数表。
>         3.  **动态绑定（Dynamic Binding）**：当通过基类指针或引用调用虚函数时，程序会执行以下步骤：
>             *   通过对象的 `v-ptr` 找到对应的 `v-table`。
>             *   在 `v-table` 中根据函数在表中的固定偏移量，找到要调用的虚函数的实际地址。
>             *   调用该地址处的函数。
>
>         因为不同派生类的对象其 `v-ptr` 指向各自类的 `v-table`，所以即使通过同一个基类指针调用，最终执行的也是实际对象所属派生类中的函数。
>
> 6.  **构造函数（Constructor）可以是私有的吗？如果是，在什么场景下会这么做？**
>
>     是的，构造函数可以是私有的（`private`）。
>
>     这种设计模式阻止了在类外部直接创建对象，通常用于以下场景：
>
>     1.  **单例模式（Singleton Pattern）**：确保一个类在程序中只有一个实例。通过私有化构造函数，并提供一个公共的静态方法来获取该唯一实例。
>         ```cpp
>         class Singleton {
>         private:
>             Singleton() {} // 私有构造函数
>             Singleton(const Singleton&) = delete; // 禁用拷贝构造
>             Singleton& operator=(const Singleton&) = delete; // 禁用赋值
>         
>         public:
>             static Singleton& getInstance() {
>                 static Singleton instance; // C++11后线程安全的局部静态变量
>                 return instance;
>             }
>         };
>         // 使用: auto& instance = Singleton::getInstance();
>         ```
>
>     2.  **工厂模式（Factory Pattern）**：当对象的创建过程很复杂，或者需要根据输入参数决定创建哪个子类的实例时，可以将构造函数设为私有，并提供一个静态的“工厂方法”来负责对象的创建。
>
>     3.  **限制对象的创建方式**：强制对象只能在栈上或堆上创建，或者只能作为另一个类的友元或内部类来创建。
>
> 7. **什么是拷贝构造函数（Copy Constructor）？请描述它被调用的典型场景。**
>
>    *   **定义**：拷贝构造函数是一种特殊的构造函数，它接受一个同类型的常量引用作为参数，用于创建一个新对象作为已存在对象的副本。如果用户没有定义，编译器会生成一个默认的拷贝构造函数，执行成员的按位复制（浅拷贝）。其标准形式为：`ClassName(const ClassName& other);`
>
>    *   **被调用的典型场景**：
>        1.  **用一个已存在的对象初始化一个新对象**：
>            
>            ```cpp
>            MyClass obj1;
>            MyClass obj2 = obj1; // 调用拷贝构造函数
>            MyClass obj3(obj1);  // 显式调用拷贝构造函数
>            ```
>        2.  **对象作为函数参数进行值传递**：
>            ```cpp
>            void func(MyClass obj) { /* ... */ } // obj是通过拷贝构造函数创建的副本
>            MyClass obj1;
>            func(obj1);
>            ```
>        3.  **函数以值的方式返回一个对象**：
>            ```cpp
>            MyClass createObject() {
>                MyClass temp;
>                return temp; // 返回时会创建临时对象，可能调用拷贝构造
>            }
>            // 注意：现代编译器通常会使用返回值优化(RVO/NRVO)来避免这次拷贝
>            ```
>        
>    *   **重要性**：当类中包含指针等管理动态资源的成员时，必须自定义拷贝构造函数以实现 **深拷贝**，否则默认的浅拷贝会导致多个对象指向同一资源，引发重复释放等严重问题。
>
> 8.  **`std::vector`在底层是如何实现动态扩容的？扩容过程会带来什么性能开销？**
>
>     *   **底层实现**：`std::vector` 内部通常使用一块连续的动态数组来存储元素。它维护了三个关键信息：指向数据起始位置的指针、当前元素数量（`size`）和当前已分配内存的容量（`capacity`）。
>
>     *   **动态扩容过程**：当向 `vector` 添加元素（如 `push_back`）且 `size == capacity` 时，会触发扩容：
>         1.  **分配新内存**：申请一块比原容量更大的新内存空间。通常，新容量是旧容量的 **1.5倍或2倍**（具体增长因子由编译器实现决定）。
>         2.  **移动/拷贝元素**：将旧内存中的所有元素 **移动**（如果类型支持移动构造）或 **拷贝** 到新内存中。
>         3.  **释放旧内存**：销毁旧内存中的对象并释放旧的内存空间。
>         4.  **更新内部指针**：将 `vector` 内部的指针指向新的内存地址。
>
>     *   **性能开销**：
>         1.  **内存分配开销**：向系统申请新内存是一个较慢的操作。
>         2.  **元素转移开销**：所有元素都需要被移动或拷贝，元素越多、对象越大，开销越大。
>         3.  **迭代器失效**：扩容后，所有指向原 `vector` 元素的迭代器、指针和引用都会失效。
>
>     *   **优化策略**：如果能预估元素数量，应使用 `reserve()` 方法提前分配足够内存，避免频繁的自动扩容。
>
> 9.  **请简述你对RAII（Resource Acquisition Is Initialization，资源获取即初始化）原则的理解。**
>
>     *   **定义**：RAII是C++中一种核心的资源管理技术和编程范式。它将资源的生命周期与对象的生命周期严格绑定。
>
>     *   **核心思想**：
>         *   **资源获取**：在对象的 **构造函数** 中获取资源（如分配内存、打开文件、加锁）。
>         *   **资源释放**：在对象的 **析构函数** 中释放资源（如释放内存、关闭文件、解锁）。
>
>     *   **核心优点**：
>         1.  **自动化管理**：资源会随着对象的销毁而自动释放，无需手动管理，极大简化了代码。
>         2.  **异常安全**：无论函数是正常返回还是因抛出异常而退出，栈上的对象都会被正确地析构，从而保证资源一定会被释放，有效防止了资源泄漏。
>         3.  **代码清晰**：资源管理的逻辑被封装在类中，职责明确。
>
>     *   **典型应用**：
>         *   **智能指针**（`std::unique_ptr`, `std::shared_ptr`）：管理动态内存。
>         *   **文件流**（`std::ifstream`, `std::ofstream`）：管理文件句柄。
>         *   **锁守卫**（`std::lock_guard`, `std::unique_lock`）：管理互斥锁。
>         ```cpp
>         // RAII示例：使用std::lock_guard管理互斥锁
>         #include <mutex>
>         std::mutex mtx;
>         
>         void safe_thread_function() {
>             std::lock_guard<std::mutex> lock(mtx); // 构造时加锁
>             // ... 访问共享资源 ...
>         } // 函数结束，lock对象析构，自动解锁
>         ```
>
> 10. **`static`关键字在C++中有什么作用？（请从变量和函数两个角度回答）**
>
>      `static` 关键字根据其使用位置有不同的作用，主要影响变量的 **生命周期** 和 **作用域（链接属性）**。
>
>      1.  **修饰局部变量（静态局部变量）**
>          *   **作用**：改变局部变量的生命周期。它不再存储于栈上，而是存储在静态存储区。其生命周期从程序开始到结束，且只在第一次执行到其定义时初始化一次。
>          *   **特点**：作用域不变（仍为局部），但其值在函数多次调用间保持不变。
>          ```cpp
>          void counter() {
>              static int count = 0; // 只初始化一次
>              count++;
>              std::cout << "Called " << count << " times." << std::endl;
>          }
>          ```
>
>      2.  **修饰全局变量（静态全局变量）**
>          *   **作用**：改变全局变量的 **链接属性**，从外部链接（external linkage）变为内部链接（internal linkage）。
>          *   **特点**：使其作用域被限制在当前源文件（翻译单元）内，其他文件无法通过 `extern` 访问它。这有助于避免多文件间的命名冲突。
>          ```cpp
>          // file1.cpp
>          static int file_local_var = 10; // 只能在 file1.cpp 中使用 lua当中对应local _G
>          ```
>
>      3.  **修饰全局函数（静态函数）**
>          *   **作用**：与静态全局变量类似，改变函数的链接属性为内部链接。
>          *   **特点**：使函数的作用域被限制在当前源文件内，成为该文件的“私有”辅助函数。
>          ```cpp
>          // file1.cpp
>          static void helper_function() { /* ... */ } // 只能在 file1.cpp 中调用
>          ```
>
>      4.  **修饰类成员变量（静态成员变量/类变量）**
>          *   **作用**：该变量属于整个类，而非类的某个特定对象。所有对象共享这一个变量。
>          *   **特点**：必须在类外进行定义和初始化。生命周期为整个程序运行期间。
>          ```cpp
>          class Player {
>          public:
>              static int playerCount;
>              Player() { playerCount++; }
>          };
>          int Player::playerCount = 0; // 在类外初始化
>          ```
>
>      5.  **修饰类成员函数（静态成员函数/类函数）**
>          *   **作用**：该函数属于整个类，不与任何特定对象实例绑定。
>          *   **特点**：没有 `this` 指针，因此不能访问非静态成员。可以直接通过类名 `::` 调用。常用于实现工厂方法或访问静态成员变量。
>          ```cpp
>          class Math {
>          public:
>              static int add(int a, int b) { return a + b; }
>          };
>          // 调用: int sum = Math::add(3, 5);
>          ```
>
> ------
>
> 希望这些详细的答案能帮助你更好地理解这些C++的基础概念。如果你有其他不确定的题目，或者想深入了解某一个知识点，随时告诉我！



> 好的，没有问题。
>
> `const` 和 `constexpr` 的区别是C++11之后非常高频的面试题，它考察了面试者对编译期和运行期概念的理解。
>
> 我已经为你补充了这道题目，并按照之前的格式进行了排版和解答。
>
> ***
>
> 11. **`const` 和 `constexpr` 的区别与联系是什么？**
>
>     `const` 和 `constexpr` 都用于定义常量，但它们的核心区别在于 **常量初始化的时机**。`const` 保证变量在初始化后不可修改，而 `constexpr` 则是一个更强的约束，它要求变量或表达式的值必须在 **编译期** 就能确定。
>
>     ---
>
>     #### **核心区别**
>
>     1.  **求值时机（Evaluation Time）**
>         *   **`const`**：只保证了 **运行时不可变** (Read-only)。其初始值可以在编译期确定，也可以在运行期确定。
>             ```cpp
>             int get_random_number() { return 42; } // 假设这是一个运行时才能确定的值
>             const int runtime_const = get_random_number(); // 合法，在运行时初始化
>             const int compile_time_const = 10;          // 合法，在编译期初始化
>             ```
>         *   **`constexpr`**：要求 **编译期可求值** (Compile-time evaluable)。它所修饰的变量或表达式，其值必须在编译阶段就能被编译器计算出来。
>             
>             ```cpp
>             constexpr int compile_time_const = 10; // 合法
>             // constexpr int runtime_const = get_random_number(); // 编译错误！get_random_number() 的值在编译期未知
>             ```
>         
>     2.  **对函数的作用**
>         *   **`const`**：修饰成员函数时，表示该函数不会修改类的成员变量（`const` 成员函数）。它对普通函数没有作用。
>         *   ==**`constexpr`**：修饰函数时，表示该函数只要传入的参数是编译期常量，那么它就能在编译期产生一个编译期常量结果。这种函数被称为“常量表达式函数”。==
>             
>             ```cpp
>             constexpr int square(int x) {
>                 return x * x;
>             }
>                         
>             const int const_val = square(5);           // 运行时计算（或被优化）
>             constexpr int constexpr_val = square(5); // 编译期计算，constexpr_val 在编译后直接就是 25
>                         
>             // constexpr 函数也可以在运行时使用
>             int n = 10;
>             int runtime_result = square(n); // 合法，此时 square 函数在运行时执行
>             ```
>         
>     3.  **使用场景**
>         *   **`const`**：用于任何你希望“只读”的场景，特别是对于那些值在运行时才能确定的常量，如函数参数、运行时配置等。
>         *   **`constexpr`**：用于那些值必须在编译期就确定的场景，例如：
>             *   数组的大小定义
>             *   模板的非类型参数
>             *   枚举（`enum`）的初始值
>             *   需要编译器进行深度优化的数值计算
>     
>             ```cpp
>             constexpr int array_size = 5;
>             std::array<int, array_size> my_array; // 合法，array_size是编译期常量
>                         
>             template<int N>
>             class MyTemplate {};
>             MyTemplate<array_size> instance; // 合法
>             ```
>
>     #### **联系**
>     
>     *   一个 `constexpr` 变量一定是 `const` 的。因为它在编译期就确定了值，之后自然也不可能被修改，所以它满足 `const` 的“只读”属性。
>     *   可以认为，`constexpr` 是 `const` 的一个更严格的子集，它特指那些在 **编译期** 就能确定其值的 `const` 变量。
>
>     #### **总结**
>     
>     | 特性             | `const`                              | `constexpr`                            |
>     | :--------------- | :----------------------------------- | :------------------------------------- |
>     | **主要目的**     | 运行时不可变（Read-only）            | 编译期可求值（Compile-time constant）  |
>     | **求值时机**     | 编译期或运行期                       | **必须**是编译期                       |
>     | **对函数的作用** | 修饰成员函数，保证不修改成员         | 修饰函数，使其能在编译期执行           |
>     | **核心优势**     | 保证数据不被意外修改，增强代码健壮性 | 提升性能（计算前移），可用于编译期编程 |
>     
>     **选择建议**：
>     *   如果一个值可以在编译期确定，**优先使用 `constexpr`**。这能给编译器最大的优化空间，并能在更多编译期场景下使用。
>     *   如果一个值必须在运行时才能确定（例如用户输入、函数返回值），但又希望它在初始化后不被修改，则使用 `const`。



- UGUI系统
  - (1)UI的性能在哪——UGUI系统的核心逻辑：Update
  - (2)如何解决性能问题？Drawcall，SetPass call，Batch
    - Sprite Altas（图集），动静分离，RectMask2D 
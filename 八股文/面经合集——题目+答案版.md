# 面经合集——题目+答案版

> 注：部分答案放的是比较精简的版本，更为详细的介绍在其他的笔记里应该有所整理。精简版本有助于回顾核心知识，确保答案能够快速说中重点。



# C++ 篇

## **【1】C++类的存储相关**

可参考链接：（[C++类的存储及类对象内存结构_c++对象的存储空间-CSDN博客](https://blog.csdn.net/fenxinzi557/article/details/51995911)）

> 这道题目考察的是C++中类是怎么存储的，答题的时候考虑一下几个方面：
>
> - 类的数据成员存储参考类的内存对齐（也是结构体的内存对齐），类内函数（非虚函数）存在代码区，虚函数表一般也存储在代码区。静态函数以及静态成员函数都存储在代码区，类的静态成员变量存储在静态区，也因此需要外部初始化。
> - 在C++中，类的声明（即定义类本身）不会占用任何内存分区。只有在声明类的对象时，才会根据写的代码分配到堆区（或者严谨一点说自由存储区）/栈区；
> - 对于基类，如果有虚函数，那么先存放虚函数表指针，然后存放自己的数据成员；如果没有虚函数，那么直接存放数据成员。
> - 对于单一继承的类对象，先存放父类的数据拷贝(包括虚函数表指针)，然后是本类的数据。
> - 虚函数表中，先存放父类的虚函数，再存放子类的虚函数；如果子类重写了父类的某些虚函数，那么新的虚函数会将虚函数表中父类的这些虚函数覆盖。
> - 对于多重继承，先存放第一个父类的数据拷贝，在存放第二个父类的数据拷贝，一次类推，最后存放自己的数据成员。其中每一个父类拷贝都包含一个虚函数表指针。如果子类重载了某个父类的某个虚函数，那么该将该父类虚函数表的函数覆盖。另外，子类自己的虚函数，存储于第一个父类的虚函数表后边部分。
> - 空类占一个字节。
>
> 另外还有一些问题，**比如派生类出现基类中的同名变量后，内存是如何布局的？优先级比较低，有时间或者问到了再来整理吧。**



### （1）虚继承的内存布局

在 C++ 中，**虚继承**的内存布局和单实例保证是通过编译器生成的**虚基类指针表**和特殊的构造顺序实现的。核心机制如下：

- **(1) 虚基类指针 (vbcp)**
  - 每个虚继承的派生类会存储一个指向**虚基类子对象**的指针。
  - 这些指针组成**虚基类表 (vbtable)**，记录虚基类在对象中的偏移量。
- （2）共享布局：
  - 虚基类的成员会被放置在**最终派生类对象**的末尾。
  - 所有中间类通过指针共享这个唯一实例。

比如下面这个菱形继承的例子：

```c++
class A { int data; };
class B : virtual public A { ... };
class C : virtual public A { ... };
class D : public B, public C { ... };
```

内存布局如下：

```c++
+------------------+
| D 的非虚成员    |  ← D 自身数据
+------------------+
| B 的非虚成员    |  ← 来自 B
| B的虚基类指针   | → 指向 A 的位置
+------------------+
| C 的非虚成员    |  ← 来自 C
| C的虚基类指针   | → 指向 A 的位置
+------------------+
| A 的成员 (data)  |  ← **唯一实例**
+------------------+
```

**(1) 构造顺序**

- 虚基类由**最终派生类 (Most Derived Class)** 直接构造。
- 中间类 (B/C) 的构造函数**不会重复构造 A**。

**(2) 析构顺序**

- 析构顺序与构造顺序相反，确保只销毁一次。



### （2）虚函数+虚继承（黑暗）

在 C++ 中，**虚继承 + 虚函数**的内存布局会结合 **虚函数表 (vtable)** 和 **虚基类指针 (vbcp)** 的机制。以下是详细分析（以典型的 MSVC/GCC 实现为例）：

```c++
class Base {
public:
    virtual void func1() {}
    int a = 1;
};

class Mid1 : virtual public Base {  // 虚继承
public:
    virtual void mid1_func() {}
    int b = 2;
};

class Mid2 : virtual public Base {  // 虚继承
public:
    virtual void mid2_func() {}
    int c = 3;
};

class Derived : public Mid1, public Mid2 {
public:
    virtual void derived_func() {}
    int d = 4;
};
```

**对象内存布局**（简化示意图）：

```c++
|-----------------------------|
| Mid1 的 vptr                | --> 指向 Mid1 的虚函数表（含虚函数地址和虚基类偏移）
| Mid1 的成员变量 (b=2)       |
|-----------------------------|
| Mid2 的 vptr                | --> 指向 Mid2 的虚函数表（含虚函数地址和虚基类偏移）
| Mid2 的成员变量 (c=3)        |
|-----------------------------|
| Derived 的成员变量 (d=4)     |
|-----------------------------|
| Base 的 vptr                | --> 指向 Base 的虚函数表（仅在最底层存在）
| Base 的成员变量 (a=1)       | 
|-----------------------------|
```

- 每个类有自己的虚函数表，包含：
  - 虚函数地址（包括继承和重写的函数）
  - **虚基类偏移量**（用于定位虚基类子对象）
- **最终派生类 (Derived)** 负责初始化 `Base` 的虚函数表。

对于虚基类指针：

- `Mid1` 和 `Mid2` 的虚函数表中会存储 **到 Base 子对象的偏移量**（可以结合题目【2】的虚函数表结构来看）。
- 访问 `Base` 成员时，通过虚函数表中的偏移量计算地址。

构造顺序如下：

- 构造顺序：`Base` → `Mid1` → `Mid2` → `Derived`
- **只有最终派生类 (Derived)** 会实际构造 `Base` 子对象。

访问过程示例：

```c++
Derived obj;
Base* p = &obj;  // 通过虚基类偏移量找到 Base 子对象
p->func1();       // 通过 Base 的 vptr 查虚函数表调用，因为子类没有重写func1函数

obj.a = 10;  // 编译器生成代码：
             // 1. 通过 Mid1 的虚函数表找到 Base 的偏移量
             // 2. 计算 Base 子对象地址
```



> 总结：
>
> - **虚函数表**和**虚基类偏移**共同管理多态和共享基类。
> - **最终派生类**统一管理虚基类的构造和虚函数表。
> - 虚继承会增加 **间接访问开销**（通过偏移量计算地址）。
> - 典型内存开销：
>   - 每个虚继承层级至少增加一个 vptr。
>   - 虚基类偏移量存储在虚函数表或独立表中。



## **【2】虚函数表的存储位置和调用逻辑。==（※）==**

> **1.虚函数表的存储位置一般是在代码区。**
>
> 2.调用逻辑是在多态的时候，会查询对象的虚函数表，找到对应的函数并调用。这里就可以延申提一下虚函数表，虚表指针，运行时多态的概念。
>
> 注：虚表指针通常存储在对象的内存布局中，即它作为对象的一部分存在于堆或栈上。每当创建一个具有虚函数的类的对象时，编译器会在该对象的内存结构中添加一个指向虚表的指针。
>
> 一些其他问题：
>
> - 子类继承父类，虚表长什么样？重写父类虚函数，虚表内容有变换吗？
> - 能否用外部指针指向虚表？**是可以的，虚表放在类开头，在虚函数对应的md笔记中有总结。**

### （1）虚函数表的结构

> 这部分有提到RTTI的概念，在后面的题目中有单独进行总结。

可以参考：[C/C++杂记：深入虚表结构 - malecrab - 博客园](https://www.cnblogs.com/malecrab/p/5573368.html)

在C++中，**虚函数表（vtable）的结构与编译器和ABI（应用二进制接口）密切相关**，但通常遵循通用模式。虚函数表的基本结构如下：

- **虚函数指针数组**：存储类中所有虚函数的地址，按声明顺序排列。
- 附加信息：
  - **type_info 指针**（启用RTTI时）：指向该类的`type_info`对象（用于`typeid`和运行时类型识别）。**type_info 与 RTTI 的关系**为：
    - **`type_info`**：是C++标准库中的类（定义在`<typeinfo>`头文件），存储类型名称和哈希等信息。
    - RTTI 的依赖：
      - 若编译时**禁用RTTI**（如GCC的`-fno-rtti`），虚函数表中将**不包含`type_info`指针**。
      - 启用RTTI时，`type_info`指针是虚函数表的一部分。
  - **偏移量（offset-to-top）**：用于处理多重继承时的对象地址调整。
  - **虚基类偏移量**：处理虚继承时的基类布局。

一个典型的虚函数表结构如下：

```c++
vtable = [
  offset_to_top,       // 对象地址偏移量（用于多重继承）
  &type_info,          // 指向type_info的指针（RTTI相关）是一个对象指针，它用于唯一地标识该类型。
  &Base::func1,        // 虚函数1的地址
  &Base::func2,        // 虚函数2的地址
  ...
]
```



**补充：多重继承下的虚函数表**

- 每个基类有独立的虚函数表

  ```c++
  class Derived : public Base1, public Base2 {
    // 虚函数表1（对应Base1）
    // 虚函数表2（对应Base2）
  };
  ```

- 主基类（Primary Base）：

  - **第一个非虚基类的虚函数表通常与派生类共享。**可以对应到题目【1】中的：子类重载了某个父类的某个虚函数，那么该将该父类虚函数表的函数覆盖。另外，子类自己的虚函数，存储于第一个父类的虚函数表后边部分。
  - 每个虚函数表可能包含自己的`type_info`指针。



### （2）纯虚函数

从高级语言的角度回过头来看，**纯虚函数**其实是一种类似于接口的定义。纯虚函数是在基类中声明但没有具体实现的虚函数,语法为 `virtual 返回类型 函数名(参数) = 0;`。而包含纯虚函数的类称为**抽象类**,不能直接实例化。

- 为了实现多态性，可以用基类指针/引用指向派生类，这一点和普通的虚函数继承是类似的。
- 抽象类的派生类必须实现所有纯虚函数,否则也会成为抽象类。

以下是一个纯虚函数的实现：

```c++
class Mihoyo
{
public:
    virtual void showName() = 0;
};

class Genshin :public Mihoyo
{
public:
    float version;
    virtual void showName() override
    {
        cout << "Genshin Impact!" << endl;
    }
};
```



### （3）补充：虚基类与虚继承

**虚基类**：

**定义**:

- 虚基类用于解决多重继承中的**菱形继承问题**(Diamond Problem),通过 `virtual` 关键字声明继承关系。
- 虚基类确保在继承体系中,基类的子对象只被创建一次。

**用途**:

- **避免重复继承**:当多个派生类继承同一个基类时,虚继承保证基类只存在一个实例。

以下是一个解决菱形继承问题的代码（使用虚继承来解决）：

```c++
class Base {
public:
    int value;
};

// 虚继承
class D1 : virtual public Base {};
class D2 : virtual public Base {};

// FinalDerived 只包含一个 Base 实例
class FinalDerived : public D1, public D2 {};

int main() {
    FinalDerived obj;
    obj.value = 42; // 无歧义,因为 Base 是虚继承的
}
```

对于虚继承的内存相关知识，可以看题目【1】的补充部分。



## **【3】C++内存分区都是什么？**

> 可以参考的链接：[【C++】内存五大区详解_c++内存分区-CSDN博客](https://blog.csdn.net/luhaoran814/article/details/136108790)（有些可以借鉴，但答案主要按下面答就好），一般在答的时候按照下面逻辑即可：
>
> - 栈区：主要存储函数运行时而分配的局部变量，函数参数，返回数据，返回地址,`指针`，`const局部变量`等。**栈区向地址减小的方向增长。**在执行函数时，函数内部变量的存储在栈上。函数执行结束时，系统自动回收。
> - 堆区：**堆区向地址增大的方向增长**，这个区域是在`运行时`使用的，**由`程序员`分配和释放内存**，程序结束时操作系统会对其进行回收，（程序员分配内存像malloc、free、new、delete）一般都是在这个区域进行的；
> - 代码区：又被称为`文本段`。主要存储程序指令、`代码`。代码段中存放`函数`（类的成员函数和全局函数）编译后的可执行的二进制代码，并且这个区域是`只读`区域；
> - 全局区：全局区包含了全局变量、静态变量、常量以及字符串常量。这部分内存在程序结束后由操作系统释放。全局变量和静态变量在编译阶段就已经确定了大小，并且在程序的整个生命周期内都不会被释放。
>   - 如果是问**五大分区**，**则这部分可以变为“常量区”和“全局/静态区”**。针对常量来说，字面值常量（比如`"Hello"`存在常量区；全局/静态const变量存在全局/静态区；局部const变量存在栈或寄存器，可能会被优化掉；`constexpr`常量会在编译时做替换；类的`const static`成员变量存在全局/静态区；动态分配的`const`类对象则可能在堆区。）



### （1）关于类中函数存在代码区的证明（==※==）

可以看一下下面这段代码：
```c++
#include<iostream>
using namespace std;
class Genshin
{
public:
	int version;
	void print() { cout << "Genshin Impact" << endl; }
	void printVersion() { cout << version << endl; }
};
int main() {
	Genshin* g = nullptr;
	g->print(); //不会报错,因为函数在代码区
	g->printVersion(); //注意:如果用到了类内的非静态变量,则此时会报错,因为没有分配内存空间
}
```



## 【4】enum class 的好处/和enum相比较

> 可以参考的链接：[C++新特性——枚举类（enum class），以及与传统枚举的区别_c++的class enum是什么类型-CSDN博客](https://blog.csdn.net/2302_80272644/article/details/141310484)
>
> 传统的 enum 定义在 C++ 中是这样的：
>
> ```c++
> enum TraversalType {
>     Preorder,
>     Inorder,
>     Postorder
> };
> ```
>
> 在这种情况下，Preorder、Inorder 和 Postorder 都是全局作用域中的常量，可以直接使用 Preorder 来引用。如果不同的 enum 类型中有相同名字的枚举值，就会产生冲突。例如，如果你在另一个地方定义了相同名称的 enum，就可能会有名字冲突问题。
>
> **而enum class 解决了传统 enum 的一些问题，主要是：**
>
> - 作用域：enum class 中定义的枚举值不再是全局作用域，而是属于枚举类的作用域。要引用时，需要使用枚举类型名作为前缀。
> - 强类型检查：enum class 是强类型的，不能隐式转换为整数，也不能与整数直接比较。这增加了类型安全性。
>
> 在使用`enum class`的时候，使用方法为：
>
> ```c++
> enum class TraversalType {
>     Preorder,
>     Inorder,
>     Postorder
> };
> //使用方法：if (type == TraversalType::Preorder)
> ```



## 【5】vector怎么实现的，一定都要开辟再拷贝嘛？能不能在原来基础上开辟呢？

> （1）`vector`的实现方法：主要回答动态数组，可以答`begin`，`end`，`end_of_storage`这三个数组，以及扩容的基本机制（每次满了扩容，一般编译器扩2倍）。
>
> （2）通常来说，`vector`的扩容机制如下：
>
> - **开辟新的内存**：分配一块比当前容量更大的新内存（通常是原来容量的两倍）。
> - **拷贝现有元素**：将现有的元素从旧内存拷贝到新内存中。这里可以提一下如果实现了`noexcept`的移动构造函数，会倾向于使用移动语义；
> - **释放旧内存**：释放原来的内存。
>
> `std::vector` 设计时考虑了动态数组的灵活性，通常来说，它并不能在原有内存基础上直接扩展，因为这可能会导致内存碎片或其他复杂性。然而，`std::vector` 可以通过预留空间 (`reserve`) 来优化性能，避免频繁的内存分配和拷贝。
>
> （3）在默认实现中，是不具备在原有内存基础上直接扩展的能力的，会造成**内存碎片等问题。**这里也可以提一下**C++ STL**中Allocator的机制。



## 【6】map和unordered_map区别。哈希表中的value是如何存储的？

> （1）重点回答内容：
>
> - `map`底层是红黑树，而`unordered_map`则使用哈希表；
> - `map`保持元素有序（元素按键排序），而`unordered_map`是无序的；
> - `map`的查找、插入和删除操作的平均时间复杂度为 O(log n)，而`std::unordered_map`：查找、插入和删除操作的平均时间复杂度为 O(1)。
>
> （2）答一下开放寻址法（也可能平方寻址之类的）和链地址法即可。一般用的是链地址法。



## 【7】简述红黑树，为什么不用AVL树而用红黑树

> - （1）红黑树：
>   - 1）每个结点非红即黑；
>   - 2）根节点是黑的；
>   - 3）如果一个结点是红色的，那么它的子节点就是黑色的（也就是不能出现连续的红节点）；
>   - 4）任一结点到树尾端（NULL）的路径上含有的黑色结点个数必须相同。**通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上；**因此，红黑树是一种弱平衡二叉树，**相对于严格要求平衡的平衡二叉树来说，它的旋转次数少，所以对于插入、删除操作较多的情况下，通常使用红黑树。**
>   - 5）叶子节点一定是黑的（NIL）
> - （2）使用红黑树不使用AVL的理由：AVL 树是高度平衡的，**频繁的插入和删除，会引起频繁的rebalance（旋转操作），导致效率下降；**红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转，但是执行速度很快。



### （1）为什么红黑树插入删除效率高？为什么红黑树插入删除后迭代器没有失效？

- **红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL 树要低**。 所以，红黑树的插入、删除、查找各种操作性能都比较稳定。
  - 红黑树的最长链和最短链之间的长度差不会超过两倍。
- 关于迭代器失效问题，可以先看一下这篇：[【C++ STL】迭代器失效的几种情况总结 - fengMisaka - 博客园](https://www.cnblogs.com/linuxAndMcu/p/14621819.html)
  - 对于关联容器(如 map, set,multimap,multiset)，删除当前的 iterator，仅仅会使当前的 iterator 失效，只要在 erase 时，递增当前 iterator 即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。以删除为例，erase 迭代器只是被删元素的迭代器失效，可以采用`erase(iter++)`的方式删除迭代器。**虽然删除了一个元素，整棵树也会调整以符合红黑树的规范，但是单个节点在内存中的地址没有变化，变化的是各节点之间的指向关系。**

注：实际测试，现在也可以写`it = myMap.erase(it)`，`erase`函数在Modern C++中的返回值是Iterator，所以现在实际上顺序容器（包括链表这种）、关联容器的`erase`都可以统一写成`it = myMap.erase(it)`了。

这里给出一个C++的示例程序，删除map中所有key为偶数的键值对：

```c++
#include <iostream>
#include <map>
#include <cstdlib> // for std::rand and std::srand
#include <ctime>   // for std::time

int main() {
    // 设置随机种子
    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    // 创建一个 map
    std::map<int, int> myMap;

    // 随机插入 20 个键值对
    for (int i = 0; i < 20; ++i) {
        int key = std::rand() % 100; // 生成 0 到 99 的随机数
        int value = std::rand() % 100;
        myMap[key] = value; // 插入到 map 中
    }

    // 删除所有键为偶数的键值对
    for (auto it = myMap.begin(); it != myMap.end();) {
        if (it->first % 2 == 0) { // 检查键是否为偶数
            it = myMap.erase(it); // 删除并更新迭代器
            //这里写myMap.erase(it++)也可以
        }
        else {
            ++it; // 继续下一个元素
        }
    }
    return 0;
}
```



## 【8】解释一下inline函数，inline函数可以是虚函数吗？

> （1）`inline`函数简介：用于**建议**编译器将函数体直接展开到调用处，减少函数调用开销，适用于短小频繁调用的函数。编译器可以忽略此建议；
>
> （2）虚函数可以声明为`inline`，但内联优化仅在编译器可确定具体调用对象时生效（如静态绑定）。通过基类指针/引用的动态调用仍然需要通过虚表查找，内联很可能是无效的。



## 【9】析构函数可以是虚函数么？

> 析构函数最好设置为虚函数：
>
> - 如果析构函数不是虚函数，那么父类指针/引用指向子类对象的时候，析构只会调用父类的析构函数，此时可能会造成子类没有析构完全，造成内存泄漏的问题；
> - 如果析构函数是虚函数，那么父类指针/引用指向子类对象的时候，由于多态的性质，会调用子类的析构函数，而子类的析构函数调用之后会自动调用父类的析构函数，此时是能够正确析构的。

补充：构造函数不能是虚函数，因为调用虚函数需要通过虚表指针查虚表，而调用构造函数时还没有虚表指针。



## 【10】内存泄漏有什么解决方式？

> - （1）智能指针：使用`shared_ptr`，`unique_ptr`等自动管理内存，避免手动delete；尽量使用智能指针或容器（标准库容器会自动管理内存），避免裸指针，减少手动管理内存的机会。
>
> - （2）**RAII**：通过构造函数分配资源，析构函数释放资源，确保资源生命周期与对象绑定；
>
>   - **RAII** 是 "Resource Acquisition Is Initialization"（资源获取即初始化）的缩写。它是**C++ 中一种重要的编程理念和模式**，旨在确保资源的正确管理与释放。
>
>     #### 核心思想：
>
>     1. **资源管理**：RAII 的基本思路是将资源的生命周期绑定到对象的生命周期上。当对象被创建时，它会获取某些资源（如动态内存、文件句柄、网络连接等），而当对象被销毁时，这些资源也会自动释放。这种方式极大地减少了内存泄漏和资源未释放的问题。
>     2. **构造函数与析构函数**：资源的获取通常在构造函数中完成，而资源的释放则在析构函数中完成。这意味着，当一个对象超出作用域时，其析构函数会被自动调用，从而释放相应的资源。



## 【11】智能指针专题：

### （1）了解C++的智能指针么？

> 可以结合游戏引擎的例子，来说明C++的三种常见智能指针。
>
> - （1）`std::unique_ptr`：独占所有权，资源唯一归属，不可复制，可以通过移动转移所有权。
>
>   - **应用场景：**比如管理GO的生命周期，例如单个Enemy对象，确保释放时触发析构逻辑；另一种场景是资源的独占加载，如关卡配置数据（LevelConfig），仅由当前关卡管理器持有（似乎Piccolo有类似的逻辑，==有时间可以验证==）
>
> - （2）`std::shared_ptr`：共享所有权。通过引用计数共享资源，计数归0时自动释放。
>
>   - **应用场景：**例如多个Character实例共享同一纹理（Texture），避免重复加载；或者是在组件系统中，`AIComponent`和`PhysicsComponent`共享统一GO的上下文数据。
>
>   - 实例：
>     ```c++
>     class GameObject
>     {
>     private:
>         std::shared_ptr<Transform> m_transform; //此时Transform即为共享资源
>     };
>     ```
>
> - （3）`std::weak_ptr`：打破循环引用。特点是观察`shared_ptr`资源但不增加引用计数。应用场景为**解决循环依赖。**比如`Player`持有`Weapon`的`shared_ptr`，`Weapon`可以通过`weak_ptr`反向引用`Player`，避免内存泄漏。
>
> 以游戏引擎实践为例，类似资源管理器可以使用`shared_ptr`统一管理资源（如材质，模型），确保跨场景时按需加载/卸载；（在ECS架构中`unique_ptr`可以用于管理独立组件（如RenderSystem），`shared_ptr`用于跨系统共享数据。）
>
> 注：高频创建/销毁的对象（如Particle）可以避免使用智能指针，改用对象池手动管理，从而减少引用计数带来的开销。

C++ 智能指针的使用注意事项（涉及到智能指针的使用语法）：

```c++
#include <memory>
#include <thread>
#include <iostream>
using namespace std;

class Genshin
{
public:
    float version;
    Genshin(float version): version(version){}
};

void Observe(std::weak_ptr<Genshin> wptr) { //weak_ptr的用法
    if (auto sptr = wptr.lock()) {
        std::cout << "value: " << sptr->version << std::endl;
    }
    else {
        std::cout << "wptr lock fail" << std::endl;
    }
}

int main() {
    Genshin g(5.5);
    Genshin g2(5.6);
    std::shared_ptr<Genshin> s1 = std::make_shared<Genshin>(g);
    //std::shared_ptr<Genshin> s2 = std::make_shared<Genshin>(g);
    std::shared_ptr<Genshin> s2 = s1; //这么写才会指向一个control block，使用上一行的话s2.use_count()=1，可能不满足需求
    
    weak_ptr<Genshin> w = s2;
    s1 = std::make_shared<Genshin>(g2);
    s2 = s1;
    std::cout << s2.use_count() << std::endl;
    cout << s2->version << endl;
    Observe(w);
}
//输出结果
/*
2
5.6
wptr lock fail
*/
```



### （2）`unique_ptr`可以作为返回值么？

> 在 C++ 中，`std::unique_ptr` 可以作为函数的返回值。这是一种常见的做法，用于实现独占所有权的资源管理。由于 `unique_ptr` 的特性是不能被复制，但可以被移动，因此当我们将 `unique_ptr` 作为返回值时，**实际发生的是移动语义**，这使得资源能够安全地转移到调用者。以下是一个使用案例：
>
> ```c++
> #include <iostream>
> #include <memory>
> class Resource
> {
> public:
>     Resource() { std::cout << "Resource acquired\n"; }
>     ~Resource() { std::cout << "Resource released\n"; }
> };
> 
> std::unique_ptr<Resource> create_resource()
> {
>     return std::make_unique<Resource>(); //make_unique由C++ 14提供
> }
> 
> int main()
> {
>     std::unique_ptr<Resource> res = create_resource(); //相当于资源被转移到主函数中
>     //do sth with res
>     return 0;
> }
> ```
>
> 移动语义通过 `std::unique_ptr` 的构造和赋值过程得以体现。当 `create_resource` 函数返回时，局部的 `unique_ptr` 被移动到 `main` 函数中的 `res` 变量中，这样有效地转移了对 `Resource` 对象的所有权，而不需要进行任何额外的复制操作



### （3）详细说一下`shared_ptr`是怎么实现的引用计数?

> 在C++中，`shared_ptr`的引用计数机制通过以下步骤实现：
>
> - （1）控制块（Control Block）：每个由`shared_ptr`管理的对象都关联一个控制块，其中包含：
>   - 引用计数：跟踪当前有多少个`shared_ptr`共享该对象
>   - 弱引用计数：跟踪`weak_ptr`的引用数（不影响对象生命周期）
>   - 原始指针
>   - 删除器deleter，自定义释放对象的函数（默认为delete）
> - （2）引用计数的操作
>   - **构造时**：当`shared_ptr`被创建（如通过`make_sharerd`或拷贝构造）时，引用计数**原子地递增**；
>     - 推荐`make_shared`，如果从原始指针构造`shared_ptr`（比如`shared_ptr<T>(new T)`），控制块与对象内存分离，此时同一原始指针初始化多个`shared_ptr`时会导致产生多个控制块，引发双重释放问题。
>   - **析构时**：当`shared_ptr`被销毁或重置时，引用计数**原子地递减**
>     - 若引用计数归零，则调用deleter释放对象内存；
>     - 若弱引用计数也为0，释放控制块内存；
> - （3）**原子性与线程安全**
>   - **原子操作**：引用计数的增减通过原子操作，如`std::atomic<int>`实现，确保多线程环境下的线程安全；
>   - **数据安全**：`shared_ptr`的引用计数是**线程安全的**，但管理的对象本身需要额外同步机制（如互斥锁）来保证线程安全。
>
> 以下是一份玩具智能指针的代码实现（包含基本的`weak_ptr`功能），仅用于展示最基础的功能（不包含原子操作、线程安全与自定义deletor）：
>
> ```c++
> #include <iostream>
> #include <memory>
> using namespace std;
> 
> template<typename T>
> class SharedPtr {
> public:
>     int* counter;
>     int* weakref;
>     T* resource;
> 
>     SharedPtr(T* resc = nullptr) {
>         cout << __PRETTY_FUNCTION__ << endl;
>         counter = new int(1);
>         weakref = new int(0);
>         resource = resc;
>     }
> 
>     SharedPtr(const SharedPtr& rhs) {
>         cout << __PRETTY_FUNCTION__ << endl;
>         resource = rhs.resource;
>         counter = rhs.counter;
>         ++*counter;
>     }
> 
>     SharedPtr& operator=(const SharedPtr& rhs) {
>         cout << __PRETTY_FUNCTION__ << endl;
>         --*counter;
>         if (*counter == 0) {
>             delete counter;
>             delete resource;
>         }
> 
>         resource = rhs.resource;
>         counter = rhs.counter;
>         ++*counter;
>     }
> 
>     ~SharedPtr() {
>         cout << __PRETTY_FUNCTION__ << endl;
>         --*counter;
>         if (*counter == 0) {
>             delete counter;
>             delete resource;
>         }
>     }
> 
>     int use_count() {
>         return *counter;
>     }
> };
> 
> template<typename T>
> class WeakPtr {
> public:
>     T* resource;
> 
>     WeakPtr(T* resc = nullptr) {
>         cout << __PRETTY_FUNCTION__ << endl;
>         resource = resc;
>     }
> 
>     WeakPtr& operator=(SharedPtr<T>& ptr) {
>         cout << __PRETTY_FUNCTION__ << endl;
>         resource = ptr.resource;
>         ++*ptr.weakref;  // 赋值时引用计数counter不变，改变弱引用计数weakref
>     }
> 
>     ~WeakPtr() {
>         cout << __PRETTY_FUNCTION__ << endl;
>     }
> };
> 
> class Son;
> 
> class Father {
> public:
>     SharedPtr<Son> son_;
>     Father() {
>         cout << __PRETTY_FUNCTION__ << endl;
>     }
>     ~Father() {
>         cout << __PRETTY_FUNCTION__ << endl;
>     }
> };
> 
> class Son {
> public:
>     WeakPtr<Father> father_;  // 将SharedPtr改为WeakPtr
>     Son() {
>         cout << __PRETTY_FUNCTION__ << endl;
>     }
>     ~Son() {
>         cout << __PRETTY_FUNCTION__ << endl;
>     }
> };
> 
> int main()
> {
>     auto son_ = new Son();  // 创建一个Son对象，返回指向Son对象的指针son_
>     auto father_ = new Father();  // 创建一个Father对象，返回指向Father对象的指针father_
>     SharedPtr<Son> son(son_);  // 调用SharedPtr构造函数：son.counter=1, son.weakref=0
>     SharedPtr<Father> father(father_);  // 调用SharedPtr构造函数：father.counter=1, father.weakref=0
>     son.resource->father_ = father;  // 调用WeakPtr赋值函数：father.counter=1, father.weakref=1
>     father.resource->son_ = son;  // 调用SharedPtr赋值函数：son.counter=2, son.weakref=0
>     cout << "son: " << son.use_count() << endl;
>     cout << "father: " << father.use_count() << endl;
>     return 0;
> }
> ```

以上代码的输出结果：

```c++
WeakPtr<T>::WeakPtr(T*) [with T = Father]
Son::Son()
SharedPtr<T>::SharedPtr(T*) [with T = Son]
Father::Father()
SharedPtr<T>::SharedPtr(T*) [with T = Son]
SharedPtr<T>::SharedPtr(T*) [with T = Father]
WeakPtr<T>& WeakPtr<T>::operator=(SharedPtr<T>&) [with T = Father]
SharedPtr<T>& SharedPtr<T>::operator=(const SharedPtr<T>&) [with T = Son]
son: 2
father: 1
SharedPtr<T>::~SharedPtr() [with T = Father]
Father::~Father()
SharedPtr<T>::~SharedPtr() [with T = Son]
SharedPtr<T>::~SharedPtr() [with T = Son]
Son::~Son()
WeakPtr<T>::~WeakPtr() [with T = Father]
```



### （4）智能指针是线程安全的么？为什么？

> - `shared_ptr`：
>   - **引用计数原子安全**：增减操作通过C++的原子操作实现，是线程安全的。
>   - **对象访问不安全**：注意，多线程直接读写同一对象需要额外做同步（如互斥锁）
> - `unique_ptr`：
>   - **非线程安全**：独占所有权，转移或者释放需要保证单线程操作；
> - `weak_ptr`：
>   - **依赖`shared_ptr`**，与`shared_ptr`类似，仅引用计数是原子安全的。
>
> 这里我们举个例子，以游戏引擎为例，线程A可以通过`shared_ptr`加载纹理，而线程B可以通过另一`shared_ptr`来访问同一纹理。此时引用计数的增减是安全的，但直接修改纹理像素的话需要加锁。



### （5）智能指针的线程共享机制

> 题目（4）是一个大体上的概括，这里以一个具体的例子来体会多线程中的智能指针应用。
>
> 首先是`unique_ptr`：不能被多个线程共享：`std::unique_ptr `是一种独占所有权的智能指针，意味着同一时间内只有一个 `unique_ptr `可以拥有某个资源。你可以将` unique_ptr `移动到另一个对象（例如通过` std::move`），但不能复制。因此，不同线程之间不能直接共享一个 `unique_ptr`:
>
> ```c++
> void threadFunction(std::unique_ptr<int> ptr) {
>     // 处理 ptr
>     std::cout << "Value: " << *ptr << std::endl;
> }
> 
> int main() {
>     std::unique_ptr<int> ptr = std::make_unique<int>(42);
>     //std::thread t1(threadFunction, ptr); // 编译错误，因为 unique_ptr 不能被复制
>     std::thread t2(threadFunction, std::move(ptr)); // 可以移动
>     t2.join();
> }
> ```
>
> 
>
> 但对于`shared_ptr`来说，是可以的。`std::shared_ptr `可以被多个线程共享：`std::shared_ptr `允许多个指针对象共享同一个资源。它使用引用计数来管理资源的所有权，当最后一个` shared_ptr` 被销毁或重置时，资源才会被释放。因此，可以安全地在多个线程中使用 `shared_ptr` 来共享同一个对象。**引用计数的增加/减少是线程安全的**。**但请务必注意，对智能指针所指向的数据进行修改，并不是线程安全的，可能需要自己维护锁。**
>
> ```c++
> #include <memory>
> #include <thread>
> #include <iostream>
> 
> void threadFunction(std::shared_ptr<int> ptr) {
>     std::cout << "Value: " << *ptr << std::endl;
> }
> 
> int main() {
>     std::shared_ptr<int> ptr = std::make_shared<int>(42);
> 
>     std::thread t1(threadFunction, ptr);
>     std::thread t2(threadFunction, ptr);
> 
>     t1.join();
>     t2.join(); // 两个线程都可以访问同一 shared_ptr
> }
> ```



### （6）介绍一下智能指针的循环引用问题

> 循环引用指两个或多个对象通过`std::shared_ptr`相互持有对方的所有权，导致引用计数无法归零，内存无法释放，引发内存泄漏的问题。
>
> **解决方案：使用`std::weak_ptr`替代单向的`shared_ptr。`**存在双向依赖时，需要将一方的`shared_ptr`替换为`weak_ptr`。

```c++
#include <memory>
#include <thread>
#include <iostream>
using namespace std;

class Honkai;
class Genshin
{
public:
    float version;
    std::shared_ptr<Honkai> game;
    Genshin(float version): version(version){}
    ~Genshin(){ cout << "genshin" << endl; }
};

class Honkai
{
public:
    float version;
    std::weak_ptr<Genshin> game;  //（1）如果这里是shared_ptr，则不会调用析构函数，造成内存泄漏
    Honkai(float version) : version(version) {}
    ~Honkai() { cout << "honkai" << endl; }
};

int main() {
    shared_ptr<Genshin> g = make_shared<Genshin>(1.2);
    shared_ptr<Honkai> h= make_shared<Honkai>(2.2);
    h->game = g;
    g->game = h; //造成循环引用的根源
    
    cout << g->game.use_count() << endl; //都是shared_ptr的情况下，这两个都是2
    cout<< h->game.use_count() << endl;
}
```



### ==（7）能用share_ptr初始化unique_ptr吗？==





## 【12】介绍一下C++的多态

C++ 中的多态是指在不同上下文中以不同方式表现的能力，主要分为两种类型：

- **编译时多态（静态多态）**：在编译器即可确定调用哪个函数，包括运算符重载、函数重载和模板；
- **运行时多态（动态多态）**：使用虚函数来实现。接下来回答就可以往虚函数上引了。



## 【13】关于函数重载，为什么不能仅靠返回值不同判断

**函数重载**是指在同一个作用域内，允许存在多个同名但参数列表不同的函数。编译器通过函数的参数数量或类型来决定调用哪个重载函数。

**特点：**

- **参数不同**：可以根据参数的数量、类型或顺序来区分。
- **返回值无关**：重载函数的返回值类型可以相同或不同，但不能仅依靠返回值来区分。

之所以不能够仅靠返回值来做不同判断，是因为如果两个重载函数的参数完全相同，只是返回值不同，编译器无法通过返回值来确定调用哪一个函数，**因为函数调用的上下文是在选择参数时就已经确定了，而并非在函数返回后。**换句话说，**函数返回值的类型是调用函数后的结果，与函数调用本身的决策过程无关。**

> 补充：关于重载和const形参：
>
> - 顶层`const`不影响传入函数的对象。一个拥有顶层`const`的形参无法和另一个没有顶层`const`的形参区分开来。
>   - 回忆：**顶层const可以表示任意的对象是常量（包括指针、类、基本数据类型等）**，底层const则与指针或引用的基本类型部分有关。指针既可以是顶层const也可以是底层const。const引用都是底层const。
> - 比如：
>
> ```c++
> void print(Genshin g){} //(1)
> void print(const Genshin g){} //(2)
> //(1)和(2)不构成重载
> void print(Genshin* g){} //(3)
> void print(Genshin* const g){} //(4):属于顶层const
> //(3)和(4)也不构成重载
> ```
>
> 另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的`const`是底层的，比如以下四个函数均构成重载：
>
> ```c++
> void print(Genshin* g){}
> void print(const Genshin* g){}
> void print(Genshin& g){} //(3)
> void print(const Genshin& g){} //(4)
> const Genshin g;
> print(g); //(4)
> ```
>
> 对于const对象或者指向const的指针来说，只能传递给const形参。理论上，非常量可以转为const，所以非常量既可以调用非常量版本也可以调用常量版本。但**当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。**

注：以下两个不构成重载，因为编译器不知道调用哪个：

```c++
void print(const Genshin g) { cout << "value" << endl; }
void print(const Genshin& g) { cout << "ref" << endl; }
```



## 【14】C++各种关键字/基础特性

### （1）volatile关键字

可参考：[C/C++ 中 volatile 关键字详解 | 菜鸟教程](https://www.runoob.com/w3cnote/c-volatile-keyword.html)

- `volatile`：`volatile` 关键字是一个类型修饰符，用于指示编译器某个变量可能会在任何时刻被外部因素更改，例如硬件或其他线程。这一修饰符的主要作用是告诉编译器不要对该变量进行优化，从而确保每次访问该变量时都直接读取其最新的值。**这防止了编译器在优化代码时，将多个访问合并成一次。**
  - 注：**不提供线程安全**：虽然 `volatile` 可以确保变量的最新值，但它并不提供原子性和线程安全。如果多个线程同时访问同一个 `volatile` 变量，仍然可能会出现竞争条件，因此通常还需要其他同步机制（如互斥锁）。



### （2）extern C

当 C++ 代码需要调用 C 函数时，可以使用 `extern "C"` 声明这些函数，以防止 C++ 的名称修饰（name mangling），确保链接器能够找到正确的 C 函数。一份使用的案例：

```c++
#ifdef __cplusplus
extern "C" {
#endif

void myCFunction(); // C 函数声明

#ifdef __cplusplus
}
#endif
```

`extern "C"` 使得 C++ 能够与 C 代码进行链接，确保 C 函数在 C++ 环境中的正确调用和链接。使用场景包括： 1.在C++中包含C的头文件 2.混合C和C++的开发。



### （3）`const`含义，有什么作用？

- （1）**const用于定义常量**：const定义的常量编译器可以对其进行数据静态类型安全检查。

- （2）**const修饰函数的形参**：当输入参数为用户自定义类型和抽象数据类型时，可以考虑将”值传递“改为”const &传递“，可以提高效率。

- （3）**const修饰函数的返回值**：比如给”指针传递“的函数返回值加const,则返回值不能被直接修改，且该返回值只能被赋值给加const修饰的同类型指针。

  如：

  ```c++
  const char* Miemie(void){};
  char* ch = Miemie();//报错
  const char* ch = Miemie();//正确
  ```

- （4）**const修饰类的成员函数**：任何不会修改数据成员的函数都应该用const修饰，这样，当不小心修改了数据成员或者调用了非const成员函数，编译器都会报错。

```c++
class Genshin
{
public:
    int c;
    void sub(int b){ }
    void add(int a) const
    {
        //c = 3; ERROR:不能修改类内变量
        a = 10; //a可以改，因为是形参
        //sub(a); ERROR:因为const成员函数只能调用const成员函数
    }
};
```



## 【15】C++模板

C++模板是一种支持泛型编程的工具，允许编写与数据类型无关的代码，在**编译时**生成具体类型的实现。

- 从类型来看，模板分为函数模板（比如max函数）和类模板（例如`vector`）。
- 模板参数：可以是类型参数`typename T`，也可以是非类型参数（例如整型/指针等常量），比如一个数组大小`int N`
- 实例化方式：隐式（编译器自动推导类型），或者显式（比如`func<int>`） 
- 特化机制：
  - **全特化：**针对全部参数定制实现
  - **偏特化：**部分参数定制/条件约束（如指针特化）



### （1）全特化与偏特化

下面给出一个全特化和偏特化的例子：

```c++
#include <iostream>

// 通用模板定义
template <typename T, typename U>
class Pair {
public:
    Pair(T first, U second) : first(first), second(second) {}

    void display() {
        std::cout << "Generic Pair: (" << first << ", " << second << ")" << std::endl;
    }

private:
    T first;
    U second;
};

// 全特化：针对 int 类型的 Pair
template <>
class Pair<int, int> {
public:
    Pair(int first, int second) : first(first), second(second) {}

    void display() {
        std::cout << "Specialized Pair for ints: (" << first << ", " << second << ")" << std::endl;
    }

private:
    int first;
    int second;
};

// 偏特化：当第二个参数为 int 类型时
template <typename T>
class Pair<T, int> {
public:
    Pair(T first, int second) : first(first), second(second) {}

    void display() {
        std::cout << "Partial Specialized Pair with int as second type: ("
            << first << ", " << second << ")" << std::endl;
    }

private:
    T first;
    int second;
};

int main() {
    Pair<double, double> genericPair(2.5, 3.0);
    genericPair.display(); // 调用通用版本

    Pair<int, int> specializedPair(114514, 1919810);
    specializedPair.display(); //调用全特化版本

    Pair<std::string, int> partialSpecializedPair("Hello", 42);
    partialSpecializedPair.display(); // 调用偏特化版本

    return 0;
}
```



### （2）可变参数模板

在 C++11 及更高版本中，可变参数模板（Variadic Templates）是一种强大的功能，允许你定义可以接受任意数量参数的模板。这在处理不确定数量的参数时非常有用，比如实现类似于 `printf` 的功能。可变参数模板在 C++ 中**通过递归展开参数包的机制实现**，是通过使用 `...` 语法来定义和操作参数包的。以下是一个可变参数模板实现任意数量参数的`print`方法：

```c++
#include <iostream>
using namespace std;

void print() //需要定义一个基础版本的 print 函数，当没有更多参数时，它仅输出一条消息。
{
	cout << " nothing" << endl;
}

template<typename T, typename... Args>
void print(T first, Args... args) //它接受至少一个参数 T first 和零个或多个额外参数 Args... args
{
	std::cout << first << " ";
	print(args...);  // 递归调用，处理剩余参数
}

int main()
{
	print("1", 2, 1.14514, 'a', true); //1 2 1.14514 a 1  nothing
}
```

实际应用：**日志记录系统**：可变参数模板可以方便地创建一个日志记录函数，支持多种数据类型的参数。以及STL中`vector`实现的`emplace_back`方法就实现了可变参数模板+完美转发。



### （3）模板萃取

> 可以参考的进阶阅读材料：[C++-模板-萃取的实现(一) - 知乎](https://zhuanlan.zhihu.com/p/559936879)，以及后续文章。目前只看了（一）和（二）的一部分，暂时对模板萃取有一个大致的认知即可。另两个进阶阅读材料：[C++模板进阶指南：SFINAE - 知乎](https://zhuanlan.zhihu.com/p/21314708)，[C++：STL中的萃取器traits - 知乎](https://zhuanlan.zhihu.com/p/547313994)。==这几个进阶阅读材料还没有看完，比较难，有遇到这么难的题目再说吧。==

C++中的模板萃取是一种通过模板技术提取类型特性（如类型属性、行为等）的编程模式，**常用于在编译期根据类型的不同特性选择不同的实现逻辑**，其核心是通过**模板特化或偏特化**定义类型的元信息，供其他模板代码使用。

**模板萃取的核心思想**

- 1.定义Traits类：通过模板类封装类型的元信息（如是否是指针、是否有特定成员等）
- 2.特化Traits：针对不同类型，通过特化为其赋予不同的元信息
- 3.编译器逻辑分发：基于Traits的元信息，在编译器选择不同的代码分支。



示例1：判断类型是否为指针（实现的是**类型特征（Type Traits）**）。

- **编译时决策**：编译器能够在编译阶段确定 `is_pointer<int>::value` 和 `is_pointer<int*>::value` 的值，从而使得这个代码在类型检查和性能上都很高效。

```c++
#include <iostream>

//基础模板:默认不是指针
template<typename T>
struct is_pointer {
	static const bool value = false;
};
//特化版本:当类型是指针时匹配
template<typename T>
struct is_pointer<T*> {
	static const bool value = true;
};

int main()
{
	std::cout << std::boolalpha; //输出流将bool值解析为true/false,否则输出1/0
	std::cout << is_pointer<int>::value << std::endl; //false
	std::cout << is_pointer<int*>::value << std::endl; //true
	return 0;
}
```



**示例2：根据类型选择不同实现。**假设需要为整数类型和浮点数类型提供不同的处理逻辑：

```c++
#include<iostream>
#include<type_traits>

//1.Traits类定义类型分类
template<typename T>
struct number_category {
	static const char* value;
};

//2.模板特化
template<> const char* number_category<int>::value = "Integer";
template<> const char* number_category<double>::value = "Double";

//3.根据Traits分发逻辑
template<typename T>
void process(T val){
	std::cout << "Processing number: " << val << "(" << number_category<T>::value << ")" << std::endl;
}

int main(){
	process(114514); //Processing number: 114514(Integer)
	process(3.14); 	//Processing number : 3.14(Double)
}
```



**示例3：STL中的迭代器萃取(iterator_traits)**

STL通过`iterator_traits`提取迭代器的类型信息（如value_type）：

```c++
#include<iostream>
#include<type_traits>
#include<vector>
#include<iterator>

template<typename Iterator>
void print_value_type(Iterator it)
{
	//通过STL的iterator_traits萃取迭代器的value_type
    //using可以简单认为跟typedef差不多
	using value_type = typename std::iterator_traits<Iterator>::value_type;
	std::cout << "Value type: " << typeid(value_type).name() << std::endl; //typeid的介绍：https://blog.csdn.net/HandsomeHong/article/details/115038507
}

int main()
{
	std::vector<int> vec={ 1,2,3 };
	print_value_type(vec.begin()); //Value type: int
	return 0;
}
```



**模板萃取的典型应用场景：**

1. **类型检查**：如 `std::is_pointer<T>`, `std::is_integral<T>`。
2. **算法优化**：根据迭代器类型（随机访问/双向）选择最优实现（如 `std::advance`）。
3. **策略分发**：通过 `std::enable_if`（过于黑魔法了） 或 `if constexpr` 实现编译期条件分支。
4. **容器适配**：萃取类型的特定成员（如 `value_type`、`iterator`）。



## 【16】C++动态内存分配有什么方式

> 这道题目应该就是考察new/delete，以及可以顺便答一下malloc/free
>
> | 特性             | `new` / `delete`                               | `malloc` / `free`              |
> | ---------------- | ---------------------------------------------- | ------------------------------ |
> | **内存分配方式** | 使用构造函数（调用对象的构造函数）             | 只分配原始内存，不调用构造函数 |
> | **内存释放方式** | 使用析构函数（调用对象的析构函数）             | 不调用析构函数                 |
> | **返回值类型**   | 返回特定类型的指针                             | 返回 `void*` 类型的指针        |
> | **异常处理**     | 如果内存分配失败，会抛出 `std::bad_alloc` 异常 | 如果分配失败，会返回 `nullptr` |
> | **用法**         | 用于对象的创建和销毁                           | 用于原始内存的分配和释放       |
> | **初始化**       | 支持初始化                                     | 不支持初始化                   |
> | **重载**         | 可以重载 `new` 和 `delete`                     | 不可重载                       |
> | **类型安全**     | 类型安全，编译时检查                           | 类型不安全，需手动转换类型     |
>
> ### 总结
>
> - **`new` 和 `delete`**：推荐用于对象的动态分配和释放，能够保证对象的构造和析构，并且支持类型安全。
> - **`malloc` 和 `free`**：通常用于 C 风格的内存管理，只适合简单的内存分配，不适用于对象的管理。
>
> 在 C++ 中，建议优先使用 `new` 和 `delete` 来进行动态内存管理，以保持类型安全和资源管理的一致性。

注：new/delete和malloc/free不要混搭，可能会导致内存管理出现问题。



## 【17】C++中`new`和`delete`都是怎么实现的？==（※）==

可参考这篇：[C++：带你理解new和delete的实现原理new和delete是用户进行动态内存申请和释放的操作符，operator - 掘金](https://juejin.cn/post/7023663734367191076)，基本涵盖了这部分的面试题目。默认的实现是：

- `new`：调用`operator new`分配内存，再调用构造函数初始化对象；
- `delete`：调用析构函数销毁对象，再调用`operator delete`释放内存；

**new和delete**是用户进行**动态内存申请和释放的操作符**，**operator new 和operator delete**是系统提供的**全局函数**，**new在底层调用operator new**全局函数来申请空间，**delete在底层通过operator delete**全局函数来释放空间。`operator new`和`operator delete`本身可能是由malloc和free来实现的。

注：栈上对象使用默认的内存管理，不会调用 `operator new` / `operator delete`。

- **衍生问题1：构建一个只能在栈上创建的类；**
- **衍生问题2：构建一个只能在堆上创建的类；**

这两个问题上面链接里有答案。

- **衍生问题3：placement new（==※==）**（new出来的不一定都在堆上）
  - [placement new机制 - 知乎](https://zhuanlan.zhihu.com/p/228001107)
- **衍生问题4：重载new operator和delete operator**
  - 注意，`new operator`和`operator new`是两个概念，后者指的是C++的全局函数，是不能够重载的，而`new operator`是类可以自己重载的操作符。举个例子：

```c++
#include<iostream>
#include<type_traits>
#include<vector>
#include<iterator>
using namespace std;

class MyClass {
public:
    static void* operator new(size_t size) {
        std::cout << "Custom new: Allocating " << size << " bytes.\n";
        void* p = std::malloc(size);
        if (!p) {
            throw std::bad_alloc();
        }
        return p;
    }

    static void operator delete(void* p) noexcept {
        std::cout << "Custom delete: Releasing memory.\n";
        std::free(p);
    }

    // 构造函数和析构函数
    MyClass() { std::cout << "MyClass constructor called.\n"; }
    ~MyClass() { std::cout << "MyClass destructor called.\n"; }
};

int main()
{
    // 动态分配
    MyClass* obj1 = new MyClass(); //重载了new和delete之后C++还是会调用构造函数和析构函数，看起来绕不开构造函数
    delete obj1;

    // 栈上分配
    MyClass obj2; // 这里不会调用 operator new/delete
	return 0;
}
```

这段代码的输出结果为：

> Custom new: Allocating 1 bytes.
> MyClass constructor called.
> MyClass destructor called.
> Custom delete: Releasing memory.
> MyClass constructor called.
> MyClass destructor called.



## 【18】函数调用的过程具体是怎么样的？比如入栈顺序

> 函数调用时的栈操作顺序如下：
>
> - 1.caller的参数压栈：按照从右到左的顺序依次压入参数（比如`func(a,b,c)`,此时先压c，再压b，再压a）；
> - 2.返回地址：执行`call`指令，将下一条指令地址（返回地址）压入栈；
> - 3.保存旧ebp：被调用函数通过push ebp保存调用者的基址指针（注：`push` 指令用于将一个寄存器或值压入栈中）；
> - 4.设置新的ebp：`mov ebp, esp`，将esp的值赋值给ebp，此时就可以通过ebp对栈进行操作；
> - 5.分配局部变量：比如`sub esp N`，调整栈顶，预留空间给局部变量和临时数据；
> - 6.执行函数体：访问参数通过ebp+偏移量（比如64位机器下，第一个函数内参数在ebp+8）；
> - 7.恢复栈帧：`mov esp ebp`，此时把ebp的值赋给esp，于是esp就指到了ebp，释放局部变量空间。接着`pop ebp`：pop的语义很重要，**pop ebp的意思是把当前栈顶的元素出栈，送入ebp中**，而不是让ebp出栈。
> - 8.返回调用者：`ret`弹出返回地址，跳转回调用处；
>
> 以上过程最好能够清晰的理解。

重要知识点：

![img](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/1134295-ce2aa08820b11888.webp)

可以参考：[对于ESP、EBP寄存器的理解 - 狂奔~ - 博客园](https://www.cnblogs.com/xiangtingshen/p/11221277.html)

- **esp是栈指针**，是cpu机制决定的，push、pop指令会自动调整esp的值；
- **ebp只是存取某时刻的esp**，**这个时刻就是进入一个函数内后，cpu会将esp的值赋给ebp，此时就可以通过ebp对栈进行操作，比如获取函数参数，局部变量等，实际上使用esp也可以；**
  - 既然使用esp也可以，那么为什么要设定ebp呢？
  - 答案是为了方便程序员。**因为esp在函数运行时会不断的变化，所以保存一个一进入某个函数的esp到ebp中会方便程序员访问参数和局部变量，而且还方便调试器分析函数调用过程中的堆栈情况**。前面说了，这个ebp不是必须要有的，你非要使用esp来访问函数参数和局部变量也是可行的，只不过这样会麻烦一些。
- 调用一个函数时，**先将堆栈原先的基址（EBP）入栈，以用来保存之前任务的信息。然后将栈顶指针的值赋给EBP，将之前的栈顶作为新的基址（栈底），然后再这个基址上开辟相应的空间用作被调用函数的堆栈。**函数返回后，从EBP中可取出之前的ESP值，使栈顶恢复函数调用前的位置；再从恢复后的栈顶可弹出之前的EBP值，因为这个值在函数调用前一步被压入堆栈。这样，EBP和ESP就都恢复了调用前的位置，堆栈恢复函数调用前的状态。原文链接：https://blog.csdn.net/qq_25814297/article/details/113475019

推荐先看这篇：[C函数调用过程原理及函数栈帧分析 - stardsd - 博客园](https://www.cnblogs.com/sddai/p/9762968.html)。直接来看下面这个例子对应的汇编，自己分析一下（==分析的不一定对，先放这里，应该也差不多，忘了可以看看。==）：

```c++
int add(int a, int b)
{
	int c = a;
	int d = b;
	return c + d;
}

int main()
{
	add(114514, 1919810);
	return 0;
}
```

对应的汇编如下：

![image-20250206172440290](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250206172440290.png)

```c++
add(int, int):
        push    rbp  //将当前基指针 (rbp) 压入栈中，以保存调用此函数之前的基指针值，为新的栈帧准备空间。
        mov     rbp, rsp //更新基指针 (rbp) 为当前栈顶指针 (rsp)，这标志着新栈帧的开始。这样后续的局部变量和参数都可以通过 rbp 进行访问。
        mov     DWORD PTR [rbp-20], edi //将第一个参数（传递给 add 的整数 a，存储在寄存器 edi 中）存储到栈帧中的位置 [rbp-20]。这个位置用于保存局部变量或参数。
        mov     DWORD PTR [rbp-24], esi //将第二个参数（传递给 add 的整数 b，存储在寄存器 esi 中）存储到栈帧中的位置 [rbp-24]。
        mov     eax, DWORD PTR [rbp-20] //从栈帧中读取 [rbp-20] 处的值（参数 a），并将其移动到 eax 寄存器中。eax 是返回值的寄存器。
        mov     DWORD PTR [rbp-4], eax //将 eax 中的值（即 a 的值）存储到 [rbp-4], 用于后续计算。
        mov     eax, DWORD PTR [rbp-24] //从栈帧中读取 [rbp-24] 处的值（参数 b），并将其移动到 eax 寄存器中。
        mov     DWORD PTR [rbp-8], eax //将 eax 中的值（即 b 的值）存储到 [rbp-8]，为后续计算做准备。
        mov     edx, DWORD PTR [rbp-4] //将 [rbp-4]（即 c 的值）加载到 edx 寄存器中，准备进行加法运算。
        mov     eax, DWORD PTR [rbp-8] //将 [rbp-8]（即 d 的值）加载到 eax 寄存器中，准备进行加法运算。
        add     eax, edx //将 edx 中的值（c）与 eax 中的值（d）相加，结果存储在 eax 中。此时 eax 中有 c + d 的值，即函数的返回值。
        pop     rbp //从栈中弹出之前保存的基指针值，恢复调用该函数之前的栈帧。
        ret //返回到调用该函数的位置，返回值存储在 eax 中。
main:
        push    rbp // 将当前基指针 (rbp) 压入栈中，以保存调用此函数之前的基指针值。
        mov     rbp, rsp //更新基指针 (rbp) 为当前堆栈顶指针 (rsp)，为新的栈帧准备空间。MOV用法：MOV DST SRC
        mov     esi, 1919810 //将整数 1919810 存储到寄存器 esi，这是add 函数的第二个参数。
        mov     edi, 114514 //将整数 114514 存储到寄存器 edi，这是 add 函数的第一个参数。
        call    add(int, int) //调用add函数
        mov     eax, 0
        pop     rbp
        ret
```

其中rbp和rsp和上文链接中的ebp和esp是类似的，只不过ebp是x86架构，而rbp是x86-64架构。`rsp`（栈指针寄存器）在 x86 和 x86_64 架构中是自动管理的，它始终指向当前栈顶的位置。每当进行入栈（push）或出栈（pop）操作时，这个寄存器的值会相应地更新。`rbp` 是一个寄存器，用于指向当前函数的栈帧的起始位置。

**栈帧的大小是由编译器在编译时自动确定的。编译器根据函数的局部变量、参数、返回地址以及其他需要存储的信息来计算栈帧的大小。这些信息影响了栈帧的布局和大小。**

在函数调用时，通常会将上一个函数的 `rbp` 值压入栈中，然后将其更新为当前的 `rsp`（栈顶指针）。

通常情况下，负偏移（如 `rbp-20`）用于访问局部变量，而正偏移（如 `rbp+20`）则用于访问函数参数。

- 每次执行 `push` 指令时，`rsp` 会先减去 8（在 64 位架构下，每次入栈 8 字节），然后将要压入的值写入新 `rsp` 指向的地址。
- 每次执行 `pop` 指令时，`rsp` 会先读取当前 `rsp` 指向的值，然后再加上 8（在 64 位架构下），以调整栈指针。



## 【19】STL各种容器分析

这个在`C++面经合集.md`里面都有总结，内容比较多，就不再粘过来了。其他那篇里没总结的内容放在这里。



## 【20】C++中有什么锁？

可以参考的链接：[C++锁（万字长文）：概念、不同锁实现、死锁现象+代码实例+预防+避免、加锁性能降低8种有效策略-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2481793)

| **锁类型**                      | **特点**                               | **优点**                       | **缺点**                              | **适用场景**                 |
| :------------------------------ | :------------------------------------- | :----------------------------- | :------------------------------------ | :--------------------------- |
| 互斥锁 (`std::mutex`)           | 简单的二进制锁，线程间互斥访问共享资源 | 实现简单、适用广泛             | 阻塞线程，可能导致上下文切换开销      | 共享资源需要严格互斥的场景   |
| 递归锁 (`std::recursive_mutex`) | 同一线程可以多次加锁，无需担心死锁     | 避免递归调用时死锁问题         | 性能略差于普通互斥锁                  | 递归函数需要加锁的场景       |
| 读写锁 (`std::shared_mutex`)    | 多线程可并发读取，但写操作独占         | 提高读操作多的场景下的并发性能 | 写操作需要独占锁，读多写少时性能最佳  | 数据读多写少的场景           |
| 自旋锁 (`std::atomic_flag`)     | 线程忙等待，不阻塞，适合短期锁         | 低延迟，无需上下文切换         | 忙等待消耗CPU资源，不适合长时间锁持有 | 短期锁定操作或实时性高的场景 |

==这个问题水很深，而且掌握的不好。暂时就只整理概念相关的内容，等其他面经刷到了更深入的问题再来整理吧。==



## 【21】简单题目合集

### （1）数组和链表的区别是什么？新增一个元素，数组和链表的区别？

| 特性          | 数组                                                         | 链表                                                   |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 存储方式      | 连续内存分配                                                 | 非连续内存分配，每个节点包含数据和指向下一个节点的指针 |
| 大小          | 固定大小，定义后无法更改                                     | 动态大小，可以根据需要扩展或收缩                       |
| 访问速度      | O(1)（随机访问，可以通过索引直接访问元素）                   | O(n)（需从头开始遍历，以找到特定元素）                 |
| 插入/删除时间 | O(n)（可能需要移动其他元素以保持顺序）                       | O(1)（只需调整指针即可）                               |
| 内存利用率    | 可能会浪费空间（如果分配的数组大于实际使用的元素）           | 更有效地使用内存                                       |
| 新增元素操作  | - 确保有足够的空间<br>- 如果没有空间，需要创建新数组并复制旧数据 | - 创建新节点并将其插入到适当位置                       |



### （2）指针和引用区别

| 特性     | 指针                                                   | 引用                                         |
| -------- | ------------------------------------------------------ | -------------------------------------------- |
| 定义方式 | 使用 `*` 符号进行声明                                  | 使用 `&` 符号进行声明                        |
| 可否为空 | 可以为空（可以不指向任何有效地址）                     | 不能为空，必须引用一个有效的对象             |
| 重新赋值 | 可以改变指针所指向的地址                               | 一旦初始化后，引用不能改变指向               |
| 含义     | 指针是一个变量，它保存了另一个变量的内存地址           | 引用是另一个变量的别名，与原变量共享内存地址 |
| 使用方法 | 使用指针需要对其进行解引用以获取或修改其指向的变量的值 | 引用可以直接使用，无需解引用                 |



### （3）二叉树的各种遍历

可以做一下这道题：[二叉树练习题（一） 二叉树的遍历-CSDN博客](https://blog.csdn.net/weixin_41611045/article/details/102057630).代码实现的话就是递归即可。这里给出一份中序遍历的代码：

```c++
class Solution {
public:
    void Traversal(TreeNode* node, vector<int>& res)
    {
        //左,根,右
        if(node==nullptr) return;
        Traversal(node->left, res);
        res.push_back(node->val);
        Traversal(node->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        Traversal(root,res);
        return res;
    }
};
```

以下是层序遍历的代码，有可能会考手撕：

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if(root==nullptr) return res;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> tmp;
            for(int i=0;i<size;i++)
            {
                TreeNode* cur = que.front(); 
                que.pop();
                tmp.emplace_back(cur->val);
                if(cur->left!=nullptr) que.push(cur->left);
                if(cur->right!=nullptr) que.push(cur->right);
            }
            res.emplace_back(tmp);
        }
        return res;
    }
};
```



## 【22】多继承的两个子类都实现了一个同名函数，具体会调用哪一个

在 C++ 的多继承中,如果两个基类(或中间派生类)实现了**同名函数**(无论是否为虚函数),且派生类没有覆盖该函数,则直接调用该函数会触发**二义性错误**。下面是一个二义性报错的例子：

```c++
class Base1 {
public:
    void func() {}  // 非虚函数
};

class Base2 {
public:
    void func() {}  // 非虚函数
};

class Derived : public Base1, public Base2 {};

int main() {
    Derived d;
    d.func();  // 编译报错:对成员 'func' 的请求不明确
}
```

**原因**:编译器无法确定调用 `Base1::func()` 还是 `Base2::func()`。解决方案是可以使用显式指定的方法，比如`d.Base1::func();  *// 调用 Base1 的版本*`。

对于虚函数的情况也是类似，如果同名函数是虚函数,且派生类未覆盖它，则依旧会报错:

```c++
class Base1 {
public:
    virtual void func() {}
};

class Base2 {
public:
    virtual void func() {}
};

class Derived : public Base1, public Base2 {};

int main() {
    Derived d;
    d.func();  // 编译报错:对成员 'func' 的请求不明确
}
```

不过，此时的解决方案就有两个：1.显式指定作用域 2.**让 `Derived`  override 该函数。**

- 针对方法2，在`Derived`类中加入`virtual void func() override {}`即可。



> 补充：如果基类通过**虚继承**共享同一祖先,且中间类覆盖了虚函数，也是不行的:
>
> ```c++
> class Base {
> public:
>     virtual void func() {}
> };
> 
> class Mid1 : virtual public Base {
> public:
>     void func() override {}  // 覆盖 Base::func()
> };
> 
> class Mid2 : virtual public Base {
> public:
>     void func() override {}  // 覆盖 Base::func()
> };
> 
> class Derived : public Mid1, public Mid2 {};
> 
> int main() {
>     Derived d;
>     d.func();  // 编译报错:对成员 'func' 的请求不明确，解决方案是统一在Derived类中再override虚基类中的虚函数。
> }
> ```





## 【23】关于RTTI（Run-Time Type Information）和 dynamic_cast 原理

现代C++中的四种CAST - 孙梓轩的文章 - 知乎
https://zhuanlan.zhihu.com/p/578828427

RTTI（Run-Time Type Information）是C++中的一种机制，用于在运行时获取对象的类型信息。实现RTTI主要包括两种操作符：`typeid` 和 `dynamic_cast`。

C++通过以下的两个操作提供RTTI：

（1）`typeid`运算符，该运算符返回其表达式或类型名的实际类型。

（2）`dynamic_cast`运算符，该运算符将基类的指针或引用安全地转换为派生类类型的指针或引用。这里的转换包括向上转换（子类转父类，总是可以的），向下转换（提供安全检查，不像`static_cast`转换总是成功的）。



`dynamic_cast` 是RTTI的一部分，用于在运行时进行安全的类型转换。**工作原理**：

- - `dynamic_cast` 依赖于虚函数表（vtable）来实现类型检查。
  - 当使用 `dynamic_cast` 进行转换时，C++运行时会检查对象的实际类型是否与目标类型兼容。
  - 如果转换成功，返回目标类型的指针或引用；如果转换失败，返回 `nullptr`（对于指针）或抛出 `std::bad_cast` 异常（对于引用）。

- **示例代码**：

```cpp
class Base {
public:
    virtual ~Base() {} // 必须有虚函数
};

class Derived : public Base {};

Base* basePtr = new Derived;
Derived* derivedPtr = dynamic_cast<Derived*>(basePtr); //向下转换
if (derivedPtr) {
    // 转换成功
} else {
    // 转换失败
}
```

**总结：** RTTI 是C++中的运行时类型信息机制，`dynamic_cast` 是RTTI的一部分，用于在运行时进行安全的类型转换。`dynamic_cast` 依赖于虚函数表来实现类型检查，确保转换的安全性。有比较大的性能开销。在Google的开发规范中，不建议在上线项目中使用RTTI，但是在单元测试中可以使用（比如测试工厂模式能否返回正确的子类）。



### （1）补充1：`typeid`的底层实现

`typeid` 是 C++ 中用于获取类型信息的运算符，其底层实现依赖于 RTTI（Run-Time Type Information）机制。RTTI 允许程序在运行时获取对象的类型信息，通常由编译器实现。`typeid`的底层实现包括：

1. **类型信息存储**：
   - 编译器为每个多态类型（包含虚函数的类）生成一个 `std::type_info` 对象，存储类型信息。
   - 这些对象通常保存在只读内存段中，程序运行时通过虚表（vtable）访问。

2. **虚表（vtable）**：
   - 多态类对象的虚表包含指向 `type_info` 对象的指针。
   - 调用 `typeid` 时，编译器生成代码从虚表中获取 `type_info` 对象。

3. **typeid 运算符**：
   - 对于多态类型，`typeid` 通过虚表获取 `type_info` 对象。
   - 对于非多态类型，`typeid` 在编译时直接返回对应的 `type_info` 对象。



### （2）补充2：Modern Cpp中的四种cast

1. **static_cast**：
   - 用于静态类型转换，通常在编译时进行类型检查。对于向下(`down`)转换总是成功的，并且不提供检查。效果和C风格的强制类型转换是一样的，需要编程者保证转换的安全性，既被转换的派生类和目标转换类型之间必须是继承派生关系；
   - 例如：将基类指针转换为派生类指针。

2. **dynamic_cast**：
   - 用于动态类型转换，通常在运行时进行类型检查。
   - 例如：将基类指针转换为派生类指针，并检查转换是否成功。

3. **const_cast**：
   - 用于去除或添加 `const` 或 `volatile` 修饰符。
   - 例如：将 `const int*` 转换为 `int*`。

4. **reinterpret_cast**：
   - 用于低级别的类型转换，通常不进行类型检查。
   - 例如：将指针转换为整数。



## 【24】Sort函数的具体实现是什么（以C++和C#为例）==（※）==

看一下这篇：[(99+ 封私信 / 82 条消息) 自己写的排序会比C#自带的排序快吗？ - 知乎](https://www.zhihu.com/question/472808760/answer/2093452888)。

这种排序叫做IntroSort，基本思路是这样的：

1. 一般情况下，使用前后双指针快排，以枢轴元素为界划分出两段，再递归排序。
2. 如果排序区间小于一定的阈值（一般是十几到小几十这个量级），快排的递归开销相对而言会比较大，于是使用插入排序。
3. 如果检测到递归层数过大，可以认为快排出了严重的划分不均问题。为了避免爆栈问题，或者快排再次划分不均导致复杂度退化为 $O(n^2)$，于是使用堆排序。
   - 注意，是**对当前递归处理的子区间应用堆排序**，并非对整个原始数据集重新进行堆排。

更为细节的部分，如果要复习的话可以去上面那个链接里面看。



## 【25】构造函数出现异常会发生什么？析构函数出现异常会发生什么？==（※）==

先来看一下C++当中的异常机制：[C++ 异常处理 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-exceptions-handling.html)

异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。

- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。
- **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。
- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：

```c++
try
{
   // 保护代码
}catch( ExceptionName e1 ) //如果用catch(...)，则表示catch块会用来处理try 块抛出的任何类型的异常
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。

接下来可以读一下这篇：[C++中构造函数和析构函数抛出异常问题-CSDN博客](https://blog.csdn.net/u012611878/article/details/78945586)



结论参考上一篇（在VS中测不出来,先背下来吧）：

> **构造函数可以抛出异常。**
>
> 1. **构造函数抛出异常的后果**：
>    - **析构函数不会执行**：对象未被完整构造，因此析构函数不会被调用。
>    - 成员变量的析构：
>      - **直接成员对象**（非指针）：若已构造完成，其析构函数会被调用。
>      - **动态分配的资源**（如指针成员）：需手动释放，否则内存泄漏。
> 2. **核心原则**：
>    - 使用RAII（如智能指针）可自动管理资源，避免手动释放。
>
> 
>
> **析构函数不能、也不应该抛出异常**：
>
> More Effective c++提出析构函数不能抛出异常的理由：
>
> - 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
> - 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
>
> 尽量不要在析构函数中抛出异常。如果要做异常处理的话，**一定要在析构函数内部捕获所有的异常。**



## 【26】C/C++中的`const char*`（==※==）

首先，注意下面的代码：

```c++
int main() {
	cout << ('\0' == 0) << endl; //1
	return 0;
}
```

也就是说，在C/C++中，char：`\0`被认为是跟0等价的。因此来看下面这段代码：
```c++
#include <cstdio>
#include <cstdlib>
#include <corecrt_memory.h>

int main() {
	char buf[64] = { 0 };  //重点考察 1.memcpy 2.'\0'和0是等价的
	const char* s1 = "genshin";
	const char* s2 = " impact";
	const char* s3 = "honkaiSR";
	memcpy(buf, s1, 7);
	memcpy(buf + 7, s2, 7);
	memcpy(buf + 15, s3, 7);

	printf("%s", buf);
	return 0;
}
```

输出结果应当为`genshin impact`，其中`memcpy(buf,s,length)`函数意味着把字符串s的长度为length的部分拷贝到buf当中。而`buf`数组的初始值为0，意味着最终buf中的内容应该为：

```
g  e  n  s  h  i  n  ' ' i  m  p  a  c  t  0  h  o  ...
0  1  2  3  4  5  6  7   8  9  10 11 12 13 14 15 16 ...
```

所以，当使用`printf("%s")`输出时，`char`数组中的0会被识别为`'\0'`，导致字符串读取结束，因此最终输出的结果为`genshin impact`，**不会输出**honkaiSR相关的内容。



## 【27】Happy Cpp合集

- （1）C++ string.find的坑：find结果是无符号整数，要用npos判断是否找到：[(99+ 封私信 / 82 条消息) 你见过最烂的代码长什么样子？ - 知乎](https://www.zhihu.com/question/265453795/answer/3119701570?utm_medium=social&utm_psn=1872981398660444164&utm_source=qq)
- 



# 操作系统篇

## 【1】操作系统进程和线程的区别？

> 参考链接：[操作系统之进程和线程（二者的区别，进程的状态切换、创建、终止、上下文切换）_进程上下文切换和线程上下文切换-CSDN博客](https://blog.csdn.net/u014454538/article/details/99330919)。
>
> - **进程（Process）是资源分配的基本单位，线程（Thread）是CPU调度的基本单位。**线程不拥有资源，但可以共享进程资源（如内存空间和文件描述符表）。同一进程中的线程切换，不会引起进程切换；不同进程中的线程切换，会引起进程切换。
> - 线程将进程的资源分和CPU调度分离开来。 以前进程既是资源分配又是CPU调度的基本单位，后来为了更好的利用高性能的CPU，将资源分配和CPU调度分开。因此，出现了线程。
> - 进程和线程的联系： 一个线程只能属于一个进程，一个进程可以拥有多个线程。线程之间共享进程资源。
>
> 比如：**进程和线程的实例：** 打开一个QQ，向朋友A发文字消息是一个线程，向朋友B发语音是一个线程，查看QQ空间是一个线程。QQ软件的运行是一个进程，软件中支持不同的操作，需要由线程去完成这些不同的任务。



## 【2】线程的通信方式有哪些？

> 可以参考的链接：[C++ 并发编程指南（10）线程间通信_c++ 线程间通信-CSDN博客](https://blog.csdn.net/cloud323/article/details/136620168)
>
> **线程通信就是当多个线程共同操作共享的资源时，互相告知自己的状态以避免资源争夺。**线程通信主要可以分为两种方式，分别为**共享内存**、**消息传递**。另外还有管道流的方式，使用较少，就不整理了。每种方式有不同的方法来实现：
>
> - （1）**共享内存**：共享内存是一种常见的线程间通信方式，多个线程可以访问和修改同一块内存区域中的数据。在C++中，全局变量、静态变量和堆上分配的对象都可以作为共享内存。为了避免数据竞争，需要使用同步原语，如互斥锁来保护共享数据的访问。例如，使用`std::lock_guard`和`std::mutex`来保护共享变量的访问。也可以使用**信号量**，信号量是一种同步原语，用于线程间的通信。它允许多个线程共享一个计数器，从而控制对资源的访问。
>   - 以及C++中提供了`volatile`关键词，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。**遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。**当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。
> - （2）**消息传递：**消息传递和管道是另一种线程间通信方式，它们允许线程通过发送和接收消息来交换信息。虽然C++标准库没有直接提供消息传递和管道的实现，但可以使用第三方库或自定义数据结构来实现。例如，使用`std::queue`和条件变量来实现一个简单的消息队列。**具体可以参考上面那个链接**。



## 【3】什么是死锁？死锁的必要条件

[C++锁（万字长文）：概念、不同锁实现、死锁现象+代码实例+预防+避免、加锁性能降低8种有效策略-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2481793)

**死锁（Deadlock）**是指两个或多个线程或进程因争夺资源而相互等待，导致所有参与者都无法继续执行的状态。

根据 **Coffman** 在 1971 年提出的理论，死锁的发生需要满足以下四个条件，这些条件同时成立时，系统可能进入死锁状态：

| **条件**                                   | **描述**                                                     |
| :----------------------------------------- | :----------------------------------------------------------- |
| **互斥（Mutual Exclusion）**               | 至少有一个资源是非共享的，某一时刻只能被一个线程或进程占用。 |
| **请求与保持/占有且等待（Hold and Wait）** | 线程已经持有资源，同时又请求新的资源，但未释放已有资源。     |
| **不可剥夺（No Preemption）**              | 已被分配的资源不能强制剥夺，只能由持有该资源的线程或进程主动释放。 |
| **循环等待（Circular Wait）**              | 存在一个线程或进程的循环等待链，链中的每个线程或进程都在等待下一个线程持有的资源。 |

下面通过一个C++多线程的例子，深入理解一下死锁：

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>

std::mutex mutex1;
std::mutex mutex2;

void threadFunction1() {
    std::cout << "Thread 1: Trying to lock mutex1...\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 确保线程顺序

    std::lock_guard<std::mutex> lock1(mutex1);
    std::cout << "Thread 1: Locked mutex1.\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    std::cout << "Thread 1: Trying to lock mutex2...\n";
    std::lock_guard<std::mutex> lock2(mutex2); // 可能导致死锁
    std::cout << "Thread 1: Locked mutex2.\n";
}

void threadFunction2() {
    std::cout << "Thread 2: Trying to lock mutex2...\n";

    std::lock_guard<std::mutex> lock2(mutex2);
    std::cout << "Thread 2: Locked mutex2.\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(120)); // 等待一段时间
    std::cout << "Thread 2: Trying to lock mutex1...\n";
    
    std::lock_guard<std::mutex> lock1(mutex1); // 可能导致死锁
    std::cout << "Thread 2: Locked mutex1.\n";
}

int main() {
    std::thread t1(threadFunction1);
    std::thread t2(threadFunction2);

    t1.join();
    t2.join();

    std::cout << "Main thread: Finished execution.\n";
    return 0;
}
```

在这个例子中：

- mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 <mutex> 头文件中，所以如果你需要使用 std::mutex，就必须包含` <mutex> `头文件。
- `std::lock_guard`，与 Mutex RAII 相关，方便线程对互斥量上锁
- **mutex1 和 mutex2**：两个互斥资源。
- **死锁场景**：线程 1 持有 `mutex1`，等待 `mutex2`；线程 2 持有 `mutex2`，等待 `mutex1`。

上述程序的输出结果为：

```c++
Thread 1: Trying to lock mutex1...
Thread 2: Trying to lock mutex2...
Thread 2: Locked mutex2.
Thread 1: Locked mutex1.
Thread 2: Trying to lock mutex1...
Thread 1: Trying to lock mutex2...
```

主函数没有输出最后一句，说明发生了死锁。



### （1）如何避免死锁？

[C++锁（万字长文）：概念、不同锁实现、死锁现象+代码实例+预防+避免、加锁性能降低8种有效策略-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2481793) 这篇文章里有更为详细的介绍。

【推荐阅读】[5.4 怎么避免死锁？ | 小林coding](https://xiaolincoding.com/os/4_process/deadlock.html#环路等待条件)

实际上，由于死锁有四个必要条件，那么实际上只要破坏其中一个条件即可解除/避免死锁。最常用的方法是**使用资源有序分配法**，从而破坏循环等待的条件。

- 资源有序分配法：线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。**也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。**



### （2）银行家算法

[操作系统面试题 | 小林coding](https://xiaolincoding.com/interview/os.html#讲一下银行家算法)

系统发生死锁是很正常的，我们需要主动去预防死锁，即进行有序的资源分配，使用**银行家算法**。**银行家算法是最有代表性的避免死锁的算法**。

> 为什么叫银行家算法呢？就是这个算法的逻辑**很像银行放贷的逻辑，也就是尽可能避免坏账的出现**。



**银行家算法的核心思想，**就是在**分配给进程资源前，首先判断这个进程的安全性**，也就是预执行，判断分配后是否产生死锁现象。如果系统当前资源能满足其执行，则尝试分配，如果不满足则让该进程等待。通过不断检查剩余可用资源是否满足某个进程的最大需求，如果可以则加入安全序列，并把该进程当前持有的资源回收；不断重复这个过程，看最后能否实现让所有进程都加入安全序列。**安全序列一定不会发生死锁，但没有死锁不一定是安全序列。**



银行家算法的业务逻辑如下：

- **不负荷执行**：一个进程的最大需求量不超过系统拥有的总资源数，才会被接纳执行。
- **可分期**：一个进程可以分期请求资源，但总请求数不可超过最大需求量。
- **推迟分配**：当系统现有资源数小于进程需求时，对进程的需求可以延迟分配，但总让进程在有限时间内获取资源。

看着比较抽象，直接给个例子。假如系统中有三类互斥资源 R1、R2、R3，可用资源数分别是 9、8、5，在指定时刻有 P1、P2、P3、P4 和 P5 这五个进程，这些进程的对三类互斥资源的最大需求量和已分配资源数如下表所示，那么系统如何先后运行这五个进程，不会发生死锁问题？

| 进程 | 最大需求量（分别为R1 R2 R3） | 已分配资源数（分别为R1 R2 R3） |
| ---- | ---------------------------- | ------------------------------ |
| P1   | 6 5 2                        | 1 2 1                          |
| P2   | 2 2 1                        | 2 1 1                          |
| P3   | 8 1 1                        | 2 1 0                          |
| P4   | 1 2 1                        | 1 2 0                          |
| P5   | 3 4 4                        | 1 1 3                          |

这个题目的分析过程和答案可以看本节开始的那个链接。注：那个链接里的答案中间计算结果感觉不太对，理解一下过程就行，应该也不会让做题。



## 【4】进程的通信方式有哪些？

可以参考：[5.2 进程间有哪些通信方式？ | 小林coding](https://xiaolincoding.com/os/4_process/process_commu.html#管道)。先读一下这篇链接，对于这道题目会有更好的理解。

由于每个进程的用户空间都是独立的，不能相互访问，**这时就需要借助内核空间来实现进程间通信**，原因很简单，每个进程都是共享一个内核空间。

- （1）内核提供了不少进程间通信的方式，其中最简单的方式就是**管道**，管道分为「匿名管道」和「命名管道」.
  - **匿名管道**：没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「<code>|</code>」就是匿名管道，通信的方式是**单向的**，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道。以及<strong>匿名管道是只能用于存在父子关系的进程间通信</strong> ，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
  - **命名管道**：突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核中**，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循<strong>先进先出</strong>原则，不支持 lseek 之类的文件定位操作。
- （2）**消息队列**：克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟<strong>每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。</strong>
- （3）**共享内存**：可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，**它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，**享有最快的进程间通信方式之名。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。
  - 此时，就可以用**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。当然，信号量不仅可以用于实现互斥访问，还可以用来实现**进程同步（上述链接中关于信号量的介绍不错，值得一看）。**
  - 信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 <strong>P 操作和 V 操作</strong>
- （4）**信号**：与信号量名字很相似的叫**信号**，但其实两者并不相关，信号是一种**异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，<strong>进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号</strong>。有两个信号是应用进程无法捕捉和忽略的，即`SIGKILL`和`SIGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。
- （5）**socket**：前面说到的通信机制，都是工作于同一台主机。如果要与不同主机的进程间通信，那么就需要 Socket 通信了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

注意：**针对线程间的通信方式**，由于同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步。

- 互斥：可保证任意时刻只有一个线程访问共享资源；
- 同步：可保证线程A应该在线程B之前执行；



## ==【5】浮点数存储原理，IEEE浮点数原理，定点数原理==



## ==【6】有没有遇到过因为内存问题导致程序崩溃的情况，怎么解决的？如何调试分析？==



## ==【7】同一进程间的线程哪些共享哪些不共享？==



# 游戏算法篇

## 【1】介绍下A*算法。`A*`算法的缺点

> （1）A* 算法是一种用于路径寻找和图形遍历的启发式搜索算法。它结合了 Dijkstra 算法的最佳优先策略和贪婪最佳优先搜索，使用一个评价函数 `f(n) = g(n) + h(n)`，其中：
>
> - `g(n)`：从起点到当前节点 n 的实际成本。
> - `h(n)`：当前节点 n 到目标节点的估计成本（启发式）。
>
> **具体算法的细节如果有额外问再做回答。**大致思路是维护一个`openList`和`closeList`，每次从`openList`中取出`F`值最小的格子，放入`closeList`中，并把周围符合要求的（比如非障碍物，非`closeList`中的点）放入到`openList`中，如果周围点的`G`值可以更新（此时会在`openList`里面），则会更新为更小的`G`值（当然，F也会顺便更新）,直到找到终点或者`openList`为空（表示没有可行路径）。
>
> 该算法确保尽量找到最短路径（其实，启发式函数`H`很可能会导致寻路结果不是最短路径）并且高效性相对较好。
>
> （2）A*算法的缺点：
>
> - **计算资源消耗**：在复杂环境中，A* 可能需要大量记忆体和计算力（想象一下，1000*1000的网格），因为它会维护多个开放和关闭列表。
> - **启发式函数依赖**：性能高度依赖于选择合适的启发式函数，不同的选择可能导致效率降低。
> - **不太适用于动态环境和复杂地形**：如果环境不断变化，A* 需要重新计算路径，造成额外开销（比如移动的NPC）。同时，斜坡，高低差等地形不太好处理。
> - 锯齿形路径：很多时候会导致路径的不自然。
>
> （3）`A*`算法本身并未被淘汰，但在纯Grid环境中使用A*会导致上述的几个问题。现在游戏中常用的应该是`Navmesh`的寻路，这在其他题目中会专门介绍。



### （1）A*算法和Dijkstra算法的区别

A* 算法可以被视为在 Dijkstra 算法的基础上引入了启发式元素 ( H ) 的一种改进。通过合理选择 ( H )，A* 能够比 Dijkstra 更快速地找到最短路径。选择合适的启发式函数对于 A* 算法的性能至关重要。这里给出一些准则：

- 如果选择的启发式函数过于乐观（低估实际成本，可以思考极限情况下H=0），A* 算法可能会变得与 Dijkstra 算法一样慢，因为它会探索过多的节点。
- 如果启发式函数过于悲观（高估实际成本），则可能导致 A* 算法无法找到最优路径。想象一下H项远大于G，那么就会退化为贪婪最佳优先搜索算法。



## 【2】快速排序的原理和时间复杂度

> 在排序算法对应的章节中，有对快排进行介绍。
>
> - （1）基本思路：找一个`pivot`，通常选中间或者随机元素（避免最坏情况），然后做`partition`操作，将小于基准的元素移到左侧，将大于基准的移到右侧，基准归为到最终位置，然后对左右子数组递归重复上述过程。
> - （2）快速排序的平均时间复杂度为$O(nlogn)$，最坏的时间复杂度是$O(n^2)$，是不稳定的排序；
>
> \PrepareForWorkNotes\Algos\算法笔记\排序算法专题.md
>
> 补充：\PrepareForWorkNotes\2025寒假\Y\note\知识点\快排补充\快排 排序算法 快速排序 补充.md



# 设计模式篇

## 【1】介绍一下单例模式

> 这里可以引导说一下Unity中实现的单例模式，毕竟没有实际用C++写过单例模式的代码。大概有几种策略：
>
> - （1）对于继承自Monobehavior的类，可以手动挂载/脚本自动挂载（`AddComponent`）在场景中的物体上。在单例类中声明**私有静态变量保证唯一实例。**在`Awake`函数中检查实例是否存在，如果存在则销毁当前对象；若不存在则赋值当前实例，并可以选择调用`DontDestoryOnLoad`保持跨场景的有效；可以设置静态属性`Instance`提供对单例的安全访问。
> - （2）对于非继承于`Monobehavior`的类，只需要正常在`GetInstance`的时候判断是否为空，为空的话`new`出来一份即可。
>
> 额外补充的话，可以提到**单例模式**中的饿汉式和懒汉式。具体可以看这篇：[【C++】C++ 单例模式总结（5种单例实现方法）_单例模式c++实现-CSDN博客](https://blog.csdn.net/unonoi/article/details/121138176)。简要概括一下：
>
> - 懒汉式：系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。这种方式要考虑线程安全（可以使用**互斥锁**）。
> - 饿汉式：系统一运行，就初始化创建实例，当需要时，直接调用即可。这种方式本身就线程安全，没有多线程的线程安全问题。
>
> 补充：懒汉式的互斥锁写法如下（C++）：
>
> ```c++
> static std::shared_ptr<Singleton> singleton = nullptr;
> static std::mutex singletonMutex;
> 
> std::shared_ptr<Singleton> Singleton::getSingleton() {
>     if (singleton == nullptr) { //这个叫双检锁，外层的==nullptr判空是为了防止每次调用getSingleton都加锁，造成性能问题
>         std::unique_lock<std::mutex> lock(singletonMutex);
>         if (singleton == nullptr) {
>             volatile auto temp = std::shared_ptr<Singleton>(new Singleton());
>             singleton = temp;
>         }
>     }
>     return singleton;
> }
> ```
>
> - 之所以使用`shared_ptr`来保存单例而不是`unique_ptr`，**是因为`unique_ptr `单例对象不能被多个线程共享**。`shared_ptr`保存的实例可以被多个线程共享，**具体的在智能指针专题中有额外介绍。**



### （1）如何从构造函数的角度处理单例模式new一个新对象的问题

- 省流版答案：将构造函数设置为私有构造函数（放到private访问修饰符下面即可）。同时，**禁用掉拷贝构造函数和赋值运算符，对外只保留一个`getInstance()`的接口，同时如果是懒汉式在生成实例时需要考虑互斥锁。**

C++单例模式的各种写法可以看这里：[C++ 单例模式的各种坑及最佳实践 - Zijian/TENG - 博客园](https://www.cnblogs.com/tengzijian/p/17473248.html)



### （2）一份C++11 之后的单例模式最佳实践

这个版本利用局部静态变量来实现单例模式。最早由 C++ 大佬、Effective C++ 系列的作者 Scott Meyers 提出，因此也被称为 Meyers’ Singleton。特点是**最简洁，线程安全，且没有额外的指针。**

> "This approach is founded on C++'s guarantee that local static objects are initialized when the object's definition is first encountered during a call to that function." ... "As a bonus, if you never call a function emulating a non-local static object, you never incur the cost of constructing and destructing the object."
> —— Scott Meyers

```c++
class Singleton {
   public:
    static Singleton& getInstance() {
        static Singleton inst;
        return inst;
    }

    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

   private:
    Singleton() = default;
};
```



## 【2】介绍一下工厂模式

顺便问了一下deepseek关于工厂模式在游戏中的应用，放在了附录文件夹——工厂模式游戏应用.md文件中，可以去那里再复习一下应用场景。

> ## 工厂模式
>
> 工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为**简单工厂模式**和**工厂方法模式**，根据工厂的抽象程度可分为工厂方法模式和**抽象工厂模式**。该模式用于封装和管理对象的创建，是一种创建型模式。
>
> 具体看**https://www.cnblogs.com/yssjun/p/11102162.html**
>
> ### 简单工厂模式
>
> ![img](assets/1419489-20190628144601084-563759643.png)
>
> ### 工厂方法模式
>
> 和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂
>
> ![img](assets/1419489-20190628154133368-906051111.png)
>
> ### 抽象工厂模式
>
> 上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品**Phone**（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。
>
> ![img](assets/1419489-20190628164001258-637961514.png)
>
> 注：
>
> - （1）上面介绍的三种工厂模式有各自的应用场景，实际应用时能解决问题满足需求即可，可灵活变通，无所谓高级与低级。
> - （2）无论哪种模式，由于可能封装了大量对象和工厂创建，新加产品需要修改已定义好的工厂相关的类，因此对于产品和工厂的扩展不太友好，利弊需要权衡一下；



## 【3】其他设计模式了解

可以参考这个链接：[重访设计模式 · 游戏设计模式](https://gpp.tkchu.me/design-patterns-revisited.html)

- 命令模式：将请求封装成对象，支持请求的排队、撤销、重做；常见于**操作回放、技能队列**，每个命令对象可以实现`Execute`和`Undo`方法，在回合制游戏中可以用于实现“撤销上一步”的功能；
- 享元模式
- 观察者模式：常见的业务需求为成就解锁、UI更新、玩家死亡逻辑等。任务系统很多时候也需要。使用事件/委托实现解耦。**需要注意事件的订阅与取消订阅，避免内存泄漏。**
- 状态模式：将对象的行为封装到不同的状态类中，通过切换状态改变行为；**常见于实现角色状态机以及游戏流程控制（主菜单、战斗中、暂停等游戏阶段）；**每个状态实现统一接口`IState`。
- **策略模式：**定义一系列算法，使其可以互相替换，且算法的变化独立于客户端。
  - 常见于比如AI行为：不同敌人使用不同的移动策略（巡逻、追击、逃跑）
  - 技能系统：同一技能槽支持多种释放方式：点击、长按、连击
  - 实现方法：通过接口定义策略，运行时动态切换具体实现，适用于需要频繁调整或扩展算法的场景。可以参考[Unity游戏开发——策略模式 - 知乎](https://zhuanlan.zhihu.com/p/86951119)
- **组合模式：**将对象组合成树形结果，以同一的方式处理单个对象和对象组合。比如：
  - UI系统中嵌套的界面元素（如面板包含按钮、文本、图片）
  - 技能树：复杂技能节点的递归遍历（如天赋树）
  - 细节：组件接口定义`Add`，`Remove`和`Execute`方法，简化递归操作，但需注意父子关系的循环引用问题。参考附录中的`设计模式补充.md`文件
- 原型模式：类似于Unity的prefab
- **装饰器模式：**动态地为对象添加额外功能，通过嵌套包装代替继承。比如，为武器添加火焰/冰冻等特效，为角色叠加各种buff/debuff。
  - 实现细节上，装饰器类与被装饰对象实现相同接口，层层嵌套增强功能。装饰器模式具备灵活扩展性，但需要注意装饰顺序对结果的影响。
  - 可以参考：附录中的`设计模式补充.md`文件
- 对象池模式：不做过多介绍了
- 组件模式：不过多介绍了
- 单例模式
- 工厂模式



# 计算机网络篇

High Level层面过一下计网：[(99+ 封私信 / 82 条消息) 有了 IP 地址，为什么还要用 MAC 地址？ - 知乎](https://www.zhihu.com/question/21546408/answer/2303205686)

首先，关于TCP协议，非常建议看这篇文章先复习一下：[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-基本认识)

这部分内容在Games104中也有所讲解，可以去这里回顾一下：[Voices from Community - T-shirt Style](https://games-1312234642.cos.ap-guangzhou.myqcloud.com/course/GAMES104/GAMES104_Lecture18.pdf)以及[Network Synchronization](https://games-1312234642.cos.ap-guangzhou.myqcloud.com/course/GAMES104/GAMES104_Lecture19.pdf)。目标是照着PPT可以大概说出讲解的内容，忘了的话可以去B站回顾Games104的课程。



## 【1】TCP 三次握手与四次挥手

由于TCP是面向连接的协议，所以TCP在使用前一定会**建立连接**，而建立连接是通过三次握手来进行的。这里还是给出链接：[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-三次握手过程是怎样的)，写的不错。有一些衍生问题，可以回顾，答案都在链接中：

- （1）三次握手的过程是什么样的？
- （2）为什么是三次握手，而不是两次或者四次？
- （3）第一次，第二次，第三次握手丢失的情况，会发生什么？
- （4）TCP四次挥手的过程是什么样的？
- （5）为什么需要四次挥手？可以变成三次么？[4.22 TCP 四次挥手，可以变成三次吗？ | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_three_fin.html)
- （6）第一、二、三、四次挥手丢失了会发生什么？
- （7）四次挥手的时候，为什么需要TIME_WAIT状态？
- （8）如果已经建立了连接，但是客户端突然出现故障了怎么办？（考察：TCP保活机制）
- （9）如果已经建立了连接，但是服务端的进程崩溃会发生什么？（考察：依旧会发生四次挥手）



## 【2】TCP协议和UDP协议的区别？分别的应用场景？

题目答案来自小林coding：[4.1 TCP 三次握手与四次挥手面试题 | 小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#udp-和-tcp-有什么区别呢-分别的应用场景是)

这个网站不让复制，复习的时候可以点进去复习，这里整理一些重点内容：

> 以下是 TCP 协议和 UDP 协议的主要区别，以表格形式展示：
>
> | 特性       | TCP (传输控制协议)                          | UDP (用户数据报协议)               |
> | ---------- | ------------------------------------------- | ---------------------------------- |
> | 连接类型   | 面向连接                                    | 无连接                             |
> | 数据可靠性 | 提供可靠的数据传输 (重传机制)               | 不提供可靠性                       |
> | 数据顺序   | 保证数据按顺序到达                          | 不保证数据顺序                     |
> | 流量控制   | 支持流量控制                                | 不支持流量控制                     |
> | 拥塞控制   | 提供拥塞控制                                | 不提供拥塞控制                     |
> | 数据包大小 | 最大 65,535 字节（含头部）                  | 最大 65,507 字节（不含头部）       |
> | 头部开销   | 20 字节                                     | 8 字节                             |
> | 使用场景   | 适用于需要可靠性和顺序的应用 (如 HTTP、FTP) | 适用于实时应用 (如 VoIP、视频会议) |
> | 性能       | 较慢，因建立连接和重传机制                  | 较快，无需连接建立和维护           |
>
> ### 总结
>
> - **TCP**：可靠传输（数据不丢失，顺序一致）、面向连接、流量控制、拥塞控制。适合需要顺序和完整性的场景。
>   - 缺点：延迟较高（重传机制导致），且报文头部开销较大（20字节的头部）
> - **UDP**：不可靠、无连接、适合实时传输，低延迟；
>   - 缺点：需要自行处理丢包、乱序等问题。
>
> 注：TCP 和 UDP 的头部不需要包含 IP 地址，因为该信息已在网络层的 IP 数据包中处理。只需通过端口号来区分不同应用程序的通信，这样既能简化协议设计，又能提高效率。
>
> ## 应用场景举例
>
> - 优先使用TCP：
>
>   - 需要严格可靠性的业务：
>     - 如账号登陆/支付系统
>     - 回合制游戏中，每一步操作的顺序严格保证；
>     - 排行榜/成就同步：数据一致性至关重要
>
>   - 对延迟不敏感的场景：比如游戏内邮件系统、配置表/资源更新。
>
> - 优先使用UDP的场景：
>
>   - 实时性要求高的操作
>     - 比如FPS游戏，MOBA游戏，赛车/格斗游戏。**注意，这里可能是考察的地方，因为UDP不可靠，所以纯用UDP可能会导致丢包乱序问题，需要自行处理，这时就可以说KCP协议了，见下。**
>   - 高频但允许少量丢包的数据：语音聊天、环境特效同步（如天气变化）等。
>
> 现代游戏通常使用混合协议策略，根据数据类型选择最优方案，下面会提到的KCP协议灵活度较高，有性能优势，很多实时游戏会使用KCP作为首选解决方案。



## 【3】（了解）KCP协议（==了解的还不够好，等学完TCP其他知识再回来整理==）Kcp有什么问题需要优化？

可以参考的链接：[GitHub - skywind3000/kcp: :zap: KCP - A Fast and Reliable ARQ Protocol](https://github.com/skywind3000/kcp)。以及对应的一些解读：[在网络中狂奔：KCP协议 - 知乎](https://zhuanlan.zhihu.com/p/112442341)

原理：

- **基于UDP的可靠传输协议**，通过改进重传策略和拥塞控制，提供比TCP更低的延迟。

核心优化：

- **快速重传：**无需等待超时，通过重复ACK立刻重传丢失包；与TCP相同，都是通过累计确认实现的，比如发送端发送了1，2，3，4，5几个包，然后收到远端的ACK：1，3，4，5，当收到ACK = 3时，KCP知道2被跳过1次，收到ACK = 4时，知道2被跳过了2次，此时可以认为2号丢失，不用等超时，直接重传2号，大大改善了丢包时的传输速度。
- **超时重传**：TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖，而KCP启动快速模式后不x2，只是x1.5（实验证明1.5这个值相对比较好），提高了传输速度。
  - 在 TCP 协议中，RTO 指的是 "Retransmission Timeout"，即重传超时时间。它是用来确定在发送数据后，发送方等待确认（ACK）响应的时间长度。如果在这个时间内没有收到确认，发送方会认为数据包可能丢失，并触发重传机制。

适用场景：**需要可靠传输但无法忍受TCP延迟的场景。**

- 比如《原神》使用了KCP协议，可能用于战斗同步：技能命中判定需要可靠且实时。
- 移动端弱网环境：KCP在网络不够好的情况下表现优于TCP。



## 【4】帧同步和状态同步

参考链接：[【网络同步】浅析帧同步和状态同步 - 知乎](https://zhuanlan.zhihu.com/p/357973435)。这里Games104也有讲，可以在忘了的时候回去复习一下。

> ## 一、帧同步
>
> 《王者荣耀》中采用的主要应该就是帧同步。在初始化的时候，要保证每个客户端的状态都是高度一致的。
>
> ### 1.基本原理
>
> - 帧同步的战斗逻辑在客户端
> - 在帧同步下，通信就比较简单了，服务端只转发操作，不做任何逻辑处理。
> - 客户端按照一定的帧速率（理解为逻辑帧，而不是客户端的渲染帧）去上传当前的操作指令，服务端将操作指令广播给所有客户端，
> - 当客户端收到指令后执行本地代码，如果输入的指令一致，计算的过程一致，那么计算的结果肯定是一致的，这样就能保证所有客户端的同步，这就是帧同步。
>
> ### 2.帧同步缺陷
>
> - 由于帧同步战斗逻辑都在客户端，服务器没有验证，带来的问题就是**外挂**的产生（加速、透视、自动瞄准、数据修改等）
> - 网络条件较差的客户端会影响其他玩家的游戏体验。（优化方案：乐观帧锁定、渲染与逻辑帧分离、客户端预执行、[指令流水线](https://zhida.zhihu.com/search?content_id=167679029&content_type=Article&match_order=1&q=指令流水线&zhida_source=entity)化、操作回滚等）
> - 不同机器浮点数精度问题（解决方案：制作Look up table求解比如$e^x$，或者使用定点数）、容器排序不确定性、RPC时序、随机[数值计算](https://zhida.zhihu.com/search?content_id=167679029&content_type=Article&match_order=1&q=数值计算&zhida_source=entity)不统一
>   - 尽量把游戏中确切的业务需求做到一致性，类似渲染的话要求没那么高。
>
> ### 3.**优化方案**
>
> ![image-20250205193551997](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250205193551997.png)
>
> 对应[18.网络游戏的架构基础 (Part 2) | GAMES104-现代游戏引擎：从入门到实践_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1HN4y157Zq?spm_id_from=333.788.videopod.sections&vd_source=f0e5ebbc6d14fe7f10f6a52debc41c99) 20分钟左右的地方。
>
> 补充：**乐观帧锁定方法**（跟上面的方法有点像）
>
> 针对传统严格帧锁定算法中网速慢会卡到网速快的问题，实践中线上动作游戏通常用**“定时不等待”的乐观方式，在每次Interval时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新**：
>
> 1. 单个用户当前键盘上下左右攻击跳跃是否按下用一个32位整数描述，服务端描述一局游戏中最多8玩家的键盘操作为：int player_keyboards[8];
> 2. 服务端每秒钟20-50次向所有客户端发送更新消息（包含所有客户端的操作和递增的帧号）：
> 3. update=（FrameID，player_keyboards）
> 4. 客户端就像播放游戏录像一样不停的播放这些包含每帧所有玩家操作的 update消息。
> 5. 客户端如果没有update数据了，就必须等待，直到有新的数据到来。
> 6. 客户端如果一下子收到很多连续的update，则快进播放。
> 7. 客户端只有按键按下或者放开，就会发送消息给服务端（而不是到每帧开始才采集键盘），消息只包含一个整数。服务端收到以后，改写player_keyboards。
>
> ### 4.帧同步总结
>
> **帧同步的优点：**
>
> - （1）低带宽，仅仅发送指令；
> - （2）很高的开发效率，就好像单人游戏开发一样；
> - （3）精准的动作/碰撞检测（我的理解是因为逻辑是在客户端算的，所以动作和伤害判定都会很准确）；
> - （4）很容易制作观战和回放的功能；
>
> **帧同步的缺点：**
>
> - （1）保持各个客户端的一致性是非常难的问题；
> - （2）难以解决外挂问题，因为帧同步都在客户端算，相当于客户端掌握所有游戏信息，很容易做出那种消除战争迷雾的外挂；
> - （3）如果断线重连的时间过长，中间的状态不太好追赶（因为太多了）；
>
> 
>
> ##  二、状态同步
>
> 大部分的MMORPG，生活类游戏都使用状态同步。
>
> **状态同步顾名思义就是同步各个客户端的状态，保证每一次操作后的状态是一致的。**通过开发服务端程序，把用户的操作作为输入实时上传到服务端，服务端通过计算返回结果给各个客户端，这样的过程就是状态同步。比如说玩家A开了一枪，那么A会给服务器发送自己开枪的报文，服务器确认后会转发给所有其他的客户端，这样其他客户端中的玩家A（叫做Replicated Player）就会同步开枪的状态，从而开枪。同时，如果这时服务器计算出了玩家A这一枪打中的玩家B，那么这个事件也会被同步给所有客户端。**游戏状态的计算是在服务器端的。**
>
> **状态同步的一个优势在于，可以只同步客户端的ROI（Region of Interest）区域。**
>
> ### 1. 基本原理
>
> - **状态同步的战斗逻辑在服务端**
>
> - 在状态同步下，客户端更像是一个服务端数据的表现层
>
> - 一般的流程是
>
> - - 客户端上传操作到服务器，
>   - 服务器收到后计算游戏行为的结果，然后以广播的方式下发游戏中各种状态，
>   - 客户端收到状态后再根据状态显示内容。
>
> - 用示意图表示如下：
>
> - ![img](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/v2-df2089bc7dd3b47107d26df5535fd108_r.jpg)
>
> - 如今的状态同步有：增量同步、RPC（[远程过程调用](https://zhida.zhihu.com/search?content_id=167679029&content_type=Article&match_order=1&q=远程过程调用&zhida_source=entity)）两种同步手段。
>
> - 目前状态同步多用于CS架构，客户端通过RPC向服务器发送指令信息，服务器通过属性同步（增量状态同步）向客户端发送各个对象的状态信息。我们可以才有**预测回滚、延迟补偿、插值等优化方式**。这些在Games104中可以复习到。
>
> - ### 2.2 状态同步缺陷
>
> - - 状态同步做回放系统的话会是个灾难。
>   - 延迟过大、客户端性能浪费、服务端压力大
>   - 对带宽的浪费。对于对象少的游戏，可以用快照保存整个游戏的状态发送，但一旦数量多起来，数量的占用就会直线上升。（优化：增量快照同步，协议同步指定数据）
>
> - 
>
> - ## 帧同步和状态同步对比
>
> - 参考这一篇下半部分：[【网络同步】浅析帧同步和状态同步 - 知乎](https://zhuanlan.zhihu.com/p/357973435)
>
> - - 最大的区别就是**战斗核心逻辑写在哪**？状态同步的战斗逻辑在服务端，帧同步的战斗逻辑在客户端。
>
> - | 属性                                       | 帧同步（LockStep）                                           | 状态同步                                                     |
>   | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
>   | 确定性                                     | 严格确定                                                     | 允许小误差，定时纠正误差数据                                 |
>   | 表现与响应速度                             | 传统严格帧锁定要等其他客户端消息全部到达，响应比较慢；乐观帧锁定可以做到本地立刻响应，但是需要回滚的时候，体验就没那么好了 | 一般会做预测，可以做到立刻响应。不做预测的话，响应时间是一个往返时间（RTT） |
>   | 带宽与流量                                 | 带宽随人数增加而增加，不适合MMO                              | 需要发送各种状态数据，带宽占用比较高。可以通过压缩、裁剪、增量等方式优化。人数较少时候不如帧同步省流量 |
>   | 网络延迟适应性                             | 要求较低的延迟。如果延迟较高，所有玩家体验都不好。即使采用乐观帧锁定优化，高延迟下也容易产生卡顿 | 适应性较高，方便做各种插值优化。当然高延迟下，也容易产生位置突变 |
>   | 开发难度                                   | 初期开发减法，框架容易实现，但是后期解决bug和完善系统很困难。比如浮点数、随机数、执行顺序导致计算结果不一致，问题很难排查（排查思路可以是计算各个值的checksum） | 框架比较复杂，客户端服务端各一套代码，每个功能都需要客户端服务端联调。问题定位比较容易。也会出现时序问题 |
>   | 玩家数量                                   | 适合少量的玩家，比如ACT、MOBA                                | 可多可少                                                     |
>   | 跨平台                                     | 不适合跨平台，会有浮点数问题，可以用定点数来将误差控制在一个可接受范围，同时可以定时纠正结果 | 适合。有权威服务器                                           |
>   | 反外挂                                     | P2P架构不适合反外挂，如果引入战斗服务器来校验各个客户端结果，可以解决常见外挂，但是透视和全图视野防不了 | 与服务器加入校验机制，可以起到比较好的反外挂效果。但是一样防不了透视外挂 |
>   | 中途加入和断线重连                         | 比较复杂。可以在断线的时候，通过快捷播放服务器同步的帧数据来快速跟上游戏 | 容易。由于实时记录了各个对象的状态信息，所以重连的时候，直接创建这些对象，并同步信息即可 |
>   | 性能（客户端）                             | 客户端要跑完整逻辑，还要执行渲染逻辑，开销比较大             | 可以灵活优化，客户端跑较少逻辑                               |
>   | 回放（离线）                               | 本身收集了所有玩家的输入信息进行逻辑推进，天然支持回放，且回放文件比较小 | 可以支持回放，但是逻辑比较复杂，需要不断记录状态信息，同时回放时候需要读取合适的时间。回放文件大 |
>   | 回放（实时）（**有些存疑，这条不太用看**） | 比较复杂，客户端需要本地对全场状态进行序列化，才能回到目标时间。播完回放后还需要加速追上实时游戏状态 | 相对容易，可以方便的记录快照信息，并按照录制内容随时播放     |

下图是一些帧同步和状态同步的游戏例子：

![img](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/v2-872213aa1932af45a7d5b39a16ee6f71_r.jpg)



## ==【5】状态同步有哪些优化技术？==

> 这个问题是接在上一个问题之后的，在上一个问题中对帧同步和状态同步有了一个基本的认知，但有一个考察点在于对状态同步更细致一些的考察（关于如何做优化），因此整理在这里。



## 【6】如何实现可靠UDP？



## 【7】RPC 远程过程调用

**RPC（Remote Procedure Call）**：远程过程调用,是一种计算机通信协议，允许程序像调用本地方法一样调用远程服务器的函数，底层隐藏了网络通信细节。基本原理如下：

- （1）**客户端调用**：客户端程序调用一个本地代理（stub），这个代理负责将调用转换为远程调用。调用的参数被打包并准备发送。
- （2）**打包参数**：本地代理将参数**序列化**（也称为编组，marshalling），将数据结构转换为可以通过网络传输的格式。
- （3）**发送请求**：序列化的数据通过网络发送到服务器的代理。这个过程可能涉及底层网络协议（如 TCP 或 UDP）的使用。
- （4）**服务器接收**：服务器端的代理接收到请求后，进行反序列化（unmarshalling），将数据转换回原始格式，并调用相应的服务或方法。
- （5）**执行服务并返回结果，客户端接收**：服务器执行所请求的方法，并生成返回结果。结果被序列化并发送回客户端的代理。客户端的代理接收到结果后，将其反序列化并返回给调用的客户端程序。

一个RPC调用的例子如下：

```python
# 伪代码，展示RPC用法,
result = rpc_client.call("PlayerServeice.level_up", player_id=1001, exp=500) #RPC也可以异步+回调函数
# 实际执行流程：
1.客户端序列化数据(player_id, exp)->二进制数据
2.通过TCP/UDP发送到游戏服务器
3.服务器反序列化数据->执行真实的level_up、逻辑
4.将结果(新等级)序列化后返回客户端
5.客户端反序列化结果->更新本地界面
```

注：Serialization和Marshalling：

- 简单来说，二者的共同点在于：它们都涉及到对象的序列化。序列化用于传输对象或存储对象。但也有一些不同：
- **Serialization**是将对象的状态转换为可存储或传输的格式的过程。这通常涉及将对象的属性和数据结构转换为字节流，以便在文件中保存或通过网络发送。Serialization一般关注的是对象及其属性，而不一定与数据的远程传输有关。
  - 可以生成多种格式，如 JSON、XML、二进制格式等，取决于所使用的序列化库或框架。
- **Marshalling（编组）**：是关于在分布式环境中将数据从一种表示形式转换为另一种表示形式的过程，尤其是在远程调用（如 RPC）时。编组通常包括将对象转换为网络协议所需的格式。**编组可以被视为序列化的一个特定实例，专注于跨网络传输的数据准备。**
  - 通常与特定的通信协议相关联，可能会有特定的编码规则。例如，gRPC 使用 Protocol Buffers 进行数据编组。

虽然 `Serialization` 和 `Marshalling` 在某些情况下可以互换使用，但它们的重点和应用场景不同。**序列化更广泛地应用于对象存储和传输，而编组则专注于在远程调用时准备数据以适应网络协议的需求。**理解这两者的差异有助于更有效地处理数据在不同层次上的传输和存储。关于RPC更为详细的内容，可以参考附录中的`RPC相关理论.md`



## 【8】Protobuf相关

protobuf是RPC中常用的序列化工具。**Protocol Buffers（简称Protobuf）**是Google开发的跨语言、跨平台、可扩展的结构化数据序列化协议。其核心价值体现在：

- 1.**二进制编码**：相比JSON/XML等文本协议，体积减少30%~80%；
- 2.**高效解编码**：解析速度比JSON快5~100倍；
- 3.**强类型约束**：通过Schema定义确保数据结构安全；
- 4.**跨语言支持**：自动生成Java/C#/Python/C++/Go等代码；
- 5.版本兼容性：支持向前向后兼容的协议演进。

Protobuf更为具体的内容，以及与其他序列化方法的对比，也被放入了附录的`RPC相关理论.md`，必要时可以去那里复习。

### （1）与Json的对比

| 维度             | Protobuf             | JSON              |
| ---------------- | -------------------- | ----------------- |
| **序列化速度**   | 快（需解析）         | 慢                |
| **反序列化速度** | 快                   | 慢                |
| **数据体积**     | 小                   | 大                |
| **可读性**       | 需工具               | 好                |
| **模式演进**     | 优秀                 | 无约束            |
| **内存占用**     | 低                   | 高                |
| **适用场景**     | 网络协议、持久化存储 | 配置文件、Web API |

XML估计跟Json差不多，对于RPC而言，Protobuf应该是比较好用的。



### （2）protobuf：variant，zigzag

这里考察的是Protobuf的各种编码结构，参考链接：[ProtoBuf（Google Protocol Buffers）—— 编码结构简介（Varint 、ZigZag 、64-bit、32-bit、Length-delimited）-CSDN博客](https://blog.csdn.net/JMW1407/article/details/107197938)

其他参考链接：[protobuf编码之varint/zigzag - Ying](https://izualzhy.cn/protobuf-encode-varint-and-zigzag)

**variant编码**

> 数据传输中出于IO的考虑，我们会希望尽可能的对数据进行压缩。Varint就是一种对数字进行编码的方法，**编码后二进制数据是不定长的，数值越小的数字使用的字节数越少**。例如对于`int32_t`，采用Varint编码后需要1~5个bytes，小的数字使用1个byte，大的数字使用5个bytes。基于实际场景中小数字的使用远远多于大数字，因此通过Varint编码对于大部分场景都可以起到一个压缩的效果。
>
> 编码规则：
> 最高位(most significant bit)表示编码是否继续，如果该位为1，表示接下来的字节仍然是该数字的一部分，如果该位为0，表示编码结束。字节里的其余7位用原码补齐，采用低位字节补齐到高位的办法。
>
> 举几个例子：
>
> - `1`进行variant编码后的结果为`0000 0001`，占用1个字节。相比`int32`的数字1存储占用4个字节，节省了3个字节的空间（主要是高位的0），而Varint的想法就是 **以标志位替换掉高字节的若干个0**。
> - 对`300`进行variant编码，`300`的原码形式为：`00000000 00000000 00000001 00101100`，编码过程为：
>
> ![number_300_varint.png](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/number_300_varint.png)
>
> 可以看到对于较大的数字(1«28)，使用的字节数由4个变成了5个，同时对于负数也有影响。`int64`的负数则要10个字节，因为64/7向上取整是10。



**Zigzag编码**

> varint编码希望以标志位能够节省掉高字节的0，但是负数的最高位一定是1， 所以varint在处理32位负数时会固定的占用5个字节（32位，每7个保留一组，需要5组）。pb（即protobuf）里提供了对应的解决方案，在介绍解决方案之前，有必要先介绍下ZigZag编码。
>
> ZigZag是将有符号数统一映射到无符号数的一种编码方案，对于无符号数`0 1 2 3 4`，映射前的有符号数分别为`0 -1 1 -2 2`，负数以及对应的正数来回映射到从0变大的数字序列里，这也是”zig-zag”的名字来源。
>
> ZigZag编码的映射函数如下：
>
> ```c++
> Zigzag(n) = (n << 1) ^ (n >> 31),  n为sint32时
> Zigzag(n) = (n << 1) ^ (n >> 63),  n为sint64时
> ```
> 可以这么理解Zigzag的编码规则：
>
> - 对于整数n：
>   - 如果 `n` 是非负的 (`n >= 0`)，则编码为 `n * 2`。
>   - 如果 `n` 是负的 (`n < 0`)，则编码为 `(-n * 2) - 1`。

简单来说，就是Protobuf极致地压缩了数据量。



## ==【9】TCP拥塞控制==



## ==【10】TCP流量控制==





# 计算机图形学篇

> 注：计算机图形学的很多知识点在教程里有，这里针对部分问题只给出重要的答题点，具体答案就不完全整理了。

## 【1】渲染管线介绍，分为哪些阶段？

> - 应用阶段：识别出潜在可视的网格实例，并把它们及其材质呈交至图形硬件以供渲染。该阶段包含三大任务：可见性判断、控制着色器参数和渲染状态、提交图元至GPU硬件以供渲染。
>
>   - 空间加速算法、视锥剔除、碰撞检测、动画物理模拟、调用Drawcall；
>
> - 几何阶段：主要负责大部分多边形操作和顶点操作，将三维空间的数据转换为二维空间的数据，可以分为**顶点着色、投影变换、裁剪和屏幕映射阶段**。
>
> - 光栅化阶段：将图元离散化成片段的过程，其任务是找到需要绘制出的所有片段，包括**三角形设定和三角形遍历**阶段；
>
>   - a. 三角形设置(图元装配)，计算出三角形的一些重要数据(如三条边的方程、深度值等)以供三角形遍历阶段使用，这些数据同样可用于各种着色数据的插值。
>
>     b. 三角形遍历，找到哪些像素被三角形所覆盖，并对这些像素的属性值进行插值。通过判断像素的中心采样点是否被三角形覆盖来决定该像素是否要生成片段。通过三角形三个顶点的属性数据，插值得到每个像素的属性值。**此外透视校正插值也在这个阶段执行。**
>
> - 像素着色阶段：**片元着色器像素着色+合并阶段（透明测试、模板测试、深度测试，blend操作等）**



## 【2】OpenGL中的渲染管线介绍

> （注：这个问题将图形渲染管线具体到了某一个图形[API](https://zhida.zhihu.com/search?content_id=183804732&content_type=Article&match_order=1&q=API&zhida_source=entity)，因此涉及到了一些具体概念，但是大体上跟上面描述的图形渲染管线一致）
>
> 【**Reference**】：[你好，三角形 - LearnOpenGL CN (learnopengl-cn.github.io)](https://link.zhihu.com/?target=https%3A//learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/)、[【OpenGL】OpenGL渲染流程详解_Zok93-CSDN博客_opengl渲染](https://link.zhihu.com/?target=https%3A//blog.csdn.net/sinat_20559947/article/details/78886440)
>
> - （1） VBO将数据存储到缓存中，VAO绑定顶点属性关系，然后VBO将缓存数据传给vertex_shader（注：还可以回顾一下IBO/EBO：存放图元对应的顶点索引）；
> - （2）在顶点着色器中进行坐标变换，由mvp矩阵将其转换到裁剪坐标系，以及顶点着色；
> - （3）然后到裁剪和屏幕映射阶段；裁剪掉视锥体外的图元，将当前坐标映射到屏幕坐标；
> - （4）三角形设置阶段（或是图元装配阶段），将顶点着色器的输出数据装配成指定图元的形状；
> - （5） 然后进入光栅化阶段，找到哪些像素被三角形覆盖，以及进行插值计算；
> - （6）然后进入到了fragment_shader，执行光照计算，进行着色；
> - （7） 最后进入到测试混合阶段，包括Alpha测试、模板测试、深度测试等，然后进行混合。



## 【3】**各种测试(缓冲)的含义，相对顺序？**

> - （1）深度测试：略
> - （2）Alpha测试：像素值一般是由[RGBA](https://zhida.zhihu.com/search?content_id=183804732&content_type=Article&match_order=1&q=RGBA&zhida_source=entity)四个分量来表示的，其中的A是alpha，表示的是物体的不透明度。1代表完全不透明，0代表完全透明。可选的 alpha 测试可在深度测试执行前在传入片段上运行。片段的 alpha 值与参考值作某些特定的测试（如等于，大于等），如果片段未能通过测试，它将不再进行进一步的处理。 alpha 测试经常用于不影响深度缓存的全透明片段的处理。简单来说，就是根据物体的透明度来决定是否渲染。
> - （3）模板测试：模板缓冲是用于记录所呈现图元位置的离屏缓存。如果使用了模板缓冲，就相当于在屏幕上有一块模板盖在上面，只有位于这个模板中的图元片段，才会被渲染出来。模板测试就是用片段指定的参考值与模板缓冲中的模板值进行比较，如果达到预设的比较结果，模板测试就通过了，然后用这个参考值更新模板缓冲中的模板值；如果没有达到预设的比较结果，就是没有通过测试，就不更新模板缓冲。简单来说，就是根据物体的位置范围决定是否渲染。
> - （4）裁剪测试（**没用过，可以不主动提这个**）：在裁剪测试中，允许程序员开设一个裁剪框，只有在裁剪框内的片元才会被显示出来，在裁剪框外的片元皆被剔除。裁切测试可以避免当视口比屏幕窗口小时造成的渲染浪费问题。通常情况下，我们会让视口的大小和屏幕空间一样大，此时可以不需要使用到裁切测试。但当两者大小不一样大时，我们需要用到裁切测试来避免其产生的一些问题。如下图所示：
> - ![img](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/v2-52e7f65de9819499d8f5d257e502927f_r.jpg)
>
> 图中的绿色方框表示视口范围，大的黑色方框表示屏幕范围，当视口小于屏幕的时候，如果不用裁剪测试，则会将视口范围外的背景白色也绘制出来，导致渲染浪费，结果也不正确。

**各种测试的相对顺序：裁剪->Alpha->模板->深度**。主要记住**Alpha->模板->深度测试这个顺序**。



## 【4】各种反走样技术的问题

> 具法的细节在图形学教程中有所整理。这里只给出大致算法。包含MSAA，SSAA，FXAA，TAA，SMAA，还可以提一下Nvidia的超分辨率DLSS系列全家桶。

1. **SSAA（超采样抗锯齿）**  
   - **原理**：以高于目标分辨率渲染场景，通过平均相邻像素颜色下采样。  
   - **特点**：效果最优，但计算开销极高（像素数平方级增长）。

2. **MSAA（多重采样抗锯齿）**  
   - **原理**：仅在几何边缘处对单个像素内多个子样本采样，混合结果。  
   - **特点**：降低SSAA计算量，硬件广泛支持（如GPU光栅化阶段优化）。

3. **FXAA（快速近似抗锯齿）**  
   - **原理**：后处理阶段通过图像空间算法检测高频边缘并模糊，不依赖几何信息。  
   - **特点**：速度快，但易导致细节模糊（基于亮度梯度检测）。

4. **SMAA（子像素形态抗锯齿）**  
   - **原理**：结合边缘检测（类似FXAA）+ 形态学分析 + 子像素信息重建边缘。  
   - **特点**：比FXAA更精确保留细节，代价略高（分模式：SMAA 1x/2x/4x）。

5. **TAA（时间抗锯齿）**  
   - **原理**：利用历史帧数据，通过运动向量对齐像素，时域累积减少当前帧锯齿。  
   - **特点**：高效且兼容动态光影，但需处理重投影鬼影（如Clip历史/Neighbor Clamp）。

**核心区别**：SSAA/MSAA基于几何采样，FXAA/SMAA为后处理，TAA利用时间连贯性。



### （1）TAA的其他细节

可以参考文章：[主流抗锯齿方案详解（二）TAA - 知乎](https://zhuanlan.zhihu.com/p/425233743)

- 使用Halton低差异序列，实现jitter抖动；要对采样点进行偏移，只需要将偏移的XY分量分别写入到投影矩阵的[2, 0] 和 [2, 1]即可。
- **TAA在图形管线中的位置**：如果使用 HDR 颜色作为输入，得到的抗锯齿效果不佳。所以需要把 TAA 放到 Tonemapping 之后。但是这样又会影响后续需要 HDR 的 Bloom 等特效的计算。**因此我们需要先进行一次 Tonemapping，进行 TAA 后再将 Tonemapping 还原，然后处理需要 HDR 颜色输入的后处理，最终再进行一次 Tonemapping 计算。**

具体可以看下图：

![img](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/v2-c4ccc37c5541f7a7fe166bc7fafc36b8_r.jpg)

- 对于静态场景和静态镜头的TAA，直接使用当前帧的结果和上一帧得到的历史结果做混合。混合的方式，就是简单地使用百分比混合，即将历史帧数据，和当前帧数据进行 lerp。代码如下：

```c++
float3 currColor = currBuffer.Load(pos);
float3 historyColor = historyBuffer.Load(pos);
return lerp(historyColor, currColor, 0.05f);
```



**重投影**

考虑镜头的移动。镜头移动后，原来投射到某个像素上的物体，现在很可能不在原来的位置上了。假设物体是不动的，我们就可以使用当前帧的深度信息，反算出世界坐标，使用上一帧的投影矩阵，在混合计算时做一次重投影 **Reprojection/重投影**。

- 重投影只能适用于静态的物体，如果物体是移动的，我们就无法精确还原物体上一帧的投影位置了。



**动态物体——Motion Vector**

物体本身的移动比较复杂，再加上摄影机本身的移动，直接在混合时进行计算的话，计算起来非常困难。为了能够精确地记录物体在屏幕空间中的移动，我们使用 **Motion Vector** 贴图来记录物体在屏幕空间中的变化距离，**表示当前帧和上一帧中，物体在屏幕空间投影坐标的变化值。**因为 Motion Vector 的精度要求比较高，因此用RG16格式来存储。**Motion Vector 可以作为延迟渲染的 GBuffer 的一部分，除了用了实现 TAA，还可以实现移动模糊/Motion Blur 等效果。**

在渲染物体时，我们需要用到**上一帧的投影矩阵和上一帧该物体的位置信息，这样可以得到当前帧和上一帧的位置差，并写入到 Motion Vector**。对于带蒙皮动画的物体，我们同时需要上一帧的骨骼的位置，来计算处上一帧中投影到的位置。**计算上一帧位置和当前帧位置的方法是一样的，都是从 VS 中输出裁剪空间的齐次坐标，在 PS 中读取，然后就可以做差求得 Motion 值。**为了使 Motion 的值比较精确，我们在计算 Motion 时，**不会**添加抖动。

接下来就是使用 Motion Vector 进行混合计算了，我们需要使用 Motion Vector 算出上一帧物体在屏幕空间中投射的坐标。在计算之前，我们先要移除当前像素采样的抖动偏移值，然后减去采样 Motion Vector 得到的 Motion 值，就可以算出上一帧中投影坐标的位置。然后就可以根据位置对历史数据进行采样了，因为我们得到的坐标往往不是正好在像素中心位置，因此这里使用双线性插值进行采样。

```c++
// 减去抖动坐标值，得到当前实际的像素中心UV值
uv -= _Jitter;
// 减去Motion值，算出上帧的投影坐标
float2 uvLast = uv - motionVectorBuffer.Sample(point, uv);
//使用双线性模式采样
float3 historyColor = historyBuffer.Sample(linear, uvLast);
```



**对历史结果进行处理**

由于像素抖动，模型变化，渲染光照变化导致渲染结果发生变化时，会导致历史帧得到的像素值失效，就会产生 **鬼影/ghosting** 和 **闪烁 /flicking** 问题。常见的解决方案有：

- 重投影容错：

  - 检测历史帧与当前帧颜色差异（过大则判定为遮挡/运动突变）。

  - 动态区域降低历史帧权重（如权重0.2历史+0.8当前）。

    - 比如，当物体的 Motion Vector 值比较大时，就增大 blendFactor 的值，反之则减小：

    - ```c++
      // 与上帧相比移动距离越远，就越倾向于使用当前的像素的值
      blendFactor = saturate(0.05 + length(motion) * 100);
      return lerp(historyColor, currColor, blendFactor);
      ```

- **Clipping（颜色钳位）**：限制历史帧颜色在合理范围内，避免拖影（Clip至当前帧邻域颜色极值）。



## ==【5】在渲染中，透明物体的深度测试和深度写入==



## ==【6】介绍一下骨骼和蒙皮技术==



## ==【7】介绍一下IK==



## ==【8】介绍一下Early-Z和Z-prepass==





# Unity篇

## ==【1】Navigation系统的介绍==





## ==【2】Mono和IL2CPP的区别（参考文章还没看）==

参考链接：[【Unity游戏开发】Mono和IL2CPP的区别 - 知乎](https://zhuanlan.zhihu.com/p/352463394)



## 【3】Unity协程, Unity协程和C#多线程使用上的区别，C#异步

**Unity协程：**

Unity中的协程（Coroutine）是一种特殊的函数，它可以在执行过程中暂停并在稍后的时间点继续执行。协程通常用于处理需要分步执行的任务，比如等待一段时间、等待某个条件满足等。协程通过`yield`关键字来实现暂停和继续。

例如：

```csharp
IEnumerator MyCoroutine()
{
    Debug.Log("Start");
    yield return new WaitForSeconds(1); // 暂停1秒
    Debug.Log("After 1 second");
}
```

**Unity协程与C#多线程的区别：**

1. **执行环境**：Unity协程是在主线程上执行的，它们并不是真正的多线程。协程的暂停和继续是通过Unity的主循环来控制的。而C#的多线程是通过`Thread`类或`Task`类创建的，它们可以在不同的线程上并行执行。

2. **用途**：协程通常用于处理需要分步执行的任务，比如动画、延时操作等。而多线程通常用于处理需要并行执行的任务，比如计算密集型操作、IO操作等。

3. **线程安全**：由于协程是在主线程上执行的，因此它们可以安全地访问Unity的对象（如`GameObject`、`Transform`等）。而多线程操作Unity对象时需要注意线程安全问题，通常需要通过主线程来操作Unity对象。



**C#异步：**

C#中的异步编程是通过`async`和`await`关键字来实现的。异步操作通常用于处理IO操作、网络请求等耗时操作，以避免阻塞主线程。

例如：

```csharp
async Task MyAsyncMethod()
{
    Debug.Log("Start");
    await Task.Delay(1000); // 异步等待1秒
    Debug.Log("After 1 second");
}
```



> 在Unity中，使用**协程(Coroutine)**和**异步场景加载**是常见的异步操作场景。以下是一个协程+异步的例子：
>
> ```c#
> // 触发加载（如按钮点击事件调用）
> public void StartLoading()
> {
>     StartCoroutine(LoadSceneAsync());
> }
> 
> IEnumerator LoadSceneAsync()
> {
>     AsyncOperation asyncLoad = SceneManager.LoadSceneAsync(sceneName);
>     asyncLoad.allowSceneActivation = false; // 禁止加载完成后自动切换
> 
>     // 循环检查加载进度
>     while (!asyncLoad.isDone)
>     {
>         float progress = Mathf.Clamp01(asyncLoad.progress / 0.9f); // Unity的progress范围是0~0.9
>         progressBar.value = progress;
>         progressText.text = $"Loading: {(progress * 100):F0}%";
> 
>         // 加载完成（progress >= 0.9）后等待用户确认
>         if (asyncLoad.progress >= 0.9f)
>         {
>             progressText.text = "Press Space to continue";
>             if (Input.GetKeyDown(KeyCode.Space))
>                 asyncLoad.allowSceneActivation = true; // 手动激活场景
>         }
> 
>         yield return null; // 等待下一帧
>     }
> }
> ```

**总结：** Unity协程是在主线程上执行的，适合处理分步执行的任务；C#多线程可以在不同线程上并行执行，适合处理计算密集型任务；C#异步编程通过`async`和`await`关键字实现，适合处理IO操作等耗时任务。**关于Unity中使用`async`和`await`，可以说确实是没用过，如果有被问到再做总结。**



### （1）协程和`AsyncOperation`的区别

> #### **1. `AsyncOperation`的本质**
>
> - **`AsyncOperation`是一个异步任务对象**，用于封装后台操作（如场景加载、资源加载等），由Unity引擎底层管理。
> - 它本身**不是协程**，而是通过`SceneManager.LoadSceneAsync`或`Resources.LoadAsync`等方法创建的异步操作句柄。
> - **底层实现可能涉及多线程**（如资源加载），但最终结果会返回到主线程（Unity主线程安全）。
>
> ------
>
> #### **2. 协程的作用**
>
> - 协程是**基于迭代器的代码流程控制工具**，通过`IEnumerator`和`yield`关键字实现分段执行。
> - 协程本身不执行异步任务，但可以通过`yield return asyncLoad`来**等待`AsyncOperation`完成**，实现非阻塞逻辑。

关键区别如下表：

| **特性**     | **协程 (Coroutine)**                  | **AsyncOperation**                     |
| ------------ | ------------------------------------- | -------------------------------------- |
| **用途**     | 控制代码流程（分段执行/等待）         | 封装后台任务（如加载场景、资源）       |
| **线程**     | 始终在主线程运行                      | 可能由引擎底层线程执行，结果返回主线程 |
| **依赖关系** | 依赖`MonoBehaviour`的`StartCoroutine` | 独立的任务对象，不依赖协程             |
| **可等待性** | 通过`yield`暂停自身                   | 可被协程`yield return`等待             |



## 【4】Unity脚本的生命周期

> Unity脚本的生命周期是指从脚本被加载到场景中，到脚本被销毁的整个过程。Unity提供了一系列的事件函数（也称为生命周期函数），开发者可以在这些函数中编写代码来控制游戏对象的行为。以下是Unity脚本的主要生命周期函数：
>
> 1. **Awake()**：
>    - 在脚本实例被创建时调用，**即使脚本未启用也会调用**（经过测试，的确是这样）。
>    - 通常用于初始化变量或获取组件引用。
>    - 注意：`Awake` 只会在脚本实例化时调用一次。
>
> 2. **OnEnable()**：
>    - 当脚本启用时调用（例如通过 `SetActive(true)` 或勾选脚本组件）。
>    - 适合用于重新启用脚本时的初始化操作。
>
> 3. **Start()**：
>    - 在脚本启用后，第一次调用 `Update` 之前调用。
>    - 通常用于初始化需要在 `Awake` 之后执行的操作。
>
> 4. **FixedUpdate()**：
>    - 以固定的时间间隔调用（默认每秒50次，可通过 `Time.fixedDeltaTime` 调整）。
>    - 适合用于物理相关的操作，如刚体运动。
>
> 5. **Update()**：
>    - 每帧调用一次，频率取决于设备的帧率。
>    - 适合用于处理游戏逻辑、输入检测等。
>
> 6. **LateUpdate()**：
>    - 在 `Update` 之后调用，每帧调用一次。
>    - 适合用于需要在所有 `Update` 逻辑执行完毕后执行的操作，如相机跟随。
>
> 7. **OnDisable()**：
>    - 当脚本被禁用时调用（例如通过 `SetActive(false)` 或取消勾选脚本组件）。
>    - 适合用于清理资源或停止某些操作。
>
> 8. **OnDestroy()**：
>    - 当脚本被销毁时调用（例如对象被销毁或场景切换）。
>    - 适合用于释放资源或保存数据。



## 【5】Update，FixedUpdate，LateUpdate的区别和使用

在Unity中，`Update`、`FixedUpdate`和`LateUpdate`是三种核心的更新函数，它们的执行时机和用途有显著区别。以下是它们的对比和典型业务场景：

- `update()`：

  - 每帧调用一次，帧率不固定（取决于设备性能或`Application.targetFrameRate`设置）。

  - 与屏幕刷新率同步，例如60Hz设备每秒调用约60次。

  - 适用场景：

    - **输入检测**：键盘、鼠标、触控的实时响应

    ```c#
    void Update() {
        float moveX = Input.GetAxis("Horizontal");
        transform.Translate(moveX * speed * Time.deltaTime, 0, 0);
    }
    ```

    - **非物理的连续逻辑**：角色动画状态切换、UI动态效果（如进度条填充）。
    - **帧率相关操作**：需要逐帧更新的游戏逻辑（如非物理移动的NPC行为）。

  - **避免在Update中做的事**：物理计算（应放在`FixedUpdate`）、高频复杂运算（可能导致卡顿）

- **`FixedUpdate()`**

  - 按固定时间间隔调用（默认`0.02秒`，对应50次/秒，可通过`Time.fixedDeltaTime`调整）。

  - 与物理引擎（PhysX）的更新频率同步。

  - 适用场景：

    - **物理相关操作**：施加力、速度修改、碰撞检测后的响应。

    ```c#
    void FixedUpdate() {
        if (isJumping) {
            rigidbody.AddForce(Vector3.up * jumpForce, ForceMode.Impulse);
            isJumping = false;
        }
    }
    ```

    - **稳定频率的逻辑**：需要严格时间间隔的操作（如回合制游戏的计时器）。

  - 注意事项：若游戏帧率低于物理帧率，可能单帧内调用多次`FixedUpdate`；物理属性（如`Rigidbody.velocity`）建议在此修改。

- **`LateUpdate()`**

  - 在**所有`Update`执行完毕后**调用，每帧一次，确保在其他对象逻辑完成后执行。

  - 适用场景：

    - **摄像机跟随**：保证目标物体移动后再更新摄像机位置。

    ```c#
    void LateUpdate() {
        Camera.main.transform.position = target.position + offset;
    }
    ```

    - **依赖其他对象状态的逻辑**：如计算玩家排名（需所有玩家分数更新后）。
    - **UI更新**：在游戏逻辑计算完毕后刷新UI数值（如血量显示）。

以下是一些经典的业务场景可以参考写的位置：

| 业务需求             | 推荐函数      | 原因说明                           |
| -------------------- | ------------- | ---------------------------------- |
| 玩家移动输入检测     | `Update`      | 需要实时响应输入，与帧率同步       |
| 角色跳跃（物理驱动） | `FixedUpdate` | 物理力的施加需稳定频率             |
| 摄像机跟随玩家       | `LateUpdate`  | 确保玩家位置更新后再移动摄像机     |
| 非物理的NPC路径移动  | `Update`      | 逐帧插值移动，与渲染同步           |
| 碰撞后播放音效       | `FixedUpdate` | 物理碰撞检测结果通常在物理帧中处理 |
| 动态更新敌人血量条UI | `LateUpdate`  | 在敌人血量计算完毕后更新UI         |
| 根据时间切换昼夜系统 | `Update`      | 非物理逻辑，逐帧插值颜色或光照     |



**常见误区**

1. **在`Update`中修改物理属性**：
   可能导致抖动或不稳定，因为物理引擎更新频率与帧率不同步。
2. **在`FixedUpdate`中处理输入**：
   输入检测可能延迟，因为`FixedUpdate`调用频率可能低于帧率。
3. **过度依赖`LateUpdate`**：
   非依赖性的逻辑无需放在此处，避免增加执行顺序复杂度。

**性能优化建议**

- 将低频操作（如AI决策）拆分到协程（`Coroutine`）中，避免每帧调用。
- 使用`[RequireComponent]`或缓存组件引用（如`Rigidbody`），减少`GetComponent`在更新函数中的调用。
- 若需跨帧计算，优先选择`UniTask`或`Job System`（多线程任务）。

------



## 【6】Unity物理引擎的碰撞检测相关

这个地方坑比较深，单独放到附录->`Unity物理引擎碰撞检测说明.md`当中，需要的时候去那里复习即可。



# 场景题目篇

> 这一部分的题目会给出一个业务需求，要求给出分析或者实现。整理一下对应的题目。

## ==【1】设计一个背包系统（写代码）考虑各种情况，如空位置、加物品超上限==



# 算法题目篇

## 【1】给出平面上n个点，求出任意两点组成的直线中斜率最大的两个点。

> 思路看这篇的理论部分即可：[浅谈一类平面点对斜率最值问题_二维坐标平面,斜率最大的两个点-CSDN博客](https://blog.csdn.net/m0_38013346/article/details/80434208)。实现上就是把所有的`x`从小到大排序，斜率最大的点对一定在相邻两个点之间。
>
> **注：上面这个证明似乎说服力还不够，但先记住结论吧。**



## 【2】用队列实现栈

> 思路：需要两个队列，记当前活跃队列为q1，另一个辅助队列为q2
>
> - （1）push操作：直接放入当前的活跃队列q1中即可；
> - （2）pop操作：从当前活跃队列q1中不断拿出元素放入q2，直到q1中只剩下一个元素，pop出去。然后将q1和q2做swap，保证q1是当前活跃队列；**注：pop操作需要判断队列是否为空。**
> - （3）top操作：从当前活跃队列q1中不断拿出元素放入q2，直到q1中只剩下一个元素，这个元素即为top的返回值，在算出来之后入队到q2中，然后swap（q1，q2），保证q1是当前活跃队列；**注：top操作需要判断队列是否为空。**
> - （4）empty（）操作：只需判断q1是否为空即可；

可以做Leetcode的这道题目：[225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/)。这道题目保证pop和top操作时栈不会空，所以就不用特判了。实现的代码如下：

```c++
class MyStack {
public:
    queue<int> q1;
    queue<int> q2;
    MyStack() {}
    
    void push(int x) 
    {
        q1.push(x); //统一都push到q1里
    }
    
    int pop() 
    {
       int size = q1.size();
       for(int i=1;i<size;i++)
       {
            int front = q1.front();
            q1.pop();
            q2.push(front);
       }
       int res = q1.front();
       q1.pop();
       swap(q1,q2);
       return res;
    }
    
    int top()
    {
        int size = q1.size();
        for(int i=1;i<size;i++)
        {
            int front = q1.front();
            q1.pop();
            q2.push(front);
        }
        int res = q1.front();
        q1.pop();
        q2.push(res);
        swap(q1,q2);
        return res;
    }
    
    bool empty() {
        return q1.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```



## 【3】用栈实现队列

> 思路：需要两个栈s1，s2。各个算法如下：
>
> - （1）push：此时统一push进第一个栈s1里；
> - （2）pop：如果s2为空，则把s1里的元素依次放入s2当中，然后pop出s2最上面的元素（前提合法，即s2不为空）；
>   - 如果s2不为空，则直接pop出s2的最上面元素；
> - （3）peek操作：与pop类似，只不过不需要pop。如果s2为空，则把s1里的元素依次放入s2当中，返回s2的top元素；s2不为空的情况直接返回s2的最上面元素；
> - （4）empty操作：判断是否s1为空且s2为空；
>
> 注：理论上每一步操作也要用代码保证合法性，这个也要看面试时的需求。

可以做一下Leetcode的这道题目：[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/description/)。这里给出AC代码：

```c++
class MyQueue {
public:
    stack<int> s1;
    stack<int> s2;
    MyQueue() {}
    
    void push(int x) {
        s1.push(x);
    }
    
    int pop() {
        int top = -1;
        if(!s2.empty())
        {
            top = s2.top();  s2.pop();
            return top;
        }
        while(!s1.empty())
        {
            top = s1.top(); s1.pop();
            s2.push(top);
        }
        if(!s2.empty())
        {
            top = s2.top(); s2.pop();
        }
        return top;
    }
    
    int peek() {
        int top = -1;
        if(!s2.empty())
        { 
            return s2.top();
        }
        while(!s1.empty())
        {
            top = s1.top(); s1.pop();
            s2.push(top);
        }
        if(!s2.empty()) top = s2.top();
        return top;
    }
    
    bool empty() {
        return s1.empty() && s2.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```



## ==【4】最小覆盖子串==

https://leetcode.cn/problems/M1oyTv/



## ==【5】树的序列化和反序列化==

[297. 二叉树的序列化与反序列化 - 力扣（LeetCode）](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/)。这道题目的题解参考Leetcode官方题解的解法1，**需要对字符串的接口足够熟悉。**



##  ==【6】最大频率栈==

[895. 最大频率栈 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-frequency-stack/description/)



## 【7】最长无重复子串

[LCR 016. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/wtcaE1/description/)

补充题目:

- （1）长度最小的子数组[LCR 008. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/2VG8Kg/description/)

这里涉及到滑动窗口的经典板子，这里把最长无重复子串的代码贴上来：

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        //滑动窗口
        unordered_map<char, int> m; //记录每个字符的出现次数
        int n = s.size();
        int res = 0, l = 0;
        for(int r=0;r<n;r++)
        {
            if(!m.count(s[r])) m[s[r]]=1; //字典里没有,加进去
            else m[s[r]]++; //字典里有,value值++
            while(m[s[r]]>1) //有重复字符了
            {
                m[s[l]]--;
                l++;
            }
            //此时滑动窗口内没有重复字符了
            if(l<=r) res = max(res, r-l+1);
        }
        return res;
    }
};
```

总结来看就是：

- 1.在外层的for循环，每次固定移动`r`；
- 2.如果当前移动完`r`之后不满足题目的要求，就移动`l`直到满足要求，这可以通过while来实现；
- 3.在窗口区间满足要求的前提下，看题目要求解的问题是否有更优解；



## 【8】归并排序

在`排序算法`对应的专题md中有介绍，这里以[912. 排序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-an-array/description/)为例直接给出题解：

```c++
class Solution {
public:
    void mergeSort(vector<int>& nums, vector<int>& tmp, int l, int r)
    {
        if(l>=r) return;
        int mid = (l+r)>>1;
        //归
        mergeSort(nums, tmp, l, mid);
        mergeSort(nums, tmp, mid+1, r);
        //并
        int i=l, j=mid+1, k=0;
        while(i<=mid&&j<=r)
        {
            if(nums[i]<=nums[j]) tmp[k++]=nums[i++];
            else tmp[k++]=nums[j++];
        }
        while(i<=mid) tmp[k++]=nums[i++];
        while(j<=r) tmp[k++]=nums[j++];
        for(int i=l, k=0;i<=r;i++, k++)
            nums[i] = tmp[k];

    }
    vector<int> sortArray(vector<int>& nums) {
        //归并排序
        int n = nums.size();
        vector<int> tmp(n);
        mergeSort(nums, tmp, 0, n-1);
        return nums;
    }
};
```



## 【9】最大子数组和

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/)，经典dp题，代码如下：

```c++
class Solution 
{
public:
    int maxSubArray(vector<int>& nums) 
    {
        //dp[i] 表示以 nums[i] *结尾* 的最大子数组和。
        int n =nums.size();
        // int dp[100010]={0};
        vector<int> dp(n,0);
        int maxNum=nums[0];//[-1]
        dp[0]=nums[0];
        for(int i=1;i<n;i++)
        {
            dp[i]=max(dp[i-1],0)+nums[i];
            maxNum=max(maxNum,dp[i]);
        }
        return maxNum;
    }
};
```

另一个简化后的DP版本（**这种题目的要点在于思考好边界情况，比如`dp[-1]`可以认为是0，这样`dp[0]=nums[0]`**）：

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //dp[i] = max(nums[i], dp[i-1]+nums[i])
        //dp[0] = nums[0];dp[-1]=0;
        int res = INT_MIN;
        int sum = 0;
        int n = nums.size();
        for(int i=0;i<n;i++)
        {
            sum = max(0, sum) + nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
```



## 【10】有效的括号

本题可以分为括号有优先级以及括号无优先级两个版本。首先是括号无优先级，对应：[20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/description/)，比较简单，优雅一点的做法是使用`unordered_map`做存储：

```c++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char, char> m = {{')','('}, {']','['}, {'}','{'}};
        stack<char> stk;
        for(int i=0;i<s.size();i++)
        {
            if(m.count(s[i])>0)
            {
                if(stk.empty() || stk.top()!=m[s[i]]) return false;
                else stk.pop();
            } 
            else stk.push(s[i]);
        }
        return stk.empty();
    }
};
```

如果括号有优先级：`()里面有[],{}也是非法的，[]里面有{}也非法`，那么无非就是在基础版上，添加对于入栈时的判断。如果入栈时栈顶是右括号显然是不可能的，而如果是左括号的话，就一定要比现在的优先级更高才行。

可以尝试的题目：[3703. 括号的匹配 - AcWing题库](https://www.acwing.com/problem/content/description/3706/)，以下是这道题目的题解。

```c++
#include<iostream>
#include<stack>
#include<unordered_map>
#include<string>
using namespace std;

unordered_map<char, int> m; //key>0的是右括号,key<0的是左括号,且绝对值更大的key优先级更高

bool check(string& s)
{
	stack<char> stk;
	for (int i = 0; i < s.size(); i++)
	{
		if (m[s[i]] > 0) //说明是右括号
		{
			//栈是不会放入右括号的，有栈顶则一定是左括号
			if (stk.empty() || m[stk.top()] != -m[s[i]]) return false;
			stk.pop();
		}
		else //左括号，看优先级
		{
			if (!stk.empty() && m[stk.top()] > m[s[i]]) return false;
			stk.push(s[i]);
		}
	}
	return stk.empty();
}

int main()
{
	m['}'] = 4; m[']'] = 3; m[')'] = 2; m['>'] = 1;
	m['{'] = -4; m['['] = -3; m['('] = -2; m['<'] = -1;
	int n;
	string s;
	cin >> n;
	while (n--)
	{
		cin >> s;
		bool res = check(s);
		cout << (res ? "YES" : "NO") << endl;
	}
	return 0;
}
```



## 【11】牛顿迭代法开方

可以做的题目：https://leetcode.cn/problems/sqrtx/solutions/238553/x-de-ping-fang-gen-by-leetcode-solution/

这道题目一共有三种做法：1.二分法 2.袖珍计算器法 3.牛顿迭代法。

### （1）二分法

```c++
class Solution {
public:
    int mySqrt(int x) {
        //二分法,左闭右闭区间,找到最后一个平方<=x的正数
        long long l = 0, r = x;
        while(l<=r) { //左闭右闭区间
            long long mid = l + ((r-l)>>1);
            if(mid*mid > x){ //严格到左边找
                r = mid-1;
            }
            else l = mid+1; //l可以再激进一点
        }
        return l-1;
    }
};
```



### （2）袖珍计算器法

「袖珍计算器算法」是一种用指数函数 exp 和对数函数$\ln$代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。

我们将$\sqrt x$写成幂的形式$x^{1/2}$,再使用自然对数$e$进行换底，即可得到：
$$
\sqrt{x}=x^{1/2}=(e^{\ln x})^{1/2}=e^{\frac12\ln x}
$$
注意：由于计算机无法存储浮点数的精确值 (浮点数的存储方法可以参考 IEEE 754，后面有专门总结),而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在**误差**。例如当$x=2147395600$时，$e^{\frac12\ln x}$的计算结果与正确值 46340 相差 10$^{-11}$,这样在对结果取整数部分时，会得到 46339 这个错误的结果。因此在得到结果的整数部分ans后，我们应当找出**ans与$ans+1$中哪一个是真正的答案**。

```c++
class Solution {
public:
    int mySqrt(int x) 
    {
        if(x==0)return 0;
        int ans = exp(0.5*log(x));//C++语法上log(x)就是ln(x) 
        return ((long long)(ans+1)*(ans+1)<=x?ans+1:ans);
    }
};
```



### （3）牛顿迭代法

![image-20250210150547135](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250210150547135.png)

![image-20250210150618944](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250210150618944.png)

![image-20250210150628361](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250210150628361.png)

![image-20250210150658261](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250210150658261.png)

使用牛顿迭代的代码如下：
```c++
class Solution {
public:
    int mySqrt(int x) {
        if(x==0) return 0;
        int start = x; //从x的位置开始迭代
        double last_value = start, this_value = 0;
        double eps = 1e-6;
        while(true) {
            this_value = 0.5 * (last_value + x * 1.0/last_value);
            if(abs(this_value-last_value)<=eps) break;
            last_value = this_value; 
        }
        return (int)this_value;
    }
};
```



## 【12】判断是否是凸多边形

解决方案：依次对多边形的相邻边做叉乘，如果每一组边叉乘的结果都是同向的，则为凸多边形，否则是凹多边形。

**复习一下，二维向量的叉乘：**

![image-20250210152139441](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250210152139441.png)

本题的题解为：

```c++
class Solution {
public:
    bool isConvex(vector<vector<int>>& points) 
    {
        int N = points.size();
        long pre = 0;
        for (int i = 0; i < N; ++i) 
        {
            long cur = angle({points[i], points[(i + 1) % N], points[(i + 2) % N]});
            if (cur != 0) 
			{
                if (cur * pre < 0)
                    return false;
                else
                    pre = cur; //第一次判断叉乘的时候，cur*pre=0，会进入这个逻辑，不会return false，后面则要保证朝向一致。
            }
        }
        return true;
    }
    int angle(vector<vector<int>> A) 	
    {
        return  (A[1][0] - A[0][0]) * (A[2][1] - A[0][1]) - 
                (A[1][1] - A[0][1]) * (A[2][0] - A[0][0]);

    }
};
```



## 【13】素数筛

![image-20250212122103060](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/image-20250212122103060.png)

```c++
//比较适用于打表的场景,把范围内的质数筛出来
vector<int> primes;
void init()
{
    isPrime.resize(MAX+1,1);
    isPrime[0]=0;
    isPrime[1]=0;
    for(int i=2;i<=MAX;i++)
    {
        if(isPrime[i])
        {
            primes.push_back(i); //同时，这个逻辑还可以判断质数
            for(int j=i;j<=MAX/i;j++)  //这样做是为了防止溢出
                isPrime[i*j]=0; //相当于这些都不是质数
        }  
    }
}
```



# C#篇

## 【1】装箱和拆箱

https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/types/boxing-and-unboxing

在C#中：

- 值类型有Sbyte、Byte、Short、Ushort、Int、Uint、Long、Ulong、Char、Float、Double、Bool、Decimal）、枚举([enum](https://so.csdn.net/so/search?q=enum&spm=1001.2101.3001.7020))、结构(struct)等；
- 引用类型有：类、数组、接口、委托、字符串等。

### （1）装箱

装箱就是**隐式**的将一个**值类型**转换为 **`object` 类型/引用型对象**。装箱用于在垃圾回收堆中存储值类型。 装箱是值类型到 `object` 类型或到此值类型所实现的任何接口类型的隐式转换。 **对值类型装箱会在堆中分配一个对象实例，并将该值复制到新的对象中。**

常见语言运行时 (CLR) 对值类型进行装箱时，会将值包装在 [System.Object](https://learn.microsoft.com/zh-cn/dotnet/api/system.object) 实例中并将其存储在托管**堆**中。 

```C#
int i = 123;
// Boxing copies the value of i into object o.
object o = i; //System.Object
//也可以显式装箱，但不是必须的
object o = (object)i;  // explicit boxing
```

其原理可以看下图：

![显示 i 和 o 变量之间的差异的图。](assets/boxing-operation-i-o-variables.gif)

上面代码的结果是在栈上创建对象引用 `o`，而在堆上则引用 `int` 类型的值。 该值是赋给变量 `i` 的值类型值的**一个副本**。**注意，原始值类型和装箱的对象使用不同的内存位置，因此能够存储不同的值。**看下面这个例子：

```c#
class TestBoxing
{
    static void Main()
    {
        int i = 123;

        // Boxing copies the value of i into object o.
        object o = i;

        // Change the value of i.
        i = 456;

        // The change in i doesn't affect the value stored in o.
        System.Console.WriteLine("The value-type value = {0}", i);
        System.Console.WriteLine("The object-type value = {0}", o);
    }
}
/* Output:
    The value-type value = 456
    The object-type value = 123
*/
```

当我们对`i`进行装箱操作后，修改`i`的值并不会修改到装箱的对象，因为他们使用不同的内存地址。



注：**对于类（class）类型，本身就是引用类型，因此不需要装箱。**

比如下面这个例子：

```c#
class MyClass
{
    public int Value { get; set; }
}

// 实例化类
MyClass myObject = new MyClass();
object obj = myObject; // 这里没有装箱，因为 myObject 已经是引用类型
```

在 C# 中，所有类类型都是从 `System.Object` 类派生而来的，因此可以将任何类的实例直接赋值给一个 `object` 类型的变量，而无需进行显式的装箱操作。当你将一个类型转换为 `object` 时，你仍然保留了对原始类型的引用。这意味着你可以将其还原为原始类型（使用强制转换）。



### （2）拆箱

拆箱就是将一个引用型对象转换成任意值型 ，或者说从对象中提取值类型。**拆箱是显式的。**

拆箱是从 `object` 类型到[值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types)或从接口类型到实现该接口的值类型的显式转换。 取消装箱操作包括：

- 检查对象实例，以确保它是给定值类型的装箱值。
- 将该值从实例复制到值类型变量中。

下面的语句演示装箱和取消装箱两种操作：

C#

```csharp
int i = 123;      // a value type
object o = i;     // boxing
int j = (int)o;   // unboxing
```

下图演示了上述语句的结果：

![显示取消装箱转换的图。](assets/unboxing-conversion-operation.gif)

要在运行时成功拆箱，被拆箱的项必须是对一个对象的引用，该对象是先前通过装箱该值类型的实例创建的。 尝试拆箱 `null` 会导致 [NullReferenceException](https://learn.microsoft.com/zh-cn/dotnet/api/system.nullreferenceexception)。 尝试拆箱对不兼容值类型的引用会导致 [InvalidCastException](https://learn.microsoft.com/zh-cn/dotnet/api/system.invalidcastexception)。

下面的示例演示无效的拆箱及引发的 `InvalidCastException`。 使用 `try` 和 `catch`，在发生错误时显示错误信息。

```csharp
class TestUnboxing
{
    static void Main()
    {
        int i = 123;
        object o = i;  // implicit boxing

        try
        {
            int j = (short)o;  // attempt to unbox (1)
            System.Console.WriteLine("Unboxing OK.");
        }
        catch (System.InvalidCastException e)
        {
            System.Console.WriteLine("{0} Error: Incorrect unboxing.", e.Message);
        }
    }
}
//以上程序会输出Error: Incorrect unboxing.将(1)改为int j = (int)o则会正常输出Unboxing OK.
```



### （3）装箱、拆箱的性能开销和应用场景

**性能**：

- 相对于简单的赋值而言，装箱和取消装箱过程需要进行大量的计算。 对值类型进行装箱时，必须分配并构造一个新对象。 拆箱所需的强制转换也需要进行大量的计算，只是程度较轻。 有关更多信息，请参阅[性能](https://learn.microsoft.com/zh-cn/dotnet/framework/performance/performance-tips)。

**装箱与拆箱的应用场景：**

- 可以参考：https://www.runoob.com/csharp/csharp-arraylist.html

  - 例如`ArrayList` 是非泛型集合，所有元素被存储为 `object` 类型。这意味着它可以存储任意类型的对象，但需要注意装箱（boxing）和拆箱（unboxing）的性能影响。

比如下面这个例子：

```csharp
// String.Concat example.
// 42和true都需要进行装箱
Console.WriteLine(String.Concat("Answer", 42, true)); //输出：Answer42true

// List example.创建一个可以装任意值类型或引用类型的List
List<object> mixedList = new List<object>();
mixedList.Add("First Group:");

for (int j = 1; j < 5; j++)
{
    mixedList.Add(j); //Add值类型时发生装箱
}

mixedList.Add("Second Group:");
for (int j = 5; j < 10; j++)
{
    mixedList.Add(j);
}

// Display the elements in the list. Declare the loop variable by
// using var, so that the compiler assigns its type.
foreach (var item in mixedList)
{
    Console.WriteLine(item);
}

var sum = 0;
for (var j = 1; j < 5; j++)
{
    sum += (int)mixedList[j] * (int)mixedList[j]; //必须要显式拆箱，否则会报错
}

// The sum displayed is 30, the sum of 1 + 4 + 9 + 16.
Console.WriteLine("Sum: " + sum);
```



## 【2】C#各种容器背后的数据结构

> - `List<T>`:动态数组（相当于C++的vector）：自动扩容的数组，连续内存，支持快速随机访问（一定程度上等效于`ArrayList`：[C# List（列表） - C#教程 - 菜鸟教程](https://www.cainiaojc.com/csharp/csharp-list.html)）；
> - `Dictionary<TKey, TValue>`：哈希表（相当于C++的`unordered_map`）：数组+链地址法，平均O(1)查找时间复杂度；
> - `HashSet<T>`，哈希表：类似字典，仅存储key，用于去重和快速存在性检查；
> - `SortedSet<T>`/`SortedDictionary<TKey, TValue>`：红黑树，自平衡二叉搜索树，保持元素有序，插入/删除/查找的时间复杂度均为O(nlogn)；
> - `LinkedList<T>`：**双向链表，**非连续内存，节点含前后引用，插入/删除复杂度O（1）；
> - `Queue<T>`：循环数组：数组实现，FIFO，自动扩容；[Queue 类 (System.Collections) | Microsoft Learn](https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.queue?view=net-8.0)
> - `Stack<T>`：数组实现，LIFO，动态调整容量；
> - `SortedList<TKey, TValue>`：有序数组：按键排序，插入需移动元素，适合少量数据；



## 【3】C#什么时候是值传递，什么时候是引用传递？

> 在 C# 中，参数传递方式如下：
>
> ### **值传递（默认行为）**
>
> - 值类型（int、struct等）：传递值的副本，方法内修改不影响原始变量。
>
>   ```c#
>   void Modify(int x) { x = 10; }
>   int a = 5;
>   Modify(a); // a 仍为 5
>   ```
>
> - 引用类型（class、string等）：传递引用的副本，方法内修改对象属性会影响原始对象，但重新赋值参数（指向新对象）不影响原变量。
>
>   ```c#
>   void ModifyObj(MyClass obj) { obj.Value = 10; }  // 修改属性会影响原对象
>   void ReassignObj(MyClass obj) { obj = new MyClass(); }  // 重新赋值不影响原变量
>   ```
>
> ### **引用传递（使用 `ref`/`out`）**
>
> - 值类型或引用类型：传递变量的直接引用，方法内修改变量值或重新赋值均影响原始变量。
>
>   ```c#
>   void ModifyRef(ref int x) { x = 10; }
>   int a = 5;
>   ModifyRef(ref a); // a 变为 10
>             
>   void ReassignRef(ref MyClass obj) { obj = new MyClass(); } //回忆C++，相当于对指针的引用
>   MyClass obj = new MyClass();
>   ReassignRef(ref obj); // obj 指向新对象
>   ```
>
> ### **总结**
>
> | **场景**                   | **传递方式**       | **影响原始变量**                 |
> | -------------------------- | ------------------ | -------------------------------- |
> | 值类型（无 `ref`/`out`）   | 值传递（副本）     | ❌ 修改值不影响                   |
> | 引用类型（无 `ref`/`out`） | 值传递（引用副本） | ✔️ 修改属性影响，❌ 重新赋值不影响 |
> | 使用 `ref`/`out`           | 引用传递           | ✔️ 修改值或重新赋值均影响         |
>
> **关键点**：
>
> - 默认参数传递是值传递（值类型传值副本，引用类型传引用副本）。
> - `ref`/`out` 强制引用传递，直接操作原始变量。



## 【4】C#中`ref`和`out`的区别

| **特性**       | **`ref`**                | **`out`**                         |
| -------------- | ------------------------ | --------------------------------- |
| **初始化要求** | 调用前**必须初始化**变量 | 调用前**无需初始化**变量          |
| **方法内赋值** | 不强制在方法内赋值       | 必须在方法内**显式赋值**          |
| **设计目的**   | 传入**已有值**并可能修改 | 用于**输出结果**（类似返回值）    |
| **使用场景**   | 需要修改外部变量时       | 需要返回多个值时（如 `TryParse`） |
| **编译器检查** | 无强制赋值检查           | 确保方法返回前必须赋值            |

**核心区别**：

1. `ref` 传递已初始化的变量（输入+输出），`out` 仅用于输出结果（无需初始值）。
2. `out` 强制方法内赋值，`ref` 不强制。



## 【5】C#的编译过程

.NET 是一个免费的跨平台开放源代码开发人员平台，用于生成多种类型的应用程序。 .NET 可以运行使用多种语言编写的程序，其中 C#是最常用的语言。 .NET 依赖于许多大规模应用在生产中使用的高性能运行时。

C#的编译过程可以分为以下几个步骤：

1. **源代码编译为IL（Intermediate Language）**：当你编写C#代码并编译时，C#编译器（如`csc.exe`）会将你的源代码编译为中间语言（IL），也称为MSIL（Microsoft Intermediate Language）或CIL（Common Intermediate Language）。**IL是一种与平台无关的低级语言**，类似于汇编语言，但它并不是机器码。

2. **IL存储在程序集中**：编译后的IL代码会被存储在程序集（通常是`.dll`或`.exe`文件）中。程序集还包含元数据，用于描述程序集中的类型、方法、属性等信息。

3. **JIT编译（Just-In-Time Compilation）**：当程序运行时，.NET运行时（CLR，Common Language Runtime）会通过JIT编译器将IL代码编译为本地机器码以及做内存管理。JIT编译是动态进行的，只有在方法第一次被调用时才会被编译为机器码。这种方式可以提高程序的启动速度，并且允许进行一些运行时优化。

4. **执行机器码**：一旦IL代码被JIT编译为机器码，CPU就可以直接执行这些机器码指令。

**总结：** C#的编译过程分为两个主要阶段：首先将源代码编译为IL，然后在运行时通过JIT编译器将IL编译为机器码并执行。

在微软的.Net框架中，任何语言只有能编译成IL后才能被CLR执行，也就是说C#需要一个编译器来编译为IL，还需要有一个CLR来负责翻译IL，Unity选择的是Mono，Mono是另一家公司做的跨平台的开源.Net FrameWork实现，但后面Mono好像很久没维护了，Unity已经把IL2CPP作为其核心了。下图是C#,IL,CLR之间的关系：

![img](%E9%9D%A2%E7%BB%8F%E5%90%88%E9%9B%86%E2%80%94%E2%80%94%E9%A2%98%E7%9B%AE+%E7%AD%94%E6%A1%88%E7%89%88.assets/v2-2cb4dc4209c7a30f7dc4f3747901bf68_r.jpg)

这一部分可以**顺便提及Mono与IL2CPP的区别，在Unity篇有进行整理。**

推荐阅读文章：[从零开始讲解HybirdCLR 热更 - 知乎](https://zhuanlan.zhihu.com/p/685026219)



## 【6】C#的字符串是什么类型？ C#两个字符串相同，指向同一个地方吗？

https://developer.aliyun.com/article/298536

在C#中，字符串是`System.String`类型，它是一个引用类型。字符串在C#中是不可变的（immutable），这意味着一旦字符串被创建，它的内容就不能被修改。

**关于字符串相同是否指向同一个地方：**

在C#中，字符串有一个称为“字符串驻留”（String Interning）的特性。当你创建两个内容相同的字符串时，CLR会尝试将它们指向同一个内存地址，以减少内存占用。例如：

```csharp
string str1 = "hello";
string str2 = "hello";
```

在这个例子中，`str1`和`str2`会指向同一个内存地址，因为它们的值是相同的，CLR会进行字符串驻留优化。

但是，如果你通过`new`关键字显式创建字符串，或者通过字符串拼接等方式动态生成字符串，CLR可能不会进行驻留，这时两个内容相同的字符串可能不会指向同一个地方：

```csharp
string str3 = new string("hello");
string str4 = new string("hello");
```

在这个例子中，`str3`和`str4`虽然内容相同，但它们指向不同的内存地址。

**总结：** C#中的字符串是`System.String`类型，是不可变的引用类型。如果两个字符串的内容相同，CLR可能会通过字符串驻留机制让它们指向同一个内存地址，但通过`new`关键字创建的字符串不会进行驻留。

> 补充知识：
>
> ### 重新赋值 vs 修改内容
>
> - **重新赋值**：你可以将一个字符串变量重新赋值为另一个字符串。这并不会修改原有的字符串对象，而是让变量指向一个新的字符串对象。
>
>  ```csharp
> string str = "hello";
> str = "world";  // 重新赋值，str现在指向一个新的字符串对象
>  ```
>
> - **修改内容**：不能直接修改一个字符串对象的内容。例如，你不能通过索引来修改字符串中的某个字符：
>
>  ```csharp
> string str = "hello";
> str[0] = 'H';  // 这行代码会编译错误，因为字符串是不可变的
>  ```
>
> ### 为什么字符串要设计为不可变？
>
> 1. **线程安全**：由于字符串是不可变的，它们可以被多个线程共享而不需要额外的同步机制。
> 2. **性能优化**：字符串驻留（String Interning）等优化技术依赖于字符串的不可变性。
> 3. **安全性**：不可变性可以防止字符串在不知情的情况下被修改，这在处理敏感数据时尤为重要。
>
> ### 如何“修改”字符串？
>
> 如果你需要频繁修改字符串内容，可以使用`StringBuilder`类。**`StringBuilder`是一个可变的字符串缓冲区，它允许在不创建新对象的情况下修改字符串内容。**
>
> 例如：
>
> ```csharp
> StringBuilder sb = new StringBuilder("hello");
> sb[0] = 'H';  // 可以直接修改字符
> sb.Append(" world");  // 可以追加字符串
> string result = sb.ToString();  // 最终转换为字符串
> ```
>
> **总结：** C#中的字符串是不可变的，这意味着你不能修改一个已存在的字符串对象的内容。你可以通过重新赋值来让字符串变量指向一个新的字符串对象，但这并不会修改原有的字符串。如果需要频繁修改字符串内容，可以使用`StringBuilder`。



## 【7】关于C#的Dictionary，Equals和GetHashCode==（※）==

应用场景： **A*寻路 Node（F=G+H）,OpenList和CloseList用Dictionary存，这时就有一个需求：`Dictionary<Int2, Node>`**。（Int2是Key，表示位置；Node是对应的节点）；针对Int2需要重写Equals和GetHashCode两个方法。

参考链接：[聊一聊C#的Equals()和GetHashCode()方法 - 袈裟和尚 - 博客园](https://www.cnblogs.com/xiaochen-vip8/p/5506478.html)

[(99+ 封私信 / 82 条消息) c#重写equals后为什么还要重写getHashCode? - 知乎](https://www.zhihu.com/question/547531189)



其实C#框架在判等的时候，是先调GetHashCode，相等了再调Equals，即比对HashCode优先，HashCode不相等就视为不同对象，不再走Equals。**GetHashCode 不等的东西必然不 Equals**，会作为新的条目放进哈希表 。

### （1）Equals写对了，但是GetHashCode写的不好会怎么样

有可能会影响业务的逻辑，但是效率可能会很低。

此时如果Equals写对了，但是GetHashCode写的不好：

- **此时GetHashCode可能会导致很多不同的对象判断HashCode相等，导致还要额外调用Equals判断，造成性能下降。**举例来说，极端情况下`GetHashCode`直接return 0，此时运行效率会降低。
- 由于Equals写对了，此时C#也只是会给出警告；
- 实际上也有可能会导致业务出现问题，比如我们认为是同一个对象的Key，如果完全没写GetHashCode，可能会导致编译器自由发挥，导致在Dictionary中加入了新的条目，此时查找结果可能会不稳定（有可能找到对象1，也可能找到对象2）
  - [(99+ 封私信 / 82 条消息) c#重写equals后为什么还要重写getHashCode? - 知乎](https://www.zhihu.com/question/547531189)



### （2）Equals写错了会怎么样

会出现达不到业务需求的情况，此时相同的对象可能会判断为不同（导致重复对象更新时在哈希表中插入新条目），不同的对象也可能判断为相同（新的对象可能会覆盖旧的对象的值）。**都会导致业务出现问题。**



综合结论：

- GetHashCode须轻量迅速，避免复杂逻辑和大开销。
- 相等的对象HashCode**必须相同**，不等的对象HashCode要**尽量不同**，实在做不到不同也是允许的同时也是不可避免的，hash哈希本质上就是取特征，碰撞是不可避免的，所以才需要Equals兜底。做到尽量不同是为了尽量避免走Equals，因为Equals是允许/可能存在复杂逻辑的。



# 游戏开发其他知识点篇

## 【1】CRC循环校验

| **CRC循环冗余校验** | **说明**                                                     |
| ------------------- | ------------------------------------------------------------ |
| **原理**            | 通过多项式除法生成校验码，附加到数据尾部，接收端重新计算并对比校验码检测错误。 |
| **特点**            | 1. **高效**：计算速度快，硬件易实现 2. **强检错**：可检测多位错误、突发错误 3. **非加密**：仅检错，不纠错 |
| **常用多项式**      | CRC-32（网络通信）、CRC-16（Modbus）、CRC-CCITT（蓝牙）等    |
| **应用场景**        | 网络通信（以太网、Wi-Fi）、存储系统（硬盘、RAID）、文件压缩（ZIP/RAR）、嵌入式设备数据传输校验 |

**核心总结**：CRC是一种高效、可靠的轻量级数据完整性验证算法，广泛用于通信与存储系统的错误检测。CRC校验码生成过程本质是**多项式模2除法求余数。**

其他内容可以看这篇文章：[【科普向】谁都能看懂的CRC（循环冗余校验）原理_crc循环冗余校验原理-CSDN博客](https://blog.csdn.net/weixin_44256803/article/details/105805628)，应该不需要再深入了。



# Leetcode:







C#的编译过程:.Net,IL,JIT


C#的字符串是什么类型？ C#两个字符串相同，指向同一个地方吗？

unity协程,unity协程和C#多线程使用上的区别，C#异步


unity脚本的生命周期


update，lateupdate和fixedupdate


可靠UDP的实现，如何减少UDP丢包


定点数的实现


怎么判断子弹与人物的碰撞

讲一下RTTI（没听说过，面试官提示我四种类型转换），讲一下dynamic_cast原理（不会，瞎猜了一个跟虚函数表有关）。


算法题: 1.牛顿迭代法开方 2.判断多边形是否是凸包





# 其他未整理问题

【1】平常玩啥游戏？解释一下你玩的游戏中的网络协议。

【2】手撕（没看懂啥意思，别的地方看到了再整理进算法篇里吧）：1.图片求内存 2.数字逻辑题 3.扑克牌问题

【3】动态规划实际上的应用：在游戏开发中，那种走格子的小游戏可能会用动规吧hhh，多做点题就知道动规的应用场景了。

【4】Entity Framework：这个简单搜了一下似乎跟SQL和数据库有关，可能是结合项目的题目，这里就暂时不研究了。

【5】实现一个游戏中的Buff系统，简单看了一下这个：比较推荐这篇文章：[Unity3D 实现简单的Buff系统_unity 持续一段时间的buff-CSDN博客](https://blog.csdn.net/qq_18192161/article/details/79296942)，还没认真看和实践，但感觉可以参考的样子。

【6】数据库：两表查询

【7】



# 面经链接合集

【1】[游戏客户端秋招面经总结_牛客网](https://www.nowcoder.com/discuss/702122998706262016?sourceSSR=search)

【2】[腾讯IEG游戏客户端一面二面面经_牛客网](https://www.nowcoder.com/discuss/603563266169733120?sourceSSR=search)
# 引擎工程师笔试题——1

## 1.以下程序输出什么？

```c++
#include <iostream>
class ComponentA
{
public:
  ComponentA()
  {
    std::cout << "a";
  }
  ~ComponentA()
  {
    std::cout << "~a";
  }
};

class ComponentB
{
public:
  ComponentB()
  {
    std::cout << "b";
    throw std::exception();
  }
  ~ComponentB()
  {
    std::cout << "~b";
  }
};

class ComponentC
{
public:
  ComponentC()
  {
    std::cout << "c";
  }
  ~ComponentC()
  {
    std::cout << "~c";
  }
};

class Container
{
  ComponentA m_a;
  ComponentB m_b;
  ComponentC m_c;
public:
  Container()
  {
    std::cout << "d";
  }
  ~Container()
  {
    std::cout << "~d";
  }
};

int main()
{
  try
  {
    Container c;
  }
  catch (std::exception const &)
  {
  }
  return 0;
}
```

以下是本道题目的解析：

> 这个程序的输出是：`ab~a`。（经过VS实测是这样）
>
> **输出分析**：  
>
> 1. 构造`ComponentA m_a`，输出`a`。  
> 2. 构造`ComponentB m_b`，输出`b`，此时构造函数抛出异常，程序中断。  
> 3. 栈展开过程中，已构造的`m_a`会被析构，输出`~a`。  
> 4. `ComponentB`的构造函数未完成，因此不会调用其析构函数。  
> 5. `ComponentC m_c`和`Container`的构造函数均未执行，因此无`c`、`d`及对应的析构输出。
>
> **考察知识点**：  
> 1. **成员变量的构造顺序**：按声明顺序（`m_a` → `m_b` → `m_c`）。  
> 2. **构造函数抛出异常时的析构行为**：已成功构造的成员会调用析构函数，未完成构造的成员和对象本身不会调用析构函数。  
> 3. **栈展开机制**：异常导致已构造的局部对象（如`m_a`）析构，保障资源不泄漏。



## 2.以下程序会输出什么？

```c++
#include <iostream>
#include <memory>

class SomeRes : public std::enable_shared_from_this<SomeRes>
{
  void Foo() const
  {
    std::cout << weak_from_this().lock().use_count();
  }

public:
  auto operator()() const
  {
    return [self = shared_from_this()]
    {
      self->Foo();
    };
  }
};

int main()
{
  auto res = std::make_shared<SomeRes>();
  (*res)()();
  std::cout << res.use_count();
  return 0;
}
```

> 这个程序的输出是**31**。
>
> **输出分析**：  
> 1. `std::make_shared<SomeRes>()` 创建 `res`，引用计数为 1。  
> 2. `(*res)()()` 的执行过程：  
>    - `operator()()` 中通过 `shared_from_this()` 捕获 `self`，引用计数增至 2。  
>    - Lambda 被调用时，`self->Foo()` 中 `weak_from_this().lock()` 生成临时 `shared_ptr`，引用计数短暂增至 3，输出 **3**。  
>    - 临时 `shared_ptr` 析构，引用计数回到 2。  
>    - Lambda 执行完毕，`self` 析构，引用计数回到 1。  
> 3. `res.use_count()` 输出 **1**，最终输出为 **31**。
>
> **考察知识点**：  
>
> 1. **`std::enable_shared_from_this` 的用途**：  
>    - 安全地在类内部获取与对象关联的 `shared_ptr`，避免通过裸指针直接构造 `shared_ptr` 导致的双重释放问题。  
>
> 2. **共享指针的引用计数机制**：  
>    - `shared_ptr` 的捕获（如 Lambda 中的 `self`）会增加引用计数。  
>    - 临时 `shared_ptr`（如 `weak_from_this().lock()` 的结果）会短暂增加引用计数。  
>
> 3. **弱指针 (`weak_ptr`) 的作用**：  
>    - 通过 `weak_from_this()` 获取弱指针，避免循环引用。  
>    - `lock()` 安全地尝试获取 `shared_ptr`，若对象存活则返回有效指针，否则返回空。  
>
> 4. **Lambda 捕获与对象生命周期**：  
>    - Lambda 中捕获 `shared_ptr` 会延长对象的生命周期。  
>    - 临时 Lambda 对象销毁时，其内部捕获的 `shared_ptr` 析构，引用计数减少。  
>
> 5. **成员函数调用与 `const` 限定**：  
>    - `Foo()` 是 `const` 成员函数，但仍可通过 `shared_from_this()` 获取非 `const` 的 `shared_ptr`（因 `shared_from_this()` 本身是 `const` 安全的）。  
>
> **关键点**：  
> - 理解 `shared_from_this()` 的正确使用场景（对象必须由 `shared_ptr` 管理）。  
> - 分析临时 `shared_ptr` 对引用计数的短暂影响。  
> - 明确 Lambda 捕获 `shared_ptr` 对生命周期的控制作用。

这道题目考察了一些之前没有接触到的知识点。这里补充一下。

### （1）`enable_shared_from_this`

比较推荐阅读这篇文章：[STL enable_shared_from_this深入了解 - 知乎](https://zhuanlan.zhihu.com/p/638029004)。暂时应该理解到这里就可以了（源码部分还没有看），剩下的随着不断学习再逐渐掌握。

> 额外知识点补充:[c++ make_shared的使用及注意事项_makeshared 用法-CSDN博客](https://blog.csdn.net/qq_26093511/article/details/131205849).
>
> 以下代码为什么报错?
>
> ```c++
> class Genshin : public std::enable_shared_from_this<Genshin>
> {
> public:
>     static std::shared_ptr<Genshin> Create()
>     {
>         //return std::make_shared<Genshin>(); //报错,make_shared调用需要有完整的类定义
> 		return std::shared_ptr<Genshin>(new Genshin()); //这句是正确的
>     }
>     std::shared_ptr<Genshin> GetPtr()
>     {
>         return shared_from_this();
>     }
> private:
>     Genshin() = default;
> };
> ```
>
> 需要注意的是，`make_shared` 参数必须是完整类型，因此需要提前定义 `MyClass` 类。接着，我们可以使用箭头运算符 `->` 来调用 `MyClass` 中的成员函数。



## 3.以下程序输出什么？

```c++
#include <iostream>
void Bar()
{
  std::cout << "Bar()" << std::endl;
}

template <typename T>
class BaseTpl
{
protected:
  void Bar()
  {
    std::cout << "BaseTpl::Bar()" << std::endl;
  }
};

template <typename T>
class DerivedTpl : BaseTpl<T>
{
public:
  void Foo()
  {
    Bar();
  }
};

class Base
{
protected:
  void Bar()
  {
    std::cout << "Base::Bar()" << std::endl;
  }
};

class Derived : public Base
{
public:
  void Foo()
  {
    Bar();
  }
};

int main()
{
  DerivedTpl<int> d1;
  d1.Foo();

  Derived d2;
  d2.Foo();

  return 0;
}
```

> 这个程序的输出结果是：  
> **Bar()**  
> **Base::Bar()**
>
> ---
>
> ### **分析过程**  
> 1. **`DerivedTpl<int> d1; d1.Foo();` 的输出**  
>    - `DerivedTpl` 是一个模板类，继承自依赖模板参数 `T` 的基类 `BaseTpl<T>`。  
>    - 在 `Foo()` 中调用 `Bar()` 时，由于基类 `BaseTpl<T>` 是模板依赖的，**编译器不会隐式查找基类中的成员** `Bar()`。  
>    - 此时会找到全局函数 `Bar()`，因此输出 `Bar()`。
>
> 2. **`Derived d2; d2.Foo();` 的输出**  
>    - `Derived` 是非模板类，继承自 `Base`，且 `Base::Bar()` 是 `protected` 成员。  
>    - 在 `Foo()` 中调用 `Bar()` 时，编译器会**直接查找基类作用域**中的 `Bar()`，因此输出 `Base::Bar()`。
>
> ---
>
> ### **考察的知识点**  
> 1. **模板依赖基类的名称查找规则**  
>    - 当派生类是模板类且基类依赖模板参数时，基类的成员不会隐式可见，必须通过 `this->` 或基类名显式访问（如 `this->Bar()` 或 `BaseTpl<T>::Bar()`）。  
>    - 若未显式指定，编译器会优先查找全局作用域或其他非依赖作用域的同名符号。
>
> 2. **非模板类的继承与名称查找**  
>    - 在非模板派生类中，基类的成员名称会被隐式查找，可以直接访问基类的 `protected` 成员。
>
> 3. **全局函数与类成员的作用域优先级**  
>    - 全局函数可能被模板派生类“意外”调用（当基类成员未显式指定时）。
>
> 4. **访问控制与名称解析的顺序**  
>    - 名称解析（确定调用哪个符号）在访问控制（如 `public`/`protected`）检查之前完成。即使基类的 `Bar()` 是 `protected`，若编译器未找到基类中的 `Bar()`，也不会触发访问控制错误。
>
> ---
>
> ### **关键代码对比**  
> ```cpp
> // 模板派生类（错误用法）
> void Foo() { Bar(); }      // 调用全局 Bar()
> 
> // 正确写法需显式指定基类成员
> void Foo() { this->Bar(); }  // 或 BaseTpl<T>::Bar();
> ```
>
> ```cpp
> // 非模板派生类（正确用法）
> void Foo() { Bar(); }      // 正确调用基类 Base::Bar()
> ```

关于上面的第四点，还有一些补充内容：

> **访问控制与名称解析的顺序**  
>
> - 名称解析（确定调用哪个符号）在访问控制（如 `public`/`protected`）检查之前完成。即使基类的 `Bar()` 是 `protected`，若编译器未找到基类中的 `Bar()`，也不会触发访问控制错误。
>
> 
>
> 具体解释如下：
>
> 在 C++ 中，名称解析（Name Lookup）和访问控制（Access Control）是两个独立的编译阶段，且**顺序严格固定**：  
> **名称解析在前，访问控制在后**。这意味着编译器会先确定一个符号（如 `Bar()`）的实体是什么，再检查是否有权限访问它。若名称解析阶段未找到对应的符号，编译器会直接报错（未声明），而不会进入访问控制阶段。
>
> ---
>
> ### **具体场景分析**  
> #### 1. 模板类 `DerivedTpl` 的情况  
> ```cpp
> template <typename T>
> class DerivedTpl : BaseTpl<T> {
> public:
>   void Foo() {
>     Bar(); // 调用全局 Bar()，而非基类的 BaseTpl<T>::Bar()
>   }
> };
> ```
>
> - **名称解析阶段**：  
>   编译器在 `Foo()` 中查找 `Bar()` 时：  
>   - 由于 `BaseTpl<T>` 是依赖模板参数的基类（Dependent Base Class），**默认不会隐式查找其成员**。  
>   - 因此，编译器会直接查找全局作用域，找到全局函数 `Bar()`。  
>
> - **访问控制阶段**：  
>   全局函数 `Bar()` 是 `public` 的，可以访问，不会报错。  
>   （即使基类 `BaseTpl<T>::Bar()` 是 `protected`，但名称解析阶段未找到它，故不会检查其访问权限。）
>
> #### 2. 非模板类 `Derived` 的情况  
> ```cpp
> class Derived : public Base {
> public:
>   void Foo() {
>     Bar(); // 正确调用 Base::Bar()
>   }
> };
> ```
>
> - **名称解析阶段**：  
>   编译器在 `Foo()` 中查找 `Bar()` 时：  
>   - 非模板基类 `Base` 的成员会被隐式查找，找到 `Base::Bar()`。  
>
> - **访问控制阶段**：  
>   `Base::Bar()` 是 `protected` 的，而 `Derived::Foo()` 是 `Derived` 的成员函数，可以访问基类的 `protected` 成员，因此合法。
>
> ---
>
> ### **关键区别**  
> - **若名称解析未找到符号**：直接报错“未声明”，**不会触发访问控制检查**。  
> - **若名称解析找到符号**：进入访问控制检查，若权限不足（如 `private`），报错“无法访问”。  
>
> #### 示例扩展  
> 假设全局没有 `Bar()`，且 `BaseTpl<T>::Bar()` 是 `private`：  
> ```cpp
> template <typename T>
> class BaseTpl {
> private: // 改为 private
>   void Bar() { ... }
> };
> 
> template <typename T>
> class DerivedTpl : BaseTpl<T> {
> public:
>   void Foo() {
>     Bar(); // 错误：名称解析失败（全局无 Bar()）
>   }
> };
> ```
> - 编译器在名称解析阶段找不到全局 `Bar()`，直接报错“`Bar` 未声明”，而不是检查基类的 `private` 权限。
>
> ---
>
> ### **总结**  
> - **名称解析是“找得到找不到”的问题**，访问控制是“能否用找到的东西”的问题。  
> - 若名称解析失败（如模板依赖基类未显式指定成员），编译器不会检查基类成员的访问权限，而是直接报错或调用其他作用域的同名符号。  
> - 若名称解析成功，才会进一步检查访问权限（如 `protected`/`private`）。  
>
> 这一机制确保了编译器的行为逻辑清晰：**先确定符号存在性，再确定能否使用**。

| 继承方式      | 基类的public成员  | 基类的protected成员 | 基类的private成员 | 继承引起的访问控制关系变化概括         |
| :------------ | :---------------- | :------------------ | :---------------- | :------------------------------------- |
| public继承    | 仍为public成员    | 仍为protected成员   | 不可见            | 基类的非私有成员在子类的访问属性不变   |
| protected继承 | 变为protected成员 | 变为protected成员   | 不可见            | 基类的非私有成员都为子类的保护成员     |
| private继承   | 变为private成员   | 变为private成员     | 不可见            | 基类中的非私有成员都称为子类的私有成员 |

更多参考资料:[C++ 模板 5： 类模板的继承和成员函数 - 知乎](https://zhuanlan.zhihu.com/p/463066090)



## 4.已知平面A上两个非平行的单位向量i和j，以及平面上一点P0。通过以下哪种计算能快速判断空间中一点P1是否在平面A上？

- dot(cross(i, j), P1-P0)
- cross(cross(i, j), P1-P0)
- dot(dot(i, j), P1-P0)
- cross(dot(i, j), P1-P0)

答案应该是`dot(cross(i, j), P1-P0)`



## 5.构建模型从世界空间到相机空间的变换矩阵需要哪些参数？

A

摄像机的FOV，摄像机的近平面，摄像机的远平面

B

视点位置，视目标位置，摄像机的Up向量

C

视目标位置，摄像机的近平面，摄像机的远平面

D

视点位置，摄像机的FOV，摄像机的Up向量



> 只是构建世界空间->相机空间的变换矩阵，B即可，不需要知道相机本身的信息（投影矩阵才需要）。所以选择B项即可。



## 6.不使用Reversed-Z的情况下，假设视锥体内一顶点在vs中做完投影变换之后的坐标为posH，若在vs中再加一行代码让该顶点画到远裁剪面上，以下做法正确的是

A

posH.w = 1

B

posH.z = posH.w

C

posH.z = 0

D

posH.z = 1

> 在标准OpenGL投影变换中，顶点经过投影矩阵后进入裁剪空间（Clip Space）。此时裁剪空间的坐标范围为 \([-w, w]\)，远裁剪面对应 \(z = w\)，归一化后（除以 \(w\)）的NDC坐标 \(z = 1\)。需通过修改顶点坐标 \(posH\) 的 \(z\) 分量，使其在远裁剪面位置。
>
> **关键分析**：
> 1. **选项B**：`posH.z = posH.w`  
>    - 裁剪空间中，\(z\) 的范围为 \([-w, w]\)。令 \(posH.z = posH.w\)，则归一化后 \(z = posH.z / posH.w = 1\)，对应远裁剪面。
>    - **正确**，直接匹配远裁剪面定义。
>
> 2. **选项D**：`posH.z = 1`  
>    - 若 $posH.w \neq 1$（例如透视投影中 \(w\) 通常存储视空间负 \(z\)），归一化后 \(z = 1 / posH.w\)，可能偏离远裁剪面。
>    - **错误**，仅当 \(w=1\) 时成立（如正交投影），但题目未特指此场景。
>
> 3. **选项A**：`posH.w = 1`  
>    - 修改 \(w\) 分量会破坏投影关系，导致深度计算错误，且不保证 \(z=1\)。
>    - **错误**。
>
> 4. **选项C**：`posH.z = 0`  
>    - 归一化后 \(z = 0\)，对应近裁剪面附近，与远裁剪面无关。
>    - **错误**。
>
> **答案**：**B**  
> **过程**：  
> - 投影变换后，远裁剪面在裁剪空间中为 \(z = w\)。  
> - 将 \(posH.z\) 设为 \(posH.w\)，确保归一化后 \(z = 1\)，顶点精确位于远裁剪面。

Reverse-Z可以用来解决Z-fighting的问题，具体在大笔记里会进行说明。
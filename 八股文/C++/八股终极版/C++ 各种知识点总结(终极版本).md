# C++ 知识点总结

# 基础八股

## 1.参考资料1

参考:[校招C++大概学习到什么程度？ - 知乎](https://zhuanlan.zhihu.com/p/405756420)

> 以下总结这里面不太会的内容，有一些八股比较基础答案需要的话自行翻阅链接即可。



### （1）基础题

#### （a）数组的一个问题

- [a和&a有什么区别？](https://link.zhihu.com/?target=https%3A//www.iamshuaidi.com/%3Fp%3D2343)

这道题目对应的代码如下：

```c++
#include <iostream>

int main() {
    int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // 声明一个指向数组的指针
    int (*p)[10] = &a;

    // 打印数组的首元素
    std::cout << "a[0]: " << a[0] << std::endl;           // 输出 0
    std::cout << "*p: " << (*p)[0] << std::endl;         // 输出 0

    // 地址计算
    std::cout << "Address of a: " << &a << std::endl;     // 输出数组a的地址
    std::cout << "Address of a + 1: " << (&a + 1) << std::endl; // 输出a尾元素后一个元素的地址

    // 指针转换
    int *intPtr = (int *)p;
    std::cout << "intPtr points to: " << *intPtr << std::endl; // 输出 0, 即 a[0]

    //p+1
    // 打印 p 和 p + 1 的值
    std::cout << "Address of p: " << p << std::endl;            // 输出数组a的地址
    std::cout << "Address of p + 1: " << (p + 1) << std::endl; // 输出a尾元素后一个元素的地址

    return 0;
}
```

GPT关于此的解释：

> ### 1. 数组名和数组指针
>
> 在C++中，数组名 `a` 实际上是指向该数组首元素的指针。因此，`a` 的值是 `&a[0]`，即数组第一个元素的地址。
>
> ### 2. 指针类型
>
> ```c++
> int (*p)[10] = &a;
> ```
>
> 这里，`p` 是一个指向包含 10 个 `int` 类型元素的数组的指针。`&a` 获取的是整个数组的地址，而不是单个元素的地址。
>
> ### 3. 地址运算
>
> - 当你对数组指针 `&a` 进行加法操作时，它会以整个数组的大小为单位向后移动：
>   - 数组 `a` 占用的空间是 `10 * sizeof(int)` 字节。
>   - 如果 `a` 的起始地址是 `0x00000001`，`&a + 1` 的结果将是 `0x00000001 + 10 * sizeof(int)`。
>
> 假设 `sizeof(int)` 为 4 字节，则：
>
> ```c++
> &a + 1 将变为 0x00000001 + 40 = 0x00000029
> ```
>
> ### 4. 解引用操作
>
> 当你将 `p` 转换成 `int*`，如 `(int*)p`，然后进行解引用：
>
> ```c++
> *(int *)p;
> ```
>
> 这实际上是取 `p` 所指向的数组的首元素的值。因此，`*(p)` 相当于 `a[0]`。
>
> ### 理解 `p + 1`
>
> 因为 `p` 是一个指向数组的指针，加 1 意味着将指针移动到下一个数组（即下一个包含 10 个 `int` 元素的数组）的起始地址。具体来说：
>
> - `p` 指向数组 `a` 的位置。
> - `p + 1` 将指向下一个 `int[10]` 数组的开始位置。
>
> 如果我们假设 `a` 的地址是 `0x00000001`，并且 `sizeof(int[10])` 是 40 字节（因为每个整数占用 4 字节），则：
>
> ```c++
> p + 1 将会是 0x00000001 + 40 = 0x00000029
> ```
>
> 这意味着 `p + 1` 实际上指向的是a尾元素后一个元素的地址，而不是 `a[10]`，因为 `a` 只有10个元素。



#### （b）static的用法

- 修饰局部变量时，使得该变量在静态存储区分配内存；只能在首次函数调用中进行首次初始化，之后的函数调用不再进行初始化；其生命周期与程序相同，但其作用域为局部作用域，并不能一直被访问；
- 修饰全局变量时，使得该变量在静态存储区分配内存；在声明该变量的整个文件中都是可见的，而在文件外是不可见的；
- 修饰函数时，在声明该函数的整个文件中都是可见的，而在文件外是不可见的，从而可以在多人协作时避免同名的函数冲突；
- 修饰成员变量时，所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享；不需要实例化对象即可访问；不能在类内部初始化，一般在类外部初始化，并且初始化时不加`static`；
- 修饰成员函数时，该函数不接受`this`指针，只能访问类的静态成员；不需要实例化对象即可访问。

> 代码可见cpp_02_static.cpp文件。



#### （c）const常量存在哪？

> 在 C++ 中，`const` 常量的存储位置取决于其定义方式和上下文。以下是 `const` 常量可能存储的几种内存空间：
>
> ### 1. **常量区域（Text Segment 或 Read-Only Data Segment）**
>
> - 对于全局或静态 `const` 常量，常量通常被存储在只读数据区。这是一个专门用于存放程序中所有只读数据（例如字符串文字、常量等）的区域。
> - 这些常量在程序运行时不可修改，因此将它们放置在只读区域可以防止意外修改。
>
> **示例：**
>
> ```c++
> const int globalConst = 10; // 存储在只读数据区
> ```
>
> ### 2. **栈内存**
>
> - 对于局部 `const` 常量，它们通常存储在栈上。这些常量在函数调用时分配内存，并在函数返回时自动释放。
> - 尽管它们是 `const`，但是由于它们的作用域仅限于函数内部，编译器仍然会为它们分配栈内存。
>
> **示例：**
>
> ```c++
> void func() {
>     const int localConst = 20; // 存储在栈内存
> }
> ```
>
> ### 3. **数据段**
>
> - 如果是 `const` 修饰的对象类型（如 `const std::string`），根据其具体实现和是否有静态存储期限，也可能在数据段中进行存储，尽管这较少见。
>
> ### 4. **优化与合并**
>
> - 编译器可能对常量进行优化，例如将相同的常量合并到一起，或者将其替换为字面值。这种情况下，常量可能并不在单独的存储位置，而是直接在使用的地方展开。
>
> ### 总结
>
> - **全局/静态 `const` 常量**：通常存储在只读数据区。
> - **局部 `const` 常量**：通常存储在栈内存。
> - **`const` 对象类型**：可能存储在数据段或其他适当的内存区域。
>   - 比如，如果一个 `const` 对象通过动态内存分配（例如使用 `new` 关键字）创建，则它将存储在堆内存中。
>   - 尽管对象是 `const`，但它仍然是在堆中分配的（==应该是？==）。



#### （d）静态链接库和动态链接库

可以复习这篇知乎文章：[(99+ 封私信 / 5 条消息) Linux 中的动态链接库和静态链接库是干什么的？ - 知乎](https://www.zhihu.com/question/20484931/answer/69553616)

以及这篇：[(99+ 封私信 / 5 条消息) 动态链接库与静态链接库有什么区别？ - 知乎](https://www.zhihu.com/question/439231062/answer/1678652070)

> 比较深的实现原理：[动态链接库的实现原理是什么？ - 知乎](https://zhuanlan.zhihu.com/p/709895388)，还没看，需要了再看。



#### （e）volatile的作用

[volatile有什么作用-帅地玩编程](https://www.iamshuaidi.com/2409.html)，平时感觉没太用到，需要再说吧。

[一个参数可以既是const又是volatile吗-帅地玩编程](https://www.iamshuaidi.com/2411.html)



#### （f）全局变量和局部变量有什么区别？编译器是如何知道的？

> 全局变量和局部变量在 C++ 中有几个关键的区别，主要涉及到作用域、生命周期、存储位置等方面。以下是它们的主要区别，以及操作系统和编译器如何识别这些变量。
>
> ### 全局变量与局部变量的区别
>
> | 特性         | 全局变量                                                     | 局部变量                                           |
> | ------------ | ------------------------------------------------------------ | -------------------------------------------------- |
> | **定义位置** | 在所有函数外部定义                                           | 在函数内部或代码块中定义                           |
> | **作用域**   | 在整个源文件中可见（或者跨多个文件，若使用 `extern` 关键字） | 仅在其定义的函数或代码块内可见                     |
> | **生命周期** | 从程序开始直到结束                                           | 当控制流进入其定义的作用域时创建，离开作用域时销毁 |
> | **存储位置** | 通常存储在静态存储区                                         | 存储在栈内存中                                     |
> | **初始化**   | 默认初始化为零（若未显式赋值）                               | 未初始化的局部变量具有未定义行为，除非显式赋值     |
>
> ### 操作系统和编译器如何识别
>
> 1. **编译阶段**：
>    - 编译器通过语法解析和作用域分析来理解变量的定义位置和作用范围。在编译过程中，编译器会构建符号表，其中记录了每个变量的名称、类型、存储位置、作用域等信息。
>    - 当编译器遇到一个变量定义时，它会根据该变量的位置判断该变量是全局变量还是局部变量。例如，位于函数外部的变量被标记为全局变量，而位于函数内部的变量被标记为局部变量。
> 2. **链接阶段**：
>    - 对于全局变量，编译器还需要处理链接。当一个源文件引用另一个源文件中的全局变量时，编译器将使用符号表来解析这些引用，并确保在最终的可执行文件中正确链接这些变量。
> 3. **运行时**：
>    - 操作系统负责管理不同的内存区域。全局变量通常分配在静态存储区或数据段，而局部变量则在栈上分配。当程序运行时，操作系统根据变量的作用域和生命周期，在适当的内存区域分配和释放内存。
> 4. **作用域规则**：
>    - C++ 语言规定了作用域的规则，例如，局部变量的作用域仅限于其所在的函数或代码块。这些规则帮助编译器决定变量的可见性和生命周期。



#### （g）strcpy，sprintf与memcpy

> `strcpy`、`sprintf` 和 `memcpy` 是 C/C++ 中常用的字符串和内存操作函数。它们各自有不同的用途和特性。以下是它们的具体区别以及相应的示例程序。
>
> ### 1. `strcpy`
>
> - **功能**：将一个字符串（包括结尾的空字符）复制到另一个字符数组。
> - **参数**：
>   - `char *dest`: 目标字符串，必须有足够的空间来容纳源字符串。
>   - `const char *src`: 源字符串，包含要复制的内容。
> - **返回值**：返回目标字符串的指针。
>
> #### 示例程序
>
> ```c++
> #include <iostream>
> #include <cstring> // 包含 strcpy 函数
> 
> int main() {
>     const char* source = "Hello, World!";
>     char destination[50]; // 确保目标数组足够大以容纳源字符串
>     
>     strcpy(destination, source); // 复制字符串
>     std::cout << "Copied String: " << destination << std::endl;
> 
>     return 0;
> }
> ```
>
> ### 2. `sprintf`
>
> - **功能**：根据格式化字符串将数据写入到字符数组中。类似于 `printf`，但输出到字符串而非标准输出。
> - **参数**：
>   - `char *str`: 目标字符串，用于保存格式化后的结果。
>   - `const char *format`: 格式化字符串，用于指定如何格式化后续参数。
>   - 可变参数：可以接受多个可变参数。
> - **返回值**：返回写入目标字符串的字符总数，不包括终止的空字符。
>
> #### 示例程序
>
> ```c++
> #include <iostream>
> #include <cstdio> // 包含 sprintf 函数
> 
> int main() {
>     char buffer[100];
>     int value = 42;
> 
>     sprintf(buffer, "The answer is %d", value); // 格式化字符串并保存到 buffer
>     std::cout << "Formatted String: " << buffer << std::endl;
> 
>     return 0;
> }
> ```
>
> ### 3. `memcpy`
>
> - **功能**：从源内存地址复制指定数量的字节到目标内存地址。适用于任意类型的数据，包括二进制数据。
> - **参数**：
>   - `void *dest`: 目标内存区域。
>   - `const void *src`: 源内存区域。
>   - `size_t n`: 复制的字节数。
> - **返回值**：返回目标内存的指针。
>
> #### 示例程序
>
> ```c++
> #include <iostream>
> #include <cstring> // 包含 memcpy 函数
> 
> int main() {
>     const char source[] = "Hello, World!";
>     char destination[50];
> 
>     memcpy(destination, source, strlen(source) + 1); // 复制字节，包括空字符
>     std::cout << "Copied Memory: " << destination << std::endl;
> 
>     return 0;
> }
> ```
>
> ### 总结比较
>
> | 函数      | 类型       | 目的                           | 注意事项                       |
> | --------- | ---------- | ------------------------------ | ------------------------------ |
> | `strcpy`  | 字符串操作 | 复制字符串，包含结束的空字符   | 必须确保目标数组足够大         |
> | `sprintf` | 格式化输出 | 将格式化的数据写入字符串       | 安全问题；使用 `snprintf` 更佳 |
> | `memcpy`  | 内存操作   | 从源地址复制指定字节到目标地址 | 不处理字符串结束符，需手动管理 |

- 操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。
- 执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。
- 实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。

**「注意」**：strcpy、sprintf 与memcpy 都可以实现拷贝的功能，但是针对的对象不同，根据实际需求，来选择合适的函数实现拷贝功能。

**具体可以参考cpp_03.cpp这个程序。**

> 有的八股可能会考这几个函数的手撕，但感觉优先级不是很高，先不整理了。



#### （h）==智能指针（重点）==

`auto_ptr`就不看了，基本被废弃了。主要是`unique_ptr`,`shared_ptr`和`weak_ptr`的实现和对应的demo，以及智能指针的实现原理和使用场景。这里推荐按照如下顺序复习：

【1】[现代 C++：一文读懂智能指针 - 知乎](https://zhuanlan.zhihu.com/p/150555165)

【2】关于循环引用的进一步介绍：[循环引用中的shared_ptr和weak_ptr - 知乎](https://zhuanlan.zhihu.com/p/355812360)

- 循环引用的问题，见cpp_circular reference.cpp文件
- 只能指针的玩具demo版，见cpp_toySmartPtr.cpp文件，可以在一定程度上解决循环引用的问题。

【3】智能指针的代码实现（**目前还没看**）：[C++智能指针简单实现（面试常问） - 知乎](https://zhuanlan.zhihu.com/p/344953368)

- shared_ptr动手实现的关键点：[shared_ptr是如何实现的？-帅地玩编程](https://www.iamshuaidi.com/2421.html)



#### RAII思想究竟是什么？

看一下这篇，有助于理解：[c++经验之谈一：RAII原理介绍 - 知乎](https://zhuanlan.zhihu.com/p/34660259)。暂时简单看看应该就行，智能指针其实就是对这种思想的封装和应用。



#### ==（i）右值引用、引用折叠、完美转发等（重点）==

复习的时候，以下是一些阅读顺序：

【1】[一文读懂C++右值引用和std::move - 知乎](https://zhuanlan.zhihu.com/p/335994370)，先看这篇；

- 对应的代码demo：rvalue_01.cpp
- 总结一下：
  - （1）右值引用本身可以是左值，也可以是右值，但是它只能被赋右值；
  - （2）引入右值引用，就是为了移动语义。移动语义就是为了减少拷贝。std::move就是将左值转为右值引用。这样就可以重载到移动构造函数了，移动构造函数将指针赋值一下就好了，不用深拷贝了，提高性能；
    - **可移动对象在<需要拷贝且被拷贝者之后不再被需要>的场景，建议使用**`std::move`**触发移动语义，提升性能。**

【2】阅读C++ primer第五版的p608页开始，对应16.2.5节开始（**讲的不错**）。

- （1）引用折叠与万能引用：16.2.5节
  - 看完这个看一下p605：进行类型转换的标准库模板类，里面介绍了`remove_reference`
- （2）理解std::move,见p610页
- （3）16.2.7节，p612，完美转发

【3】引用折叠与完美转发：

- [万能引用，引用折叠，移动构造函数，emplace_back及其实现，完美转发及其实现 - 知乎](https://zhuanlan.zhihu.com/p/260508149)
- [谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward - 知乎](https://zhuanlan.zhihu.com/p/369203981)（这篇似乎最好理解）
- [现代C++之万能引用、完美转发、引用折叠 - 知乎](https://zhuanlan.zhihu.com/p/99524127)



#### （j）悬挂指针和野指针的区别

> ### 悬挂指针（Dangling Pointer）
>
> **定义**：悬挂指针指的是一个指向已经被释放或不存在的内存地址的指针。在这种情况下，指针仍然持有旧的内存地址，但该地址上的数据已经不再有效。
>
> **产生原因**：
>
> - **对象的生命周期结束**：例如，一个局部变量在函数退出后，其内存空间会被释放，而指向该局部变量的指针就成为悬挂指针。
> - **动态内存释放**：当使用 `delete` 或 `delete[]` 释放了某个动态分配的内存，但没有将指针设为 `nullptr`，则该指针也会变成悬挂指针。
>
> **示例**：
>
> ```c++
> int* ptr; // 声明一个指针
> {
>     int value = 42;
>     ptr = &value; // ptr 指向一个局部变量
> } // value 的生命周期结束，ptr 变为悬挂指针
> 
> // 此时访问 *ptr 是未定义行为，因为它指向已释放的内存
> ```
>
> ### 野指针（Wild Pointer）
>
> **定义**：野指针指的是未初始化或者指向任意内存地址的指针。它可能指向程序的任何部分，包括无效地址，导致不可预测的行为。
>
> **产生原因**：
>
> - **未初始化**：指针声明后没有被赋值，直接使用这样的指针会导致野指针。
> - **错误的赋值**：指针被赋予一个随机值或者未定义的内存地址。
>
> **示例**：
>
> ```c++
> int* ptr; // 声明但未初始化的指针
> // 此时 ptr 是一个野指针，访问 *ptr 会导致未定义行为
> ```
>
> ### 区别总结
>
> 1. **内存状态**：
>    - 悬挂指针指向已被释放的内存区域，虽然指针本身是有效的。
>    - 野指针指向未初始化或随机的内存地址，通常在声明时即为未定义状态。
> 2. **产生原因**：
>    - 悬挂指针通常由对象生命周期结束或动态内存释放引起。
>    - 野指针主要是由于指针未初始化或错误赋值造成。
> 3. **影响与风险**：
>    - 两者都有可能导致程序崩溃或未定义行为，因此需要特别注意其管理和使用。



#### (k)顶层const与底层const

> 在C++中，`const` 关键字用于指定某些变量是不可修改的，但它有不同的层次和应用方式。特别地，顶层 `const` 和底层 `const` 是两个重要的概念，它们涉及到对象、指针和引用的常量性。以下是对这两个概念的详细解释：
>
> ### 顶层 const
>
> **定义**：顶层 `const` 指的是一个对象本身的常量性。这意味着该对象不能被重新赋值或修改。
>
> **示例**：
>
> ```c++
> const int a = 10; // a 是一个顶层 const，表示 a 的值不能被修改
> ```
>
> 在这个例子中，`a` 是一个常量整数，其值为10，其他地方不能改变这个值。
>
> ### 底层 const
>
> **定义**：底层 `const` 指的是指针或引用所指向的对象的常量性。这表明通过该指针或引用无法修改其所指向的对象。
>
> **示例**：
>
> ```c++
> int b = 20;
> const int* ptr = &b; // ptr 是一个指向 const 整数的指针，表示通过 ptr 不能修改 b 的值
> ```
>
> 在这个例子中，`ptr` 是一个指向 `const int` 的指针，这意味着你不能通过 `ptr` 来修改 `b` 的值，但可以改变 `ptr` 指向的对象，即 `ptr` 可以指向其他地址。
>
> ### 结合使用
>
> C++允许将顶层 `const` 和底层 `const` 结合使用，以控制对象和指针/引用的行为。例如，你可以声明一个指向常量的常量指针：
>
> ```c++
> const int value = 30;
> const int* const ptr = &value; // ptr 是一个指向常量整数的常量指针
> ```
>
> 在这个例子中，`ptr` 本身也是常量，这意味着不仅不能修改 `value`，而且不能使 `ptr` 指向其他地址。
>
> ### 小结
>
> - **顶层 const**：关联于对象本身，表示对象不可修改。
> - **底层 const**：关联于指针或引用的指向对象，表示通过该指针或引用不能修改其指向的对象。



#### (l)C++中的各种构造函数

https://zhuanlan.zhihu.com/p/405756420



==注：==

- ==请解析((void ()( ) )0)( )的含义：这个题应该不会考，不管他了==
- https://www.iamshuaidi.com/2456.html ：设置地址为0x67a9 的整型变量的值为0xaa66，这个优先级也没那么高
- 

# 牛客的一些题目总结

1. 智能指针、unique_ptr怎么获得控制权、unique_ptr为了解决什么问题？

   见基础八股——1.（1）.（h）

2. 右值，举一个适合使用move的场景？

   见基础八股——1.（1）.（i）

3. 引用折叠，完美转发，举一个适合使用完美转发的场景？

​	见基础八股——1.（1）.（i）


# 18 函数调用的过程具体是怎么样的？比如入栈顺序



好的，这个面试中确实很常被问到，我们用一个更通俗的例子来理解这个过程，让你能轻松记住。

就把函数调用想象成**你去图书馆借书**。

---

### 图书馆借书：一个通俗的函数调用比喻

你的大脑就是 **CPU**，图书馆的存包柜就是**栈 (Stack)**。你手头正在做的事情（比如看小说）就是你的 `main` 函数。现在，你想去借一本叫《深入理解计算机系统》的书，这个“借书”的动作就是我们要调用的一个函数，我们叫它 `borrow_book()`。

我们来一步步对应函数调用的过程：

#### 1. 准备工作（参数入栈）

*   **原文**: > 1.caller的参数压栈：按照从右到左的顺序依次压入参数...
*   **比喻**: 你要去借书，需要带上一些必要的东西，比如**借书卡**和**要借的书名**。你把这些东西（参数）一个一个放进你的背包（入栈）。比如你先放“书名”，再放“借书卡”。这就像从右到左把参数压入栈中，为调用函数做准备。

#### 2. 记住你从哪儿来（返回地址入栈）

*   **原文**: > 2.返回地址：执行`call`指令，将**下一条指令地址**（返回地址）压入栈...
*   **比喻**: 你正看到小说的第99页，现在要去图书馆了。为了回来后能继续看，你**在第99页夹了张书签**。这张“书签”就是你的**返回地址**。你把这张“书签”也放进背包的最上面（压入栈），这样借完书回来就知道从哪里继续。

#### 3. 存包，为新任务做准备（保存旧ebp，设置新ebp）

*   **原文**: > 3.保存旧ebp：被调用函数通过push ebp保存调用者的基址指针...
    > 4.设置新的ebp：`mov ebp, esp`...
*   **比喻**: 你到了图书馆，看到一排**空的存包柜**（栈空间）。
    *   首先，你不能把你自己的背包直接扔进去，万一和别人的混了怎么办？于是你先**记下你来的时候，存包柜区域的入口在哪**（保存旧ebp），这个“入口”位置能帮你找到你之前的作用域（比如`main`函数）。
    *   然后，你为自己**分配一个新的柜子**（设置新的ebp）。现在，这个柜子就是你“借书”这个任务专属的活动区域了。

#### 4. 腾出空间放新东西（分配局部变量）

*   **原文**: > 5.分配局部变量：比如`sub esp N`，调整栈顶...
*   **比喻**: 你打开你的新柜子，发现里面需要放一些接下来要用的东西，比如你可能会在图书馆里**做笔记的草稿纸**和**笔**（局部变量）。你把这些东西放进柜子，柜子里的空间就被占用了。

#### 5. 开始办理借书业务（执行函数体）

*   **原文**: > 6.执行函数体：访问参数通过ebp+偏移量...
*   **比喻**: 一切准备就绪，你开始办理借书业务。你需要拿出之前放进背包的“借书卡”和“书名”（通过ebp+偏移量访问参数），把它们交给图书管理员。图书管理员根据这些信息帮你找到了书。

#### 6. 任务完成，收拾东西准备离开（恢复栈帧）

*   **原文**: > 7.恢复栈帧：`mov esp ebp`，...接着`pop ebp`...
*   **比喻**: 你成功借到了书。现在要离开了。
    *   首先，你把你柜子里的**草稿纸和笔都扔掉**（释放局部变量空间）。
    *   然后，你**找到你之前记下的“存包柜区域入口”**（恢复旧的ebp），这样你就回到了你刚来时的状态。现在，这个柜子又空出来了，可以给下一个人用。

#### 7. 回到原来的地方（返回调用者）

*   **原文**: > 8.返回调用者：`ret`弹出返回地址，跳转回调用处；
*   **比喻**: 你离开了图书馆，从背包里拿出那张**“书签”**（弹出返回地址）。哦，原来我小说看到了第99页！于是你翻到第99页，继续你的阅读。整个借书过程顺利结束。

---

### 面试时如何记忆和回答？

当面试官问起时，你可以这样想，并简化地回答：

“函数调用就像一个任务的交接。

1.  **准备阶段**：调用者（比如main函数）先把需要传递的**参数**（比如数据）放到一个叫‘栈’的内存区域。
2.  **交接**：然后，它会记下自己执行到了哪里（**返回地址**），也存到栈里，然后跳转到被调用的函数。
3.  **新任务开始**：被调用的函数会在栈里建立自己的工作区（**新的栈帧**），用来存放它自己的**局部变量**。
4.  **执行任务**：函数利用调用者传来的参数和自己的局部变量完成计算。
5.  **任务结束并清理**：函数完成后，会**清理掉自己的工作区**（释放局部变量），这就像把自己的东西从桌子上拿走。
6.  **返回**：最后，它根据之前保存的**返回地址**，跳回到调用者中断的地方，调用者继续执行。

整个过程通过栈来管理，后进先出，保证了函数调用和返回的有序进行，即使是层层嵌套的调用也能准确无误地返回。”